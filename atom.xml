<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小康博客</title>
  
  <subtitle>计算化学与分子模拟爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kangsgo.com/"/>
  <updated>9999-11-12T12:37:22.000Z</updated>
  <id>http://kangsgo.com/</id>
  
  <author>
    <name>kangsgo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分子模拟网站推荐</title>
    <link href="http://kangsgo.com/2.html"/>
    <id>http://kangsgo.com/2.html</id>
    <published>9999-11-27T18:37:22.000Z</published>
    <updated>9999-11-12T12:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：待编辑</p><h3 id="1-内容性推荐"><a href="#1-内容性推荐" class="headerlink" title="1.内容性推荐"></a><span style="color: #3366ff;">1.内容性推荐</span></h3><h4 id="综合性网站推荐："><a href="#综合性网站推荐：" class="headerlink" title="综合性网站推荐："></a>综合性网站推荐：</h4><p><a href="http://emuch.net/bbs/forumdisplay.php?fid=322" target="_blank" rel="external">小木虫论坛</a>：一个综合性的论坛，项目非常杂，但是里面有非常多的资料分享。感觉对于交流和求知比较欠缺 。</p><p><a href="http://www.bioms.org" target="_blank" rel="external">bioms分子模拟论坛</a>：是一个专业性质的论坛，主要集中讨论计算机辅助药物设计这一快，氛围非常好，但是最近活跃度有所下降。</p><p><a href="http://jerkwin.github.io/" target="_blank" rel="external">哲科文</a>：李继存老师的个人博客，主要是gromacs的一些中文教程，老师人也非常好</p><p><a href="http://platinhom.github.io/" target="_blank" rel="external">勤力既懒猪</a>：一些模拟方面的教程</p><p><a href="http://bbs.keinsci.com/forum.php" target="_blank" rel="external">计算化学公社</a>：有论坛和门户网站，具体没有发掘~主要是看到了VMD的教程</p><p><a href="http://sobereva.com/54" target="_blank" rel="external">思想家公社的门口</a>：博客</p><p><a href="http://spaces.ac.cn/" target="_blank" rel="external">科学空间</a>: 并不是一个严格的分子模拟网站，更多的是算法相关的资源分享，还是非常推荐查看的</p><p><a href="http://blog.sina.com.cn/aj426q" target="_blank" rel="external">吴钩白的博客</a>: 我最崇拜的学长之一，知识渊博，喜欢亲切的叫他一声老师</p><p><a href="http://howiedlut.top/" target="_blank" rel="external">Howie</a>：永远相信美好的事情终将发生</p><p><a href="http://blog.csdn.net/u012325865?viewmode=contents" target="_blank" rel="external">AspirinCode</a> 和 <a href="http://www.aspirincode.com/" target="_blank" rel="external">Hexo版本</a>:  建民兄的博客，其对药物设计有非常独特的见解</p><p><a href="https://liuyujie714.github.io/" target="_blank" rel="external">Liu Yujie</a> 杰哥的博客，对gromacs有非常深的见解！</p><h4 id="QQ群："><a href="#QQ群：" class="headerlink" title="QQ群："></a>QQ群：</h4><p>BioMS分子模拟-药物设计 <span style="color: #ff6600;">68093966  </span> 【十分活跃】</p><p>药物研发科学计算 <span style="color: #ff6600;">205448601</span></p><p>GROMACS中文组 <span style="color: #ff6600;">132266540    </span>【专一性强，很热心】</p><p>「药设之道」医药R&amp;D <span style="color: #ff6600;">426442973</span></p><p>分子模拟技术交流 <span style="color: #ff6600;">397981984     <span style="color: #000000;">【田老师组织的群，很活跃】</span></span></p><p>计算生命科学  <span style="color: #ff6600;">496548248</span></p><h4 id="微信公众号："><a href="#微信公众号：" class="headerlink" title="微信公众号："></a>微信公众号：</h4><p><span style="color: #ff6600;">生物研究生</span> 分子模拟牛人小9创立的一个分享分子模拟方面内容的微信公众号</p><p><span style="color: #ff6600;">分子模拟之道</span> 李老师创办的生物模拟资讯公众号，内容不多但是篇篇精华</p><p><span style="color: #ff6600;">王初课题组</span> 好文章的推荐公众号</p><p><span style="color: #ff6600;">生信杂谈</span> 分子模拟与生物信息杂交体</p><p><span style="color: #ff6600;">克里科学苑</span>  致力于组织生命科学及医学领域科研及应用培训的专业机构</p><p><span style="color: #ff6600;">药设之道</span>  致力于向大众和专业工作者传播药物设计新方法的公众号</p><h3 id="2-软件推荐与教程"><a href="#2-软件推荐与教程" class="headerlink" title="2.软件推荐与教程"></a><span style="color: #3366ff;">2.软件推荐与教程</span></h3><p>1.序列比对</p><p>ClustaX ：  没有做过多深入了解</p><p>2.蛋白建模</p><p>2.1同源建模</p><p><a href="https://salilab.org/modeller/" target="_blank" rel="external">Modeller</a>：同源建模经典网站</p><p>Easymodeller：Modeller的可视化界面，深入学习的话不建议学</p><p><a href="http://www.swissmodel.expasy.org/" target="_blank" rel="external">Swiss-model</a>：在线建模网站，质量不错，可操控性高</p><p>2.2从头建模</p><p><a href="http://zhanglab.ccmb.med.umich.edu/" target="_blank" rel="external">I-TASSER</a>：Zhang实验室制作的一个从头建模在线服务器</p><p>Rostta：综合性软件，学术免费</p><p>2.3模型评价</p><p><a href="http://services.mbi.ucla.edu/SAVES/" target="_blank" rel="external">SAVES</a>：包含XdVal | MTZdump | Ramachandran Plot | pdbU | pdbSNAFU  | PROCHECK | Verify3D | ERRAT 多种评价，其中常用Ramachandran Plot和ERRAT2</p><p>2.4 结构准备</p><p><a href="http://openbabel.org/" target="_blank" rel="external">OpenBabel</a>：一个格式转换工具，具有本地编译包和多种语言的API</p><p><a href="http://kinemage.biochem.duke.edu/software/reduce.php" target="_blank" rel="external">Reduce</a>： 一个加氢删氢的命令行工具，仅支持PDB格式</p><p>3.分子对接</p><p><a href="http://dock.compbio.ucsf.edu/DOCK_6/index.htm" target="_blank" rel="external">DOCK</a>: UCSF DOCK,现在是第6版，同样具有柔性对接和刚性对接，对接的结果评价中等，学术免费，需要搭配Chimera使用。平台：linux</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">AutoDock</a>：最为经典的对接软件，有一款HIV药物据说就是它的功劳，使用广泛，但是速度和准确度很低，据飞天说能量打分尚可。平台：linux/windows</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">AutoDock Vina</a>： 与AutoDock为同一实验室不同课题组产物，速度和准确度都有较大的提高，算是免费里面做的最好之一了。平台：linux/windows</p><p><a href="http://gemdock.life.nctu.edu.tw/dock/igemdock.php" target="_blank" rel="external">Igemdock</a>：台湾设计的一款对接软件，选择活性区域位点比较麻烦，但是准确度高（据华中师大-精灵测试）。平台：linux/windows</p><p>LibDock： 对接速度快，Discover Studio集成，不是一般人买得起。平台：linux/windows</p><p>CDOCK：相对于LibDock更为精确。平台：linux/windows</p><p>LigandFit： 柔性对接，同上，这三款都是DS集成的对接。平台：linux/windows</p><p><a href="http://pc1664.pharmazie.uni-marburg.de/drugscore/" target="_blank" rel="external">DrugScoreX</a>： DrugScoreX是一个较新的，对于蛋白配体打分具有比DrugScore更高精度的软件，其打分功能是基于统计势能？(statistical potentials)</p><p><a href="http://kangsgo.com/665.html">LigScore</a>： 与DrugScore的算法类似,提供本地(IMP 工具包)以及在线服务。</p><p><a href="http://poseview.zbh.uni-hamburg.de/" target="_blank" rel="external">PoseViewWeb</a> : 在线的对接2D相互关系图形显示工具</p><p>4.分子模拟/分子动力学 MD</p><p><a href="http://www.gromacs.org/" target="_blank" rel="external">gromacs</a>: 一个开源的分子动力学模拟软件</p><p><a href="http://ambermd.org/" target="_blank" rel="external">Amber</a>: 一个以生物为主导的分子动力学模拟软件，GPU加速模块收费</p><p><a href="http://openmm.org/" target="_blank" rel="external">OpenMM</a>： 一个开源的分子动力学模拟软件，发展很好，但是社区和一类模拟软件还是有差距</p><p><a href="http://openmd.org/" target="_blank" rel="external">OpenMD</a>: 小型模拟软件</p><p><a href="http://www.cgmartini.nl/index.php" target="_blank" rel="external">Martini</a>: 最为流行的粗粒化力场</p><p><a href="http://kangsgo.com/681.html">LigParGen: </a>配体OPLS/CM1A力场在线生成</p><p>4.1 体积检测：</p><p><a href="http://kangsgo.com/306.html">Epock</a>   Epock是一个可以动态计算结合腔大小的一个软件，由于有VMD的可视化软件，所以非常的容易上手，简单~</p><p><a href="http://kangsgo.com/443.html"> fpocket2</a>  具有在线服务器的体积检测软件，在线服务:<a href="http://bioserv.rpbs.univ-paris-diderot.fr/services/fpocket/" target="_blank" rel="external">点我进去</a></p><p>4.2 综合轨迹分析工具</p><p><a href="http://mdtraj.org/1.9.0/" target="_blank" rel="external">MDTraj</a>  可以进行轨迹转化，氢键分析等较为底层的工具包，但是非常好用</p><p><a href="http://www.mdanalysis.org/" target="_blank" rel="external">MDAnalysis</a>  完全用Python编写的分析工具包</p><p><a href="http://www.plumed.org/" target="_blank" rel="external">PLUMED</a>  一个非常有名的分子模拟分析工具，暂时没有看</p><p>5.药效团构建</p><p>6.毒理测试</p><p>7.可视化软件</p><p><a href="http://openastexviewer.net/web/" target="_blank" rel="external">AstexViewer3.0</a>  是一个基于java的轻量级软件，虽然功能简单，但是五脏俱全，特别是可以进行电子密度图查看，相对于pymol和vmd比较容易上手，其一些软件的设置方式与pymol和vmd类似，适合新学者或者编写脚本批量分析。</p><p><a href="http://www.pymol.org/" target="_blank" rel="external">Pymol </a> 一个跨平台的可视化开源软件，后因被薛定谔公司收购，有一部分发展为闭源更新</p><p><a href="http://www.ks.uiuc.edu/Research/vmd/" target="_blank" rel="external">VMD </a> 一个以命令行为主的开源可视化软件，个人感觉发展势头优于pymol，且可以和gromacs较好的连用，NAMD，amber的集成性也较好</p><p><a href="http://www.cgl.ucsf.edu/chimera/" target="_blank" rel="external">Chimera</a>  UCSF chimera 功能强大，可以与dock连用</p><p><a href="https://www.cgl.ucsf.edu/chimerax/" target="_blank" rel="external">ChimeraX</a> 下一代可视化软件，作图美丽但是功能暂时比较少</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">PMV</a> Autodock/Autodock搭配的可视化软件，使用的人较少，一般都是用autodock搭配着使用的</p><p>8.开发库</p><p><a href="http://biopython.org/wiki/Main_Page" target="_blank" rel="external">Biopython</a>：一个Python工具包，中文文档可以<a href="http://biopython-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">点此</a>查看</p><p><a href="http://scikit-bio.org/" target="_blank" rel="external">scikit-bio</a>: 一个提供多种生物科学功能，数据结构和算法的Python包</p><p>9.综合性软件</p><p>最后更新:2017/12/09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：待编辑&lt;/p&gt;
&lt;h3 id=&quot;1-内容性推荐&quot;&gt;&lt;a href=&quot;#1-内容性推荐&quot; class=&quot;headerlink&quot; title=&quot;1.内容性推荐&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color: #3366ff;&quot;&gt;1.内容性推荐&lt;/span&gt;&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="推荐" scheme="http://kangsgo.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>系列笔记整理</title>
    <link href="http://kangsgo.com/87.html"/>
    <id>http://kangsgo.com/87.html</id>
    <published>9999-10-03T18:32:44.000Z</published>
    <updated>2018-01-10T12:57:31.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Gromacs笔记整理"><a href="#1-Gromacs笔记整理" class="headerlink" title="1.Gromacs笔记整理"></a>1.Gromacs笔记整理</h2><h3 id="1-1-安装篇"><a href="#1-1-安装篇" class="headerlink" title="1.1.安装篇"></a>1.1.安装篇</h3><p><a href="http://kangsgo.com/31.html">Gromacs2018 详细安装</a>  (兼容gromacs5.X版本)</p><p><a href="http://kangsgo.com/577.html">Gromacs CUDA版一键安装脚本</a></p><h3 id="1-2-核心教程"><a href="#1-2-核心教程" class="headerlink" title="1.2.核心教程"></a>1.2.核心教程</h3><p><a href="http://kangsgo.com/670.html">GROMACS之水中部分載脂蛋白</a></p><p><a href="http://kangsgo.com/681.html">LigParGen:配体OPLS/CM1A力场在线生成</a></p><p><a href="http://kangsgo.com/94.html">gromacs下蛋白-配体复合物模拟[GAFF]</a></p><p><a href="http://kangsgo.com/13.html">gromacs中构建非标准氨基酸残基力场</a></p><p><a href="http://kangsgo.com/156.html">gromacs下蛋白配体复合物分析</a></p><p><a href="http://kangsgo.com/694.html">Gromacs 5.1.2做拉伸动力学的几点笔记</a></p><h3 id="1-2-1-g-mmpbsa教程"><a href="#1-2-1-g-mmpbsa教程" class="headerlink" title="1.2.1 g_mmpbsa教程"></a>1.2.1 g_mmpbsa教程</h3><p><a href="http://kangsgo.com/18.html">g_mmpbsa之简单教程/结合自由能计算</a></p><p><a href="http://kangsgo.com/17.html">g_mmpbsa之参数注释</a></p><p><a href="http://kangsgo.com/295.html">GMXPBSAtool安装与使用经验教程</a></p><h3 id="1-3-小技巧合集"><a href="#1-3-小技巧合集" class="headerlink" title="1.3.小技巧合集"></a>1.3.小技巧合集</h3><p><a href="http://kangsgo.com/106.html">Gromacs共轭梯度法mdp设置</a></p><h2 id="2-Rosetta笔记整理"><a href="#2-Rosetta笔记整理" class="headerlink" title="2.Rosetta笔记整理"></a>2.Rosetta笔记整理</h2><h3 id="2-1-安装篇"><a href="#2-1-安装篇" class="headerlink" title="2.1.安装篇"></a>2.1.安装篇</h3><h3 id="2-2-完整教程"><a href="#2-2-完整教程" class="headerlink" title="2.2.完整教程"></a>2.2.完整教程</h3><p><a href="http://kangsgo.com/647.html">Rosetta蛋白蛋白对接</a><br><a href="http://kangsgo.com/657.html">Rosetta从头结构预测</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Gromacs笔记整理&quot;&gt;&lt;a href=&quot;#1-Gromacs笔记整理&quot; class=&quot;headerlink&quot; title=&quot;1.Gromacs笔记整理&quot;&gt;&lt;/a&gt;1.Gromacs笔记整理&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装篇&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pymol核酸绘图</title>
    <link href="http://kangsgo.com/23.html"/>
    <id>http://kangsgo.com/23.html</id>
    <published>2018-03-13T05:09:30.000Z</published>
    <updated>2018-03-13T06:39:52.920Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道chimera的核酸绘图功能非常强大，一般大家理解的pymol核酸绘图功能就显得薄弱了，但是今天在看pymol的cartoon的时候无意间看到了其核酸绘图，发现实际上其功能还是不错的。</p><h2 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h2><p>默认的一般有一个磷酸骨架和一个跨过核苷酸平面的枝棒，默认设置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set cartoon_nucleic_acid_mode, 0 # 骨架随后的磷酸盐，实际上pymol默认设置为4</div><div class="line">set cartoon_ladder_mode, 1 # 从骨架到核苷酸的枝条</div><div class="line">set cartoon_ring_mode, 0 # 没有核酸环</div><div class="line">set cartoon_ring_finder, 1 # 核糖和基本环 (因为ring mode 0，所以这里设置什么都不会展示)</div></pre></td></tr></table></figure></p><p>我们以PDB<code>265d</code>为例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch <span class="number">265</span>d</div><div class="line">remove resname HOH</div><div class="line">remove resname MG</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><h2 id="Cartoon-环模式（ring-mode）"><a href="#Cartoon-环模式（ring-mode）" class="headerlink" title="Cartoon 环模式（ring mode）"></a>Cartoon 环模式（ring mode）</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ring_mode, value</p><p><strong>值影响</strong></p><p>0  枝条从骨架原子到嘌呤的N1或嘧啶的N3<br>1  简单的核糖平面和覆盖环键之间区域的基环<br>2  简单的核糖平面和覆盖环键内侧之间区域的基环（和模式1相比略小）<br>3  用棍棒包围核糖和基环的平面<br>4  在核糖中心和每个基环上的大直径环球体<br>5  大约为4的1/10的球体</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure></p><p>模式3：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure></p><p>模式4：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure></p><h2 id="Cartoon-ring-finder"><a href="#Cartoon-ring-finder" class="headerlink" title="Cartoon ring finder"></a>Cartoon ring finder</h2><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ring_finder, value</p><p><strong>值影响</strong></p><p>0 没有环或枝条加入<br>1 核糖和基础环<br>2 只有基础环<br>3 和模式1类似，轻微的透视<br>4 和模式1类似，核糖核苷酸和碱基，以及蛋白质的芳香侧链显示<br>5 只有枝条，无环</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/7.png" alt="图片7" title="">                </div>                <div class="image-caption">图片7</div>            </figure></p><h2 id="Cartoon梯子模式"><a href="#Cartoon梯子模式" class="headerlink" title="Cartoon梯子模式"></a>Cartoon梯子模式</h2><h3 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ladder_mode, value</p><p><strong>值影响</strong><br>0 没有枝条展示<br>1 枝条展示</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/8.png" alt="图片8" title="">                </div>                <div class="image-caption">图片8</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><h2 id="Cartoon核酸模式"><a href="#Cartoon核酸模式" class="headerlink" title="Cartoon核酸模式"></a>Cartoon核酸模式</h2><h3 id="设置-3"><a href="#设置-3" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_nucleic_acid_mode, value</p><p><strong>值影响</strong><br>0    光滑的骨架通过磷原子，骨架的两端均终止于磷末端<br>1    光滑的骨架通过核糖C3’原子，骨架的两端最后C3’终止<br>2    光滑的骨架通过磷原子，主链在5’末端终止于磷，在3’末端终止于O3’<br>3    和0模式相似？<br>4    和模式2相似？</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/9.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/10.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道chimera的核酸绘图功能非常强大，一般大家理解的pymol核酸绘图功能就显得薄弱了，但是今天在看pymol的cartoon的时候无意间看到了其核酸绘图，发现实际上其功能还是不错的。&lt;/p&gt;
&lt;h2 id=&quot;默认设置&quot;&gt;&lt;a href=&quot;#默认设置&quot; class
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>Pymol渲染（Ray）笔记</title>
    <link href="http://kangsgo.com/22.html"/>
    <id>http://kangsgo.com/22.html</id>
    <published>2018-02-26T05:09:30.000Z</published>
    <updated>2018-02-26T05:33:41.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ray"><a href="#Ray" class="headerlink" title="Ray"></a>Ray</h1><p><strong>ray</strong>将会创建一个现在的框架图像的渲染（ray-traced）图像。我们平常使用pymol的时候可能就是直接ray一下出图，其实ray有许多功能可以挖掘，这里简单介绍一小部分。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ray [width,height [,renderer [,angle [,<span class="built_in">shift</span> ]]]</div></pre></td></tr></table></figure><p><strong>angle</strong>和<strong>shift</strong>将会生成立体的配对<br><strong>width</strong>和<strong>height</strong>为设置ray的长宽，可以超出现在的框架</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>默认图像</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><p>简单渲染<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#全部使用默认设置</span></div><div class="line">ray</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure><h2 id="PyMol-API"><a href="#PyMol-API" class="headerlink" title="PyMol API"></a>PyMol API</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd.ray(int width,int height,int renderer=<span class="number">-1</span>,float shift=<span class="number">0</span>)</div></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h3><p>设置<strong>Ray_trace_mode</strong>设置可以修改最终成图的时候的PyMOL的内部渲染蛋白的模式.<br>下面可以查看不同模式的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 普通颜色</div><div class="line">set ray_trace_mode, 0</div><div class="line"></div><div class="line"># 普通颜色+黑色线</div><div class="line">set ray_trace_mode, 1</div><div class="line"></div><div class="line"># 仅包含黑色线</div><div class="line">set ray_trace_mode, 2</div><div class="line"></div><div class="line"># 倍色+黑色线</div><div class="line">set ray_trace_mode, 3</div><div class="line"></div><div class="line"># 建议设置</div><div class="line">set antialias, 2</div><div class="line"></div><div class="line"># 更改线的颜色</div><div class="line">set ray_trace_color, magenta</div></pre></td></tr></table></figure><p>效果如下</p><p>ray_trace_mode, 1<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure></p><p>ray_trace_mode, 2<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure></p><p>ray_trace_mode, 3<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure></p><p>ray_trace_color, magenta<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><h3 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h3><p>在0.98版本以后，渲染速度得到了提升，选择的开关如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set orthoscopic, off</div><div class="line"></div><div class="line">set orthoscopic, on</div></pre></td></tr></table></figure></p><p>放大近景如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set field_of_view, X</div></pre></td></tr></table></figure></p><p>当50&lt;X&lt;70，默认为20.50-70 拥有非常强的透视效果。透视的轴为Y轴，而不是X轴</p><p>orthoscopic, off<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-7.png" alt="图片7" title="">                </div>                <div class="image-caption">图片7</div>            </figure></p><p>orthoscopic, on<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-8.png" alt="图片8" title="">                </div>                <div class="image-caption">图片8</div>            </figure></p><p>set field_of_view, 70<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-9.png" alt="图片9" title="">                </div>                <div class="image-caption">图片9</div>            </figure></p><p>不知道为何我做出来没有效果，可以看官方的图例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-10.png" alt="图片10" title="">                </div>                <div class="image-caption">图片10</div>            </figure><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>renderer = -1 为默认渲染<br>renderer = 0 为PyMOL内部渲染器<br>renderer = 1 使用PovRay渲染器， <strong>Unix-only </strong></p><p>例子如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ray trace with an external renderer.</span></div><div class="line">ray renderer=<span class="number">0</span></div></pre></td></tr></table></figure></p><p>比较了一下-1和0模式的效果差别不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ray&quot;&gt;&lt;a href=&quot;#Ray&quot; class=&quot;headerlink&quot; title=&quot;Ray&quot;&gt;&lt;/a&gt;Ray&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ray&lt;/strong&gt;将会创建一个现在的框架图像的渲染（ray-traced）图像。我们平常使用pymol的时候可
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>利用OpenBabel生成多个构像</title>
    <link href="http://kangsgo.com/21.html"/>
    <id>http://kangsgo.com/21.html</id>
    <published>2018-01-19T08:10:20.000Z</published>
    <updated>2018-01-20T12:38:10.201Z</updated>
    
    <content type="html"><![CDATA[<p>此文感谢建民兄的指导，才让我学习到这么有用的工具</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>有许多软件例如<code>Dock 6.8</code>，对于小分子的柔性对接支持并不那么好，这就导致了因为初始构像的不正确而导致了对接结果的不正确和不可靠，为了解决这个问题一个方法就是进行构像的生成，再进行多对接，整理得分排序。当然还有一个应用就是用于3D药效团的使用。网上有许多在线网站可以进行这方面的工作，但是最好用的我感觉还是openbabel神器！</p><h2 id="利用openbabel生成多构像"><a href="#利用openbabel生成多构像" class="headerlink" title="利用openbabel生成多构像"></a>利用openbabel生成多构像</h2><p>Open Babel提供了两种构像生成的算法代码:</p><ol><li>Confab: 一个成体系的构像生成器，有序的生成所有的低能量构像</li><li>遗传算法: 是一个随机构像产生器，能够根据RMSD或者能量的不同达到优化的目的</li></ol><h3 id="1-遗传算法"><a href="#1-遗传算法" class="headerlink" title="1. 遗传算法"></a>1. 遗传算法</h3><p>了解算法的命令信息可以使用:<code>obabel -L conformer</code>查看。虽然查看是说的构像搜寻，但是可以使用<code>--writeconformers</code>对生成的构像进行保存。可以查看如下的生成30个构像的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel startingConformer.mol -O ga_conformers.sdf --conformer --nconf 30  --score rmsd --writeconformers</div></pre></td></tr></table></figure></p><p>其中<code>--score rmsd</code>可以不写，因为默认就是使用这种方式</p><p>当然生成的构像在1个文件里，我们有时候需要split，当然首先想到的还是<code>obabel</code>,其进行拆分相当于高射炮打蚊子–相当好用呀（&lt;-原谅我在这里乱用歇后语），示例如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel ga_conformers.sdf -O new.mol -m</div></pre></td></tr></table></figure></p><p>我自己的输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">32 molecules converted</div><div class="line">32 files output. The first is molecule/new1.mol2</div></pre></td></tr></table></figure></p><h3 id="2-Confab"><a href="#2-Confab" class="headerlink" title="2. Confab"></a>2. Confab</h3><p>Confab 生成分子的低能量构像分子集合。设置命令为<code>--confab</code>,同样可以使用<code>obabel -L confab</code>进行查看了解。<br>使用简单的设置操作如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel &lt;inputfile&gt; -O &lt;outputfile&gt; --confab [confab options]</div></pre></td></tr></table></figure></p><p>其还有一个额外的应用就是<strong>confabreport format</strong>，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel &lt;inputfile&gt; [-O &lt;outputfile&gt;] -o confabreport -xf &lt;reference_file&gt; [-xr &lt;rmsd&gt;]</div></pre></td></tr></table></figure></p><p>主要是为了和初始构像进行比较。</p><p>下面是其中一个例子，首先生成100K个构像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; obabel bostrom.sdf -O confs.sdf --confab --conf 100000</div><div class="line"></div><div class="line">**Starting Confab 1.1.0</div><div class="line">**To support, cite Journal of Cheminformatics, 2011, 3, 8.</div><div class="line">..Input format = sdf</div><div class="line">..Output format = sdf</div><div class="line">..RMSD cutoff = 0.5</div><div class="line">..Energy cutoff = 50</div><div class="line">..Conformer cutoff = 1000000</div><div class="line">..Write input conformation? False</div><div class="line">..Verbose? False</div><div class="line"></div><div class="line">**Molecule 1</div><div class="line">..title = 1a28_STR_1_A_1__C__</div><div class="line">..number of rotatable bonds = 1</div><div class="line">..tot conformations = 12</div><div class="line">..tot confs tested = 12</div><div class="line">..below energy threshold = 10</div><div class="line">..generated 3 conformers</div><div class="line"></div><div class="line">... etc, etc</div><div class="line"></div><div class="line">0 molecules converted</div></pre></td></tr></table></figure></p><p>统计多少个构像和初始构像相比RMSD小于1.0A<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; obabel confs.sdf -oconfabreport -xf bostrom.sdf -xr 1.0</div><div class="line"></div><div class="line">**Generating Confab Report</div><div class="line">..Reference file = bostrom.sdf</div><div class="line">..Conformer file = confs.sdf</div><div class="line"></div><div class="line">..Molecule 1</div><div class="line">..title = 1a28_STR_1_A_1__C__</div><div class="line">..number of confs = 3</div><div class="line">..minimum rmsd = 0.0644801</div><div class="line">..confs less than cutoffs: 0.2 0.5 1 1.5 2 3 4 100</div><div class="line">..1 1 3 3 3 3 3 3</div><div class="line">..cutoff (1) passed =  Yes</div><div class="line"></div><div class="line">... etc, etc</div><div class="line"></div><div class="line">**Summary</div><div class="line">..number of molecules = 36</div><div class="line">..less than cutoff(1) = 35</div><div class="line">52271 molecules converted</div></pre></td></tr></table></figure></p><p>我做的一个的简单应用（批量读取文件对接），不提供部分代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> ucsfdock.docksh <span class="keyword">import</span> PreDock</div><div class="line"><span class="keyword">from</span> ucsfdock.dockfile <span class="keyword">import</span> Dock</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment">#计时器工具</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line">time_start=time.time()</div><div class="line"></div><div class="line">DOCKHOME=<span class="string">'/home/kangsgo/install/dock6/bin/'</span></div><div class="line"><span class="comment">#run=PreDock(DOCKHOME=DOCKHOME)</span></div><div class="line"><span class="comment">#run.onerun()</span></div><div class="line">dock=Dock(DOCKHOME=DOCKHOME)</div><div class="line"><span class="comment">#遍历molecule目录下所有的文件</span></div><div class="line"><span class="keyword">for</span> (dirpath,dirnames,filenames) <span class="keyword">in</span> os.walk(<span class="string">'molecule'</span>):</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> filenames:</div><div class="line">        print(<span class="string">'开始执行'</span>+i+<span class="string">'文件'</span>)</div><div class="line">        dock.dock(mode=<span class="number">2</span>,ligand_atom_file=<span class="string">'molecule/'</span>+i,ligand_outfile_prefix=<span class="string">'out1/'</span>+i[:<span class="number">-5</span>])</div><div class="line"><span class="comment">#dock.dock(mode=2,ligand_atom_file='2.mol2')</span></div><div class="line">print(<span class="string">"done!"</span>)</div><div class="line">time_end=time.time()</div><div class="line">print(<span class="string">"耗时为"</span>+str(time_end-time_start)+<span class="string">" 秒"</span>)</div></pre></td></tr></table></figure></p><p>参考资料:</p><ol><li><a href="http://open-babel.readthedocs.io/en/latest/3DStructureGen/multipleconformers.html" target="_blank" rel="external">Generate multiple conformers</a></li><li><a href="http://open-babel.readthedocs.io/en/latest/Command-line_tools/babel.html" target="_blank" rel="external">obabel and babel</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此文感谢建民兄的指导，才让我学习到这么有用的工具&lt;/p&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;有许多软件例如&lt;code&gt;Dock 6.8&lt;/code&gt;，对于小分子的柔性对
      
    
    </summary>
    
      <category term="预处理" scheme="http://kangsgo.com/categories/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
    
      <category term="OpenBabel" scheme="http://kangsgo.com/tags/OpenBabel/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本文件夹内文件依次执行</title>
    <link href="http://kangsgo.com/20.html"/>
    <id>http://kangsgo.com/20.html</id>
    <published>2018-01-18T04:05:29.000Z</published>
    <updated>2018-01-18T05:00:23.656Z</updated>
    
    <content type="html"><![CDATA[<p>这个脚本非常简单，个人觉得也很实用，对于初学linux或者bash的小伙伴们，我觉得在很多地方可以解放我们的小手。<br>写的这个脚本是因为师弟师妹们有很多高斯文件需要计算，高斯的计算文件一般以<code>gjf</code>或者<code>com</code>结尾。所以要师弟师妹们把文件放到一个文件夹下，然后批量执行。<br>为了以后的方便我还写了通过识别后缀是否执行。脚本全文如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls` ;<span class="keyword">do</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"文件的后缀为"</span><span class="variable">$&#123;i##*.&#125;</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;i##*.&#125;</span> = <span class="string">"gjf"</span> ]||[ <span class="variable">$&#123;i##*.&#125;</span> = <span class="string">"com"</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$i</span><span class="string">"后缀正确，开始计算"</span></div><div class="line">g09 <span class="variable">$i</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"计算完成"</span></div></pre></td></tr></table></figure></p><p>首先通过一个for循环结合<code>ls</code>查看文件命令依次读取文件，然后用一个<code>if</code>命令判定后缀是否后缀正确，<br><code>##*.</code>表示删除最后一个点以及左边的字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个脚本非常简单，个人觉得也很实用，对于初学linux或者bash的小伙伴们，我觉得在很多地方可以解放我们的小手。&lt;br&gt;写的这个脚本是因为师弟师妹们有很多高斯文件需要计算，高斯的计算文件一般以&lt;code&gt;gjf&lt;/code&gt;或者&lt;code&gt;com&lt;/code&gt;结尾。所以要
      
    
    </summary>
    
      <category term="Linux" scheme="http://kangsgo.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://kangsgo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux GTX1080TI安装显卡驱动小记</title>
    <link href="http://kangsgo.com/19.html"/>
    <id>http://kangsgo.com/19.html</id>
    <published>2018-01-11T09:50:28.000Z</published>
    <updated>2018-01-11T02:30:53.092Z</updated>
    
    <content type="html"><![CDATA[<p>我这辈子没有见过什么世面，之前用的最好的显卡就是GTX750Ti了，有幸来到一个还算有钱的课题组，导师给配了一台装有E5-2696 v3 CPU，GTX1080TI显卡的电脑，不甚欢喜，爱不释手。没想到是填坑的开始，前前后后捣鼓了一个星期，把其中的坑慢慢总结，今天先记录一下我安装记录:</p><p>由于GTX1080TI在linux下没有开源驱动，所以安装ubuntu后啥也没有，需要安装闭源驱动。点此进入<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external">下载地址</a>。由于我的CPU没有集成显卡，无奈只能在旧机器上弄了一个GT630装上，其实也可以把硬盘取下来，安装好后再重新装上。</p><p>安装好后进行驱动的安装，简要如下:</p><p>a) 禁用nouveau<br>终端中运行：<code>lsmod | grep nouveau</code>，如果有输出则代表nouveau正在加载。</p><p>Ubuntu的nouveau禁用方法：<br>在<code>/etc/modprobe.d</code>中创建文件<code>blacklist-nouveau.conf</code>，在文件中输入一下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">blacklist nouveau</div><div class="line">options nouveau modeset=0</div></pre></td></tr></table></figure><p>打开终端，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-initramfs –u</div></pre></td></tr></table></figure></p><p>设置完毕可以再次运行 <code>lsmod | grep nouveau</code>检查是否禁用成功，如果运行后没有任何输出，则代表禁用成功。</p><p>b) 重启电脑，到达登录界面时，<code>alt+ctrl+f1</code>，进入text mode，登录账户</p><p>c) 输入<code>sudo service lightdm stop</code>关闭图形化界面</p><p>d) 切换到cuda安装文件的路径，运行<code>sudo sh cuda_9.1.18_linux.run</code> (可能不同)</p><p>按照提示一步步操作</p><p>安装成功后，会显示<strong>installed</strong>，否则会显示<strong>failed</strong>。</p><p>e) 输入 $ sudo service lightdm start 重新启动图形化界面。</p><p>Alt + ctrl +F7，返回到图形化登录界面，输入密码登录。<br>如果能够成功登录，则表示不会遇到循环登录的问题，基本说明CUDA的安装成功了。</p><p>f) 重启电脑。检查<strong>Device Node Verification</strong>。</p><p>检查路径/dev下 有无存在名为nvidia*（以nvidia开头）的多个文件(device files)<br>如果没有的话，可以参考官方文档里的指导步骤，进行添加。</p><p>若安装了CUDA，则需要设置环境变量，具体可以查看<a href="http://kangsgo.com/40.html">这一篇</a>文章。</p><p>参考:<a href="http://blog.csdn.net/masa_fish/article/details/51882183" target="_blank" rel="external">Ubuntu 14.04 上安装 CUDA 7.5/8.0 超详细教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我这辈子没有见过什么世面，之前用的最好的显卡就是GTX750Ti了，有幸来到一个还算有钱的课题组，导师给配了一台装有E5-2696 v3 CPU，GTX1080TI显卡的电脑，不甚欢喜，爱不释手。没想到是填坑的开始，前前后后捣鼓了一个星期，把其中的坑慢慢总结，今天先记录一下
      
    
    </summary>
    
      <category term="Linux" scheme="http://kangsgo.com/categories/Linux/"/>
    
    
      <category term="安装" scheme="http://kangsgo.com/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>g_mmpbsa之参数注释</title>
    <link href="http://kangsgo.com/17.html"/>
    <id>http://kangsgo.com/17.html</id>
    <published>2018-01-10T14:23:09.000Z</published>
    <updated>2018-01-10T12:35:44.253Z</updated>
    
    <content type="html"><![CDATA[<p>MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。<br>g_mmpbsa是一个针对GROMACS程序使用的MM/PBSA方法，最近在群里讨论非常多，最近一个膜蛋白体系使用该方法做出的结果发现一些问题，最近在找问题，所以先把g_mmpbsa的参数进行了研读，在这里分享给大家。</p><h2 id="极性溶剂化能-Polar-Solvation-Energy-输入关键字"><a href="#极性溶剂化能-Polar-Solvation-Energy-输入关键字" class="headerlink" title="极性溶剂化能(Polar Solvation Energy)输入关键字"></a>极性溶剂化能(Polar Solvation Energy)输入关键字</h2><h4 id="polar"><a href="#polar" class="headerlink" title="polar"></a>polar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">polar             = yes</div></pre></td></tr></table></figure><p>是否计算极性溶剂化能，如果不需要进行极性计算，值可以变为<code>no</code></p><h4 id="cfac"><a href="#cfac" class="headerlink" title="cfac"></a>cfac</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfac              = 2</div></pre></td></tr></table></figure><p><strong>扩大</strong>分子尺寸来获得粗糙的格点尺寸的因子.如果是非常简单的边界条件或者非常高的带电分子，那么值需要增加。APBS程序中默认值为<code>1.7</code></p><h4 id="fadd"><a href="#fadd" class="headerlink" title="fadd"></a>fadd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fadd               = 20</div></pre></td></tr></table></figure><p><strong>增加</strong>分子尺寸的数值(埃级别)来获得精确的格点尺寸。在高电荷分子中该值需要被增加来阻止等界限被截断</p><h4 id="gridspace"><a href="#gridspace" class="headerlink" title="gridspace"></a>gridspace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gridspace           =  0.2</div></pre></td></tr></table></figure><p>微调格点空间的特异值(埃界别).若为精细计算，那么需要0.5A或者更低的值，若需要初略计算，则可以增加数值</p><h4 id="gmemceil"><a href="#gmemceil" class="headerlink" title="gmemceil"></a>gmemceil</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gmemceil              = 4000</div></pre></td></tr></table></figure><p>设置的最大内存值(MB)</p><h4 id="PBsolver"><a href="#PBsolver" class="headerlink" title="PBsolver"></a>PBsolver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PBsolver               = npbe</div></pre></td></tr></table></figure><p>选择线性还是非线性波尔兹曼公式来解决问题。关键字<code>lpbe</code>和<code>npbe</code>分别表示线性和传统的非线性PB公式。在极性计算中不同的值的影响已被调查过。对于高电荷体系，使用非线性PB公式是必须的。</p><h4 id="mg-type"><a href="#mg-type" class="headerlink" title="mg-type"></a>mg-type</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mg-type                 = mg-auto</div></pre></td></tr></table></figure><p>接受<code>mg-auto</code>和<code>mg-para</code>两个关键字<br><code>mg-auto</code>将会自动设置顺序进行多格点PB计算<br><code>mg-para</code>将会自动设置线程进行多格点PB计算（此需要自己编译APBS版本和mpirun）</p><h4 id="pcharge"><a href="#pcharge" class="headerlink" title="pcharge"></a>pcharge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pcharge                   =  1</div></pre></td></tr></table></figure><p>溶液中正电荷离子电荷</p><h4 id="prad"><a href="#prad" class="headerlink" title="prad"></a>prad</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prad                       =  0.95</div></pre></td></tr></table></figure><p>正电荷离子半径</p><h4 id="pconc"><a href="#pconc" class="headerlink" title="pconc"></a>pconc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pconc                       =  0.150</div></pre></td></tr></table></figure><p>正电荷离子浓度</p><h4 id="ncharge"><a href="#ncharge" class="headerlink" title="ncharge"></a>ncharge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ncharge                      =  -1</div></pre></td></tr></table></figure><p>溶液中负电荷离子电荷</p><h4 id="nrad"><a href="#nrad" class="headerlink" title="nrad"></a>nrad</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nrad                          =  1.81</div></pre></td></tr></table></figure><p>负电荷离子半径</p><h4 id="nconc"><a href="#nconc" class="headerlink" title="nconc"></a>nconc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nconc                         = 0.150</div></pre></td></tr></table></figure><p>负电荷离子浓度</p><h4 id="pdie"><a href="#pdie" class="headerlink" title="pdie"></a>pdie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pdie                           =   4</div></pre></td></tr></table></figure><p>溶解电解质常数值。此值需要依据计算的溶质对象进行改变。对于高电荷溶质高的电介质值将会产生更加准确的极性溶解能。</p><h4 id="sdie"><a href="#sdie" class="headerlink" title="sdie"></a>sdie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdie                           =  80</div></pre></td></tr></table></figure><p>溶剂介电常数</p><h4 id="vdie"><a href="#vdie" class="headerlink" title="vdie"></a>vdie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vdie                           =   1</div></pre></td></tr></table></figure><p>真空下介电常数</p><h4 id="srad"><a href="#srad" class="headerlink" title="srad"></a>srad</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">srad                             =  1.4</div></pre></td></tr></table></figure><p>溶剂分子半径，水类似物状的分子表面一般设置为1.4埃</p><h4 id="swin"><a href="#swin" class="headerlink" title="swin"></a>swin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swin                            =  0.30</div></pre></td></tr></table></figure><p>这为基于样条曲线的曲面定义指定了三次样条曲线窗口的值。 在计算中使用基于探针的表面时不使用.所以一般不需要修改</p><h4 id="srfm"><a href="#srfm" class="headerlink" title="srfm"></a>srfm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">srfm                            =   smol</div></pre></td></tr></table></figure><p>这指定了用来构造介电和离子可及性系数的模型.关键字接受<code>mol</code>,<code>smol</code>,<code>spl2</code>和<code>spl4</code>，其会影响极性能计算。该关键字指定用于构建溶剂相关表面和体积的模型</p><h4 id="sdens"><a href="#sdens" class="headerlink" title="sdens"></a>sdens</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdens                            =   10</div></pre></td></tr></table></figure><p>指定构建分子表面或溶剂可及表面的每个Å2的网格点数。 当srad = 0.0或srfm = spl2时不考虑</p><h4 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">temp                              =  300</div></pre></td></tr></table></figure><p>温度</p><h4 id="chgm"><a href="#chgm" class="headerlink" title="chgm"></a>chgm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chgm                               = spl4</div></pre></td></tr></table></figure><p>这指定了用于将生物分子点电荷映射到网格的方法，用于多重格点波尔兹曼计算。 接受的关键字是<code>spl0</code>，<code>spl2</code>和<code>spl4</code><br><code>spl0</code> 传统的三线插值法(线性样条函数 Traditional trilinear interpolation )，产生的电位对网格间距，长度和位置非常敏感。<br><code>spl2</code>立体B-线性样条离散化(Cubic B-spline discretization)，相对spl0敏感度低<br><code>spl4</code>五次B-线性样条离散化(Quintic B-spline discretization)<br>该值的变化没有被测试过</p><h4 id="bcfl"><a href="#bcfl" class="headerlink" title="bcfl"></a>bcfl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bcfl                               = mdh</div></pre></td></tr></table></figure><p>特定的边界条件类型来解决波尔兹曼公式。关键字接受<code>zero</code>,<code>sdh</code>,<code>mdh</code>,<code>focus</code>和<code>map</code>。其中<code>focus</code>和<code>map</code>或导致g_mmpbsa终止。<code>zero</code>不是很常用。<code>sdh</code>当在边界条件很远的时候效果较好。<code>mdh</code>速度较慢</p><h2 id="非极性溶剂化能-Polar-Solvation-Energy-输入关键字"><a href="#非极性溶剂化能-Polar-Solvation-Energy-输入关键字" class="headerlink" title="非极性溶剂化能(Polar Solvation Energy)输入关键字"></a>非极性溶剂化能(Polar Solvation Energy)输入关键字</h2><h4 id="apolar"><a href="#apolar" class="headerlink" title="apolar"></a>apolar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apolar                              =  yes</div></pre></td></tr></table></figure><p>是否进行非极性溶剂化能计算</p><h3 id="SASA模型"><a href="#SASA模型" class="headerlink" title="SASA模型"></a>SASA模型</h3><h4 id="gamma"><a href="#gamma" class="headerlink" title="gamma"></a>gamma</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gamma                                = 0.02267</div></pre></td></tr></table></figure><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。&lt;br&gt;g_mmpbsa是一个针对GROMACS程序使用的MM/PBSA方法，最近在群里讨论非常多，最近一个膜蛋白体系使用该方法做出的结果发现一些问题，最近在找问题，所以先把g_mmpbsa的参
      
    
    </summary>
    
      <category term="Gromacs" scheme="http://kangsgo.com/categories/Gromacs/"/>
    
    
  </entry>
  
  <entry>
    <title>g_mmpbsa之简单教程</title>
    <link href="http://kangsgo.com/18.html"/>
    <id>http://kangsgo.com/18.html</id>
    <published>2018-01-10T14:20:09.000Z</published>
    <updated>2018-01-10T12:35:22.626Z</updated>
    
    <content type="html"><![CDATA[<p>MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。<br>相对于自由能微扰(FEP)和热力学积分(TI),虽然准确度相对较低，但其计算量相对较小，比较适用于生物大分子体系。是一种对MD轨迹进行后处理以估计结合自由能的方法, 计算时会将溶剂视为均匀的连续介质, 并基于力场和隐式的连续介质模型, 对平衡轨迹中的许多帧进行平均, 以考虑温度的影响。其实该教程网上很多地方有，我之前也做过很多次，在这里仅做简单介绍，其实只是想引出后面的文章做一个系列。</p><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>首先从这里<a href="http://rashmikumari.github.io/g_mmpbsa/Download-and-Installation.html" target="_blank" rel="external">下载</a>对应版本,GROMACS2016和GROMACS2018版本都可以下载GROMACS-5.1.<br>版本。建议下载包括APBS版本，但改版本APBS无法进行多线程。记得把脚本也都下载下来。</p><h3 id="预编译版本"><a href="#预编译版本" class="headerlink" title="预编译版本"></a>预编译版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -zxvf g_mmpbsa.tar.gz</div><div class="line"><span class="built_in">cd</span> bin</div><div class="line">sudo cp g_mmpbsa /usr/<span class="built_in">local</span>/bin/.</div><div class="line">sudo cp energy2bfac /usr/<span class="built_in">local</span>/bin/.</div></pre></td></tr></table></figure><p>或导入<code>$HOME</code>中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar -zxvf g_mmpbsa.tar.gz</div><div class="line"><span class="built_in">cd</span> bin</div><div class="line">cp g_mmpbsa <span class="variable">$HOME</span>/bin/.</div><div class="line">cp energy2bfac <span class="variable">$HOME</span>/bin/.</div></pre></td></tr></table></figure></p><p>或设置环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/path/to/g_mmpbsa/bin</div></pre></td></tr></table></figure></p><h3 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h3><p>略</p><h2 id="下载教程包"><a href="#下载教程包" class="headerlink" title="下载教程包"></a>下载教程包</h2><p>你可以<a href="http://rashmikumari.github.io/g_mmpbsa/tutorial.tar.gz" target="_blank" rel="external">从此</a>下载教程包，并进行解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -zxvf tutorial.tar.gz</div><div class="line"><span class="built_in">cd</span> tutorial</div><div class="line"><span class="built_in">cd</span> 1EBZ</div></pre></td></tr></table></figure><p>其目录下包括HIV-1蛋白酶及其抑制剂的拓扑参数(tpr),索引文件(ndx)和轨迹(xtc)文件</p><h2 id="GMXLIB环境变量"><a href="#GMXLIB环境变量" class="headerlink" title="GMXLIB环境变量"></a>GMXLIB环境变量</h2><p>如果GROMACS为自定义安装，设置GMXLIB环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> GMXLIB=/opt/gromacs/share/gromacs/top</div></pre></td></tr></table></figure></p><h2 id="计算三个能量组件"><a href="#计算三个能量组件" class="headerlink" title="计算三个能量组件"></a>计算三个能量组件</h2><p>结合能计算包括三个能量项目（a）真空中的势能，（b）极性溶剂化能和（c）非极性溶剂化能。这些能量可以一步计算或三步计算</p><h3 id="三步计算"><a href="#三步计算" class="headerlink" title="三步计算"></a>三步计算</h3><p>（a）真空中的势能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -pdie 2 -decomp</div></pre></td></tr></table></figure></p><p>选择时第一次选择蛋白，第二次选择配体，计算将会得到<code>energy_MM.xvg</code>和<code>contrib_MM.dat</code>。<code>energy_MM.xvg</code>文件包含范德华力，静电相互作用以及蛋白质和抑制剂之间的非结合势能。 <code>contrib_MM.dat</code>包含每个残基对计算得到的非结合势能的贡献。</p><p>（b）计算极性溶剂化能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../polar.mdp -nomme -pbsa -decomp</div></pre></td></tr></table></figure></p><p>选择时第一次选择蛋白，第二次选择配体，计算将会得到<code>polar.xvg</code>和<code>contrib_pol.dat</code>。<code>polar.xvg</code>含有未结合蛋白，未结合抑制剂和蛋白抑制剂复合物的极性溶剂化能。<code>contrib_pol.dat</code>包含每个残基对计算的净极性溶剂化能的贡献。</p><p>（c）计算非极性溶剂化能<br>非极性溶剂化能包含三种，分别为SASA，SAV和WCA-like模型，其实据我经验非极性溶剂化能只是很小的一部分能量，一般。这里按照教程来的介绍两个。</p><p><strong>SASA模型</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sasa.mdp -nomme -pbsa -decomp -apol sasa.xvg -apcon sasa_contrib.dat</div></pre></td></tr></table></figure></p><p><strong>SAV模型</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sav.mdp -nomme -pbsa -decomp -apol sav.xvg -apcon sav_contrib.dat</div></pre></td></tr></table></figure></p><h3 id="一步计算"><a href="#一步计算" class="headerlink" title="一步计算"></a>一步计算</h3><p>非常简单方便，也没有从教程中看出说差别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../pbsa.mdp -pdie 2 -pbsa -decomp`</div></pre></td></tr></table></figure></p><h2 id="平均结合能计算"><a href="#平均结合能计算" class="headerlink" title="平均结合能计算"></a>平均结合能计算</h2><p>使用的脚本在此<a href="http://rashmikumari.github.io/g_mmpbsa/package/scripts.tar.gz" target="_blank" rel="external">下载</a>。注意需要python包含<code>numpy</code>和<code>scipy</code>。可以简单如下查看:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="keyword">import</span> scipy</div></pre></td></tr></table></figure><p>查看是否报错。<br>若报错可以分别如下安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu下，推荐</span></div><div class="line">sudo apt-get install python-numpy</div><div class="line">sudo apt-get install python-scipy</div><div class="line"></div><div class="line"><span class="comment"># pip</span></div><div class="line">pip install numpy</div><div class="line">pip install scipy</div><div class="line"></div><div class="line"><span class="comment"># conda，一般自带，推荐</span></div></pre></td></tr></table></figure></p><p>最后命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python MmPbSaStat.py -m energy_MM.xvg -p polar.xvg -a apolar.xvg (or sasa.xvg)</div></pre></td></tr></table></figure></p><p>输出文件<code>full_energy.dat</code>和<code>summary_energy.dat</code>。<code>summary_energy.dat</code>文件内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#Complex Number:    1 </div><div class="line">=============== </div><div class="line">   SUMMARY   </div><div class="line">=============== </div><div class="line"></div><div class="line"> van der Waal energy      =        -334.587   +/-   15.514 kJ/mol </div><div class="line"></div><div class="line"> Electrostattic energy    =        -159.380   +/-   15.810 kJ/mol </div><div class="line"></div><div class="line"> Polar solvation energy   =         313.698   +/-   10.174 kJ/mol </div><div class="line"></div><div class="line"> SASA energy              =         -30.431   +/-    0.996 kJ/mol </div><div class="line"></div><div class="line"> SAV energy               =           0.000   +/-    0.000 kJ/mol </div><div class="line"></div><div class="line"> WCA energy               =           0.000   +/-    0.000 kJ/mol </div><div class="line"></div><div class="line"> Binding energy           =        -210.699   +/-   19.745 kJ/mol </div><div class="line"></div><div class="line">=============== </div><div class="line">    END     </div><div class="line">===============</div></pre></td></tr></table></figure></p><p><code>full_energy.dat</code>包含Δ_E_MM, Δ_G_polar, Δ_G_nonpolar 和 Δ_G_binding随时间的关系。例如如下图:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://rashmikumari.github.io/g_mmpbsa/images/binding_energy.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure></p><h2 id="能量拆分"><a href="#能量拆分" class="headerlink" title="能量拆分"></a>能量拆分</h2><p>这个应该大家在很多地方都看过，就是看每个残基对小分子的贡献:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python MmPbSaDecomp.py -bs -nbs 2000 -m contrib_MM.dat -p contrib_pol.dat -a contrib_apol.dat</div></pre></td></tr></table></figure></p><p>输出文件<code>final_contrib_energy.dat</code>和<code>energyMapIn.dat</code>.<code>final_contrib_energy.dat</code>包含对所有三个能量项（包括每个残基的结合能）的贡献能量以及标准误差的平均值。 <code>energyMapIn.dat</code>和xmgrace / matplotlib / gnuplot可用来绘制每个残基的贡献能量（需要删除抑制剂）。例如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://rashmikumari.github.io/g_mmpbsa/images/single_protein_ligand_contribution_energy.png" alt="图2" title="">                </div>                <div class="image-caption">图2</div>            </figure></p><h2 id="在VMD中可视化能量贡献"><a href="#在VMD中可视化能量贡献" class="headerlink" title="在VMD中可视化能量贡献"></a>在VMD中可视化能量贡献</h2><p>其主要是把其写入到PDB文件中B-factor 那一行，用B-factor 来进行做图。<br>使用<code>energy2bfac</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">energy2bfac -s 1EBZ_pbc_corrected.tpr -i energyMapIn.dat</div></pre></td></tr></table></figure></p><p>输出文件<code>complex.pdb</code>, <code>subunit_1.pdb</code>和<code>subunit_2.pdb</code>,<code>subunit_1.pdb</code>和<code>subunit_2.pdb</code>分别表示第一选择组和第二选择组。在VMD中查看(其实pymol等工具也是可以滴):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vmd  subunit_1.pdb</div></pre></td></tr></table></figure></p><p>在<code>Drawing Method</code>将图像展示改为<code>NewCartoon</code> . 将 <code>Coloring Method</code> 设为 <code>Beta</code>. 为了获得颜色尺度bar, <code>Extension</code> ⇒ <code>Visulaization</code> ⇒ <code>Color Scale Bar</code>. 选择 <code>Autoscale: On</code>. 选择 <code>Label format: Decimal</code>. 结果如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://rashmikumari.github.io/g_mmpbsa/images/1EBZ_HIV_protease.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>参考1:<a href="http://jerkwin.github.io/GMX/GMXtut-9/#2.g_mmpbsa" target="_blank" rel="external">GROMACS教程:使用GROMACS计算MM-PBSA结合自由能</a><br>参考2:<a href="http://rashmikumari.github.io/g_mmpbsa" target="_blank" rel="external">g_mmpbsa</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。&lt;br&gt;相对于自由能微扰(FEP)和热力学积分(TI),虽然准确度相对较低，但其计算量相对较小，比较适用于生物大分子体系。是一种对MD轨迹进行后处理以估计结合自由能的方法, 计算时会将溶剂视为均
      
    
    </summary>
    
      <category term="Gromacs" scheme="http://kangsgo.com/categories/Gromacs/"/>
    
    
  </entry>
  
  <entry>
    <title>计算蛋白长宽高</title>
    <link href="http://kangsgo.com/14.html"/>
    <id>http://kangsgo.com/14.html</id>
    <published>2018-01-09T12:25:21.000Z</published>
    <updated>2018-01-09T14:36:59.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了两次需要初略估计蛋白长宽高的情况，其实这个非常简单，在pdb中查看卡迪尔坐标然后排序即可。这里和大家分享三种方法：</p><h3 id="1-shell进行读取"><a href="#1-shell进行读取" class="headerlink" title="1.shell进行读取"></a>1.shell进行读取</h3><p>这个我之前其实有<a href="http://kangsgo.com/840.html">分享</a>过,代码简单如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment">#作者：GROMACS中文组群: 广药-阿福</span></div><div class="line"><span class="comment">#x轴</span></div><div class="line">grep ^ATOM <span class="variable">$1</span> | awk ‘&#123;<span class="built_in">print</span> <span class="variable">$7</span>&#125;’| sort -n |sed -n ‘1p;<span class="variable">$p</span>’</div><div class="line"><span class="comment">#y轴</span></div><div class="line">grep ^ATOM <span class="variable">$1</span> | awk ‘&#123;<span class="built_in">print</span> <span class="variable">$8</span>&#125;’| sort -n |sed -n ‘1p;<span class="variable">$p</span>’</div><div class="line"><span class="comment">#z轴</span></div><div class="line">grep ^ATOM <span class="variable">$1</span> | awk ‘&#123;<span class="built_in">print</span> <span class="variable">$9</span>&#125;’| sort -n |sed -n ‘1p;<span class="variable">$p</span>’</div></pre></td></tr></table></figure></p><h3 id="2-利用python脚本进行读取计算"><a href="#2-利用python脚本进行读取计算" class="headerlink" title="2.利用python脚本进行读取计算"></a>2.利用python脚本进行读取计算</h3><p>这个是我今天写的，写的很初略，因为我发现第三种方法最直接简练:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line">x=[]</div><div class="line">y=[]</div><div class="line">z=[]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> open(<span class="string">'file.pdb'</span>,<span class="string">'r'</span>):</div><div class="line">    <span class="keyword">if</span> i.startswith(<span class="string">'ATOM'</span>):</div><div class="line">        new=i.split()</div><div class="line">        x.append(float(new[<span class="number">6</span>]))</div><div class="line">        y.append(float(new[<span class="number">7</span>]))</div><div class="line">        z.append(float(new[<span class="number">8</span>]))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">print(<span class="string">'长:'</span>+str(max(x)-min(x)))</div><div class="line">print(<span class="string">'宽:'</span>+str(max(y)-min(y)))</div><div class="line">print(<span class="string">'高:'</span>+str(max(z)-min(z)))</div></pre></td></tr></table></figure></p><h3 id="3-Pymol进行读取计算"><a href="#3-Pymol进行读取计算" class="headerlink" title="3.Pymol进行读取计算"></a>3.Pymol进行读取计算</h3><p>其实简单的方便的方法可以使用Pymol的<code>get_extent</code>来获得XYZ的最大最小值，如下排列:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ [ min-X , min-Y , min-Z ],[ max-X, max-Y , max-Z ]]</div></pre></td></tr></table></figure></p><p>可以使用命令行如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get_extent sele</div></pre></td></tr></table></figure></p><p><strong>PYMOL API</strong>如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd.get_extent(string selection=<span class="string">"(all)"</span>, state=<span class="number">0</span> )</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到了两次需要初略估计蛋白长宽高的情况，其实这个非常简单，在pdb中查看卡迪尔坐标然后排序即可。这里和大家分享三种方法：&lt;/p&gt;
&lt;h3 id=&quot;1-shell进行读取&quot;&gt;&lt;a href=&quot;#1-shell进行读取&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>Amber教程5:模拟绿色荧光蛋白</title>
    <link href="http://kangsgo.com/16.html"/>
    <id>http://kangsgo.com/16.html</id>
    <published>2018-01-09T08:10:20.000Z</published>
    <updated>2018-01-10T05:55:49.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="教程B5-模拟绿色荧光蛋白"><a href="#教程B5-模拟绿色荧光蛋白" class="headerlink" title="教程B5 模拟绿色荧光蛋白"></a>教程B5 模拟绿色荧光蛋白</h1><p>原文:Jason Swails,Dave Case, Tai-Sung Lee<br>译: 湖南大学-康文渊   建议移步查看许楠(浙江大学)<a href="https://jerkwin.github.io/2018/01/07/Amber%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BB5-%E6%A8%A1%E6%8B%9F%E7%BB%BF%E8%89%B2%E8%8D%A7%E5%85%89%E8%9B%8B%E7%99%BD%E5%8F%8A%E6%9E%84%E5%BB%BA%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%B0%A8%E5%9F%BA%E9%85%B8%E6%AE%8B%E5%9F%BA/" target="_blank" rel="external">修订的版本</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ambermd.org/tutorials/basic/tutorial5/files/gfp_img.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>绿色荧光蛋白的结构，配体分子使用球棍模型展示</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个教程主要是介绍怎样用Amber进行分子动力学模拟一个带有非标准氨基酸残基的体系。需要注意的是非标准的残基是聚合物的一部分，这不同于其他的有机小分子参数力场构建的例子，所以相对更加复杂，主要涉及电荷的计算和准备恰当的文件用于肽链中的非标准残基。</p><p>我们假设你已经运行过仅含标准氨基酸残基的基本模拟体系（同时建议熟悉<a href="http://ambermd.org/tutorials/basic/tutorial4b/index.html" target="_blank" rel="external">antechamber Sustiva tutorial</a> ）,所以该教程主要关注非标准氨基酸残基的参数构建。不过本教程同时包含完整的GFP（绿色荧光蛋白）分子动力学流程。</p><p>教程的大纲如下:<br>1.使用AMBER准备PDB文件<br>2.计算非标准氨基酸残基的电荷和原子类型<br>3.使用LEaP准备残基文库和力场参数<br>4.创建用于模拟的拓扑和坐标文件<br>5.使用生成的文件进行最小化，加热，平衡和正式模拟</p><p>让我们开始do it！</p><h3 id="第1部分：准备PDB文件"><a href="#第1部分：准备PDB文件" class="headerlink" title="第1部分：准备PDB文件"></a>第1部分：准备PDB文件</h3><p>我们开始于<a href="http://www.rcsb.org/pdb/explore/explore.do?structureId=1ema" target="_blank" rel="external">1EMA.pdb</a>PDB文件，其包含GFP和CRO生色团。因此我们首先从RCSB网站下载PDB文件（或者<a href="http://ambermd.org/tutorials/basic/tutorial5/files/1EMA.pdb" target="_blank" rel="external">点此</a>下载副本）.你可以看到CRO残基位于PDB文件中的896行，标记残基编号为66（残基65和67并入残基66生成生色团，PDB文件头部有描述）。</p><p>第一步是在准备使用tleap之前给PDB文件“按摩”。为了使用<code>tleap</code>,Amber包括一个名为<code>pdb4amber</code>的脚本，可以修饰PDB文件。<code>--help</code>标签可以展示所有可用的设置。我们将使用<code>--dry</code>标签来移除晶体水，<code>--reduce</code>标签增加氢原子到它们最理想的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pdb4amber -i 1EMA.pdb -o gfp.pdb --dry --reduce</div></pre></td></tr></table></figure><p>需要提醒的是你要了解<code>pdb4amber</code>到底“做”了什么。现在输出的PDB文件应该每个残基都包含了对应的氢键（该体系中没有二硫键，如果体系中包含二硫键，<code>pdb4amber</code>会在正确的位置为你加上二硫键）。运行<code>pdb4amber</code>之后，你需要修改gfp.pdb文件，将MSE残基（硒代甲硫氨酸，selenomethionine）改为标准的MET（我们需要模拟的是野生型变体，而不是为了结晶而刻意突变的版本）。你可以使用<code>sed</code>或者你喜爱的编辑软件将MSE全局替换为MET。此外，你需要转换硒原子变为硫原子（名称为SD）以及将元素符号SE转为S。建议您自己运行命令，当然也可以下载我们的副本<a href="http://ambermd.org/tutorials/basic/tutorial5/files/gfp.pdb" target="_blank" rel="external">gfp.pdb</a>文件进行比较。</p><h3 id="第2部分-计算CRO分解电荷和原子类型"><a href="#第2部分-计算CRO分解电荷和原子类型" class="headerlink" title="第2部分:计算CRO分解电荷和原子类型"></a>第2部分:计算CRO分解电荷和原子类型</h3><p>我们通过1EMA.pdb的头部文件了解到CRO是非标准氨基酸残基（实际上是三个氨基酸残基环化形成）。因此，Amber的标准氨基酸残基库不包含该残基的原子类型和电荷。单这些是分子模拟所需要的。 这一部分教程主要关注于如何制作CRO电荷和测定其原子类型。<br>我们将使用<code>antechamber</code>使用<code>bcc</code>电荷方案生成电荷，如果你运行过介绍中提到过的Sustiva教程方案你应该熟知（操作的方法）。需要注意的是该选择不是唯一的，并且对于所有应用也可能不是最佳方案。另外一些工具，例如<a href="http://q4md-forcefieldtools.org/" target="_blank" rel="external">R.E.D.Tools</a>提供了更加严谨和可重复的计算电荷，但是对于这个教程，antechamber工具已足够。如果你希望使用R.E.D.，他们拥有一定数量的教程，你可以用来生成电荷和原子类型，之后可以直接查看第4部分教程.</p><p>CRO模板我们可以使用Protein Data Bank中的非常有用的”components.cif”(<a href="http://www.rcsb.org/pdb/static.do?p=download/http/index.html" target="_blank" rel="external">在此查看</a>)，对于每个包含在PDB文件中的化合物，其都包含观察到的和假想的结构。使用这个解决了坐标问题，并且确保了原子和残基名称会和您的PDB文件相匹配。如果你在PDB中搜索“CRO”，选择配体ID的搜索结果，你将会进入一个站点，其可以下载CRO component CIF文件，CRO.cif.(可以<a href="http://ambermd.org/tutorials/basic/tutorial5/files/CRO.cif" target="_blank" rel="external">点此</a>下载copy)</p><p>antechamber项目将会阅读component CIF（ccif）文件，并且生成电荷和原子类型。你应该查询”Antechamber and GAFF”章节的Amber参考手册的描述和例子。当然你也可以在命令行中输入<code>antechamber -help</code>获取关于设置的详细信息。在这里我们告知他原子类型为Amber类型(-at amber)，因为这是一个修饰的氨基酸残基，分子和Amber原子类型参数是相似的（对于更普遍的有机小分子，通常使用gaff原子类型会更好）我们使用如下的命令来运行<code>antechamber</code>（通常需要几分钟的时间）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antechamber -<span class="keyword">fi</span> ccif -i CRO.cif -bk CRO -fo ac -o cro.ac -c bcc -at amber</div></pre></td></tr></table></figure><p>在生成的许多其他文件中，你可以看到<code>cro.ac</code>文件，其有点像PDB文件，但是包含键，分解的原子电荷和原子类型参数。需要注意的是antechamber是为gaff原子类型所使用的，所以在制作Amber原子类型的时候会出现一些错误，在这个例子中，我们需要修复起始的N原子，其需要拥有酰胺氮(N)同样的类型。你可以手动简单的改变原子类型<code>NT</code>变为<code>N</code>。(或者当作练习，使用<code>sed</code>,<code>awk</code>,<code>perl</code>等工具修改)，你可以<a href="http://ambermd.org/tutorials/basic/tutorial5/files/cro.ac" target="_blank" rel="external">下载cro.ac</a>和您的文件做比较。</p><p>现在我们有antechamber分子文件，其包含分解原子电荷和原子类型。下一部分将会讨论怎样创建残基库文件和为LEaP做准备。</p><p>提醒:你通常需要使用<code>antechamber</code>来创建mol2文件给LEaP阅读。但是我们随后的流程需要先将结果文件给<code>prepgen</code>进行阅读，所以我们需要使用<code>prepgen</code>能够阅读的ac格式文件。</p><h3 id="第3部分-准备给LEaP所使用的残基库和力场参数"><a href="#第3部分-准备给LEaP所使用的残基库和力场参数" class="headerlink" title="第3部分:准备给LEaP所使用的残基库和力场参数"></a>第3部分:准备给LEaP所使用的残基库和力场参数</h3><p>我们从PDB下载的“CRO”组件是一个完整的分子，包含了所有的氢原子，这是antechamber（或任何量子力学程序）计算电荷所需要的。 但是我们需要在开头和结尾处去除原子，以便制备一个“氨基酸”样残基，该氨基酸残基可以在其N-端和C-端与其他氨基酸连接。</p><p>这部分可以使用<code>prepgen</code>项目和”mc”(主链)文件进行准备，该文件定义哪些原子需要被移除，哪些原子是主链的一部分(例如:骨架原子)。通常需要自己创建该文件。下面的内容是该教程的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HEAD_NAME N1</div><div class="line">TAIL_NAME C3 </div><div class="line">MAIN_CHAIN CA1</div><div class="line">MAIN_CHAIN C1</div><div class="line">MAIN_CHAIN N3</div><div class="line">MAIN_CHAIN CA3</div><div class="line">OMIT_NAME H2</div><div class="line">OMIT_NAME HN11</div><div class="line">OMIT_NAME OXT</div><div class="line">OMIT_NAME HXT</div><div class="line">PRE_HEAD_TYPE C</div><div class="line">POST_TAIL_TYPE N</div><div class="line">CHARGE 0.0</div></pre></td></tr></table></figure></p><p><code>HEAD_NAME</code>和<code>TAIL_NAME</code>行的原子将会联系前后氨基酸残基。<code>MAIN_CHAIN</code>行列出连接头和尾原子之间链中的原子,<code>OMIT_NAME</code>行列出了CRO残基中应该从最终结构中去除的原子，因为它们不存在于完整蛋白质中。<code>PRE_HEAD_TYPE</code>和<code>POST_TAIL_TYPE</code>行让<code>prepgen</code>知道周围蛋白质中哪些原子类型将用于共价连接。(需要记住的是<code>prepgen</code>在用于蛋白和多肽以外还可以用于聚合物的制作)<code>CHARGE</code>行设定氨基酸残基的总电荷，<code>prepgen</code>将确保“删除的”原子电荷在剩余的原子之间重新分配，以便总电荷是正确的。(在这个例子中为0)</p><p>之后，你可以对<code>prepgen</code>使用<code>-help</code>标签来查看该项目所有可用的设置。随后运行<code>prepgen</code>将会除去N端和C端不需要的原子，假设你的主链文件命名为<code>cro.mc</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prepgen -i cro.ac -o cro.prepin -m cro.mc -rn CRO</div></pre></td></tr></table></figure></p><p>运行该命令之后你将会拥有<code>cro.prepin</code>文件，包含定义的CRO残基（可以<a href="http://ambermd.org/tutorials/basic/tutorial5/files/cro.prepin" target="_blank" rel="external">从此下载</a>相互比较）</p><p>此刻，我们拥有包含我们修饰的氨基酸残基的原子电荷的残基库。接下来我们需要检查其共价参数(bonds,angles和diherals)，查看他们是否可用。<code>parmchk2</code>项目将会描绘出哪些参数是需要的，并且在标准文件中寻找。如果没有找到，将会进行训练过的猜测，并且放入新参数到文件中，我们命名为”frcmod.cro”。</p><p>我们使用如下命令运行<code>parmchk2</code>(同样的可以使用<code>-help</code>标签查看可用的设置):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parmchk2 -i cro.prepin -f prepi -o frcmod.cro -a Y \</div><div class="line">         -p <span class="variable">$AMBERHOME</span>/dat/leap/parm/parm10.dat</div></pre></td></tr></table></figure></p><p>这里我们指定<code>parm10.dat</code>文件，因为它是我们打算使用的ff14SB力场的主要参数数据库，（这个信息可以在您打算使用的力场的leaprc文件中找到）。 如果我们删除这个标签，那么parmchk2将匹配gaff数据库中的参数，这并不是我们想要的。我们还要求打印所有的参数（即使是在parm10.dat中完美匹配的参数），原因很快就会明了。</p><p>完成这一步之后，查看<code>frcmod.cro</code>（你可以比较我们的<a href="http://ambermd.org/tutorials/basic/tutorial5/files/frcmod.cro" target="_blank" rel="external">frcmod.cro副本</a>）。 您应该马上看到了含有标记为ATTN的参数的行的问题需要修改。 这表示<code>parmchk2</code>在<code>parm10.dat</code>数据库中找不到适当的相似参数。 还有许多其他的参数被选择为具有高惩罚（这表明<code>parmchk2</code>的结果是不合适的）。</p><p>一个简单的解决办法是通过设置<code>parm10.dat</code>,使用<code>parmchk2</code>搜寻<code>gaff.dat</code>来“填充”不存在或者高惩罚的参数。所以我们需要删除<code>frcmod.cro</code>中标为<code>ATTN:need revision</code>的参数，并且告诉<code>parmchk2</code>在<code>gaff.dat</code>(默认设置)中搜寻。来自parm10.dat内的参数我们想要保留，而其他参数使用gaff参数填充到frcmod1.cro文件中（这也是为什么我们需要使用<code>-a Y</code>标签打印所有参数）。完成这些设置的命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grep -v <span class="string">"ATTN"</span> frcmod.cro &gt; frcmod1.cro <span class="comment"># Strip out ATTN lines</span></div><div class="line">parmchk2 -i cro.prepin -f prepi -o frcmod2.cro</div></pre></td></tr></table></figure></p><p>至此，我们拥有两个frcmod文件，一个参数来自于Amber参数数据库(frcmod1.cro,可以再此<a href="http://ambermd.org/tutorials/basic/tutorial5/files/frcmod1.cro" target="_blank" rel="external">下载副本</a>进行比较),另一个参数为gaff原子类型(frcmod2.cro,可以再此<a href="http://ambermd.org/tutorials/basic/tutorial5/files/frcmod2.cro" target="_blank" rel="external">下载副本</a>进行比较),在这两个参数之中拥有所有我们需要的内容。如果你想，你可以从frcmod2.cro种提取7个缺失参数（和附加的高惩罚参数），将其添加到frcmod1.cro中。然而，如果你按照教程顺序进行操作，这些参数会在下一部分加载，不需要进行这一步操作。然我们继续下面的步骤来创建<code>prmtop</code>和<code>inpcrd</code>文件。</p><p>与往常一样，这里生成的参数 - 尤其是由gaff提供的参数，应被视为一个起点，应该根据可用的实验或高水平QM数据进行验证。 为了本教程的目的，我们将简单地继续我们在这里生成的内容。</p><h3 id="第4部分-创建用于模拟的拓扑和坐标文件"><a href="#第4部分-创建用于模拟的拓扑和坐标文件" class="headerlink" title="第4部分:创建用于模拟的拓扑和坐标文件"></a>第4部分:创建用于模拟的拓扑和坐标文件</h3><p>我们现在有了我们需要的所有文件来创建用于sander或pmemd的拓扑和坐标文件！我们只需要将这些文件加载到LEaP来创建这些文件。 如果你使用R.E.D. 或其他一些工具来做电荷推导和原子类型，欢迎回到教程。</p><p>对于这个例子，我们使用ff14SB力场和igb=8隐性水模型，描述可以查看Amber参考手册。将默认PBRadii设置为“mbondi3”集是指定力场的一部分。</p><p>我们之后加载之前创建的<code>cro.prepin</code>文件。在这种情况下，我们需要首先加载<code>frcmod2.cro</code>文件，随后是<code>frcmod1.cro</code>文件，确保gaff参数会被我们更加想用的ff14SB参数所覆盖。然后我们加入我们准备的1EMA PDB文件（为gfp.pdb），并保存这个结果。脚本展示如下，将其保存为<code>tleap.in</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">source leaprc.protein.ff14SB</div><div class="line">set default PBRadii mbondi3</div><div class="line">loadAmberPrep cro.prepin</div><div class="line">loadAmberParams frcmod2.cro</div><div class="line">loadAmberParams frcmod1.cro</div><div class="line">x = loadPDB gfp.pdb</div><div class="line">saveAmberParm x gfp.parm7 gfp.rst7</div><div class="line">quit</div></pre></td></tr></table></figure></p><p>我们可以通过如下命令运行tleap:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tleap -f tleap.in</div></pre></td></tr></table></figure></p><p>这一步骤以后，你应该有完整的拓扑和坐标文件，你已经准备开始模拟啦！你可以<a href="http://ambermd.org/tutorials/basic/tutorial5/files/gfp_parmcrd.tgz" target="_blank" rel="external">下载我们创建的副本</a>和你的进行比较.进入部分5！</p><h3 id="第5部分：模拟；最小化，加热，平衡和正式（模拟）"><a href="#第5部分：模拟；最小化，加热，平衡和正式（模拟）" class="headerlink" title="第5部分：模拟；最小化，加热，平衡和正式（模拟）"></a>第5部分：模拟；最小化，加热，平衡和正式（模拟）</h3><p>由于本教程的目的是通过对修饰聚合物“link”进行参数化，本部分仅作简要介绍。 在你自己的项目中，你当然可以自由选择显式溶剂模型和比我们在这里使用的更小心的最小化，加热和平衡程序（也许利用位置限制来防止结构扭曲）。</p><h4 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h4><p>我们使用的最小化输入文件如下。我们将该文件命名为<code>min.in</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> simple generalized Born minimization script</div><div class="line">&amp;cntrl</div><div class="line">  imin=1, ntb=0, maxcyc=100, ntpr=10, cut=1000., igb=8, </div><div class="line">/</div></pre></td></tr></table></figure></p><p>我们可以使用<code>sander</code>模块运行最小化:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sander -O -i min.in -p gfp.parm7 -c gfp.rst7 -o min1.out -r min1.rst7</div></pre></td></tr></table></figure></p><p>如同往常一样，我们建议可视化查看结果结构(mini1.rst7)来确保观察没有糟糕的事情发生，并且输出文件确保所有的看起来都正常（例如:结构完整，在最小化期间总能量最大梯度稳步下降）。我们创建的输出文件可以作为压缩包的一部分进行下载，压缩包包含本节最后的计算过程中生成的大部分文件。</p><h4 id="加热"><a href="#加热" class="headerlink" title="加热"></a>加热</h4><p>下面显示了我们用于加热的输入文件。 我们将这个文件命名为<code>heat.in</code>，并且将在从10K到300K的200ps的过程中线性地改变目标温度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Implicit solvent initial heating mdin</div><div class="line"> &amp;cntrl</div><div class="line">   imin=0, irest=0, ntx=1,</div><div class="line">   ntpr=1000, ntwx=1000, nstlim=100000,</div><div class="line">   dt=0.002, ntt=3, tempi=10,</div><div class="line">   temp0=300, gamma_ln=1.0, ig=-1,</div><div class="line">   ntp=0, ntc=2, ntf=2, cut=1000,</div><div class="line">   ntb=0, igb=8, ioutfm=1, nmropt=1,</div><div class="line"> /</div><div class="line"> &amp;wt</div><div class="line">   TYPE=&apos;TEMP0&apos;, ISTEP1=1, ISTEP2=100000,</div><div class="line">   VALUE1=10.0, VALUE2=300.0,</div><div class="line"> /</div><div class="line"> &amp;wt TYPE=&apos;END&apos; /</div></pre></td></tr></table></figure></p><p>需要注意的是，我们加热结构时，我们需要使用上一步（最小化）生成的结构来加热。所用使用<code>sander</code>来进行加热操作的命令看起来如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sander -O -i heat.in -p gfp.parm7 -c min1.rst7 -o heat.mdout \</div><div class="line">       -x heat.nc -r heat.rst7</div></pre></td></tr></table></figure></p><p>值得注意的是使用<code>sander</code>可能需要很长世间，我们使用<code>pmemd.cuda</code>运行我们的模拟，在我们的GTX680上运行能够更加快速的完成。与往常一样，使用您最喜爱的可视化工具检查所得结构和轨迹，以确保没有发生任何明显的不良事件。和以前一样，我们生成的文件将在本节末尾的压缩包中提供。</p><h4 id="正式模拟"><a href="#正式模拟" class="headerlink" title="正式模拟"></a>正式模拟</h4><p>！！！这一段翻译的不是很好<br>我们成功的加热了我们的结构！现在我们已经准备开始正式的模拟。请注意，许多人称之为“平衡”的过程实际上只是在分析过程中忽略的正式模拟的一部分，因为要么就是稳定约束的结构，要么就是让系统向平衡位置迁移。为了本教程的目的，我们不区分这两个阶段，我们使用相同的输入对待两者。</p><p>我们将使用的输入文件如下，命名为<code>md.in</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Implicit solvent molecular dynamics</div><div class="line"> &amp;cntrl</div><div class="line">   imin=0, irest=1, ntx=5,</div><div class="line">   ntpr=1000, ntwx=1000, nstlim=500000,</div><div class="line">   dt=0.002, ntt=3, tempi=300,</div><div class="line">   temp0=300, gamma_ln=1.0, ig=-1,</div><div class="line">   ntp=0, ntc=2, ntf=2, cut=1000,</div><div class="line">   ntb=0, igb=8, ioutfm=1,</div><div class="line"> /</div></pre></td></tr></table></figure></p><p>你可以使用随后的命令来运行模拟(再一次，我们将使用<code>pmemd.cuda</code>):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sander -O -i md.in -p gfp.parm7 -c heat.rst7 -o md1.mdout \</div><div class="line">       -x md1.nc -r md1.rst7</div></pre></td></tr></table></figure></p><p>所有的都完成了！当然，你仍然需要分析你的模拟，以便测试通过首先运行计算得到的结果。现在你已经知道怎样进行一个新的参数化，修饰包含寡聚链的单体单元（例如修饰核苷酸或者氨基酸残基）。这个侧链可以应用你想应用到的任何寡聚单元。</p><p>正如我们的承诺，你可以<a href="http://ambermd.org/tutorials/basic/tutorial5/files/simulation_files.tgz" target="_blank" rel="external">下载</a>我们生成的版本。值得注意的是你的输出绝大部分时候和我们的都会不同（甚至整体参数都会不同，因为1ns的轨迹实在太短）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;教程B5-模拟绿色荧光蛋白&quot;&gt;&lt;a href=&quot;#教程B5-模拟绿色荧光蛋白&quot; class=&quot;headerlink&quot; title=&quot;教程B5 模拟绿色荧光蛋白&quot;&gt;&lt;/a&gt;教程B5 模拟绿色荧光蛋白&lt;/h1&gt;&lt;p&gt;原文:Jason Swails,Dave Case,
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Amber" scheme="http://kangsgo.com/tags/Amber/"/>
    
  </entry>
  
  <entry>
    <title>gromacs2018安装教程</title>
    <link href="http://kangsgo.com/31.html"/>
    <id>http://kangsgo.com/31.html</id>
    <published>2017-12-21T11:50:59.000Z</published>
    <updated>2018-01-02T12:07:15.734Z</updated>
    
    <content type="html"><![CDATA[<p>首次发布:2015-12-02</p><p>第一次更新:2017-12-21</p><p>第二次更新:2018-01-02</p><p>gromacs2018版本其实和gromacs5.X版本差别不大，正好新电脑到了，这里以2018版本为例进行安装</p><p>默认安装在各位文件夹（我的用户名yaolab）的install下：</p><h2 id="一-预先安装："><a href="#一-预先安装：" class="headerlink" title="一.预先安装："></a>一.预先安装：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install gcc</div><div class="line">sudo apt-get install g++</div><div class="line">sudo apt-get install gfortran</div><div class="line"><span class="comment">#若不需要GPU加速或者只是学习只用，仅需:</span></div><div class="line"><span class="comment">#sudo apt-get install gromacs</span></div><div class="line"><span class="comment">#后面无需在看</span></div></pre></td></tr></table></figure><h2 id="二-安装cmake"><a href="#二-安装cmake" class="headerlink" title="二.安装cmake"></a>二.安装cmake</h2><h3 id="方案一：直接apt-get"><a href="#方案一：直接apt-get" class="headerlink" title="方案一：直接apt-get"></a>方案一：直接apt-get</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install cmake</div></pre></td></tr></table></figure><h3 id="方案二：编译安装"><a href="#方案二：编译安装" class="headerlink" title="方案二：编译安装"></a>方案二：编译安装</h3><p>首先我们需要在<a href="https://cmake.org/" target="_blank" rel="external">cmake官网</a>进行<a href="https://cmake.org/download/" target="_blank" rel="external">下载</a></p><p>发表文章时版本为3.10.1，所以以该版本为例</p><h4 id="1-进入文件目录："><a href="#1-进入文件目录：" class="headerlink" title="1.进入文件目录："></a>1.进入文件目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span>  /home/yaolab/install</div></pre></td></tr></table></figure><h4 id="2-解压缩："><a href="#2-解压缩：" class="headerlink" title="2.解压缩："></a>2.解压缩：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf cmake-3.10.1.tar.gz</div></pre></td></tr></table></figure><h4 id="3-进入目录："><a href="#3-进入目录：" class="headerlink" title="3.进入目录："></a>3.进入目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> cmake-3.10.1</div></pre></td></tr></table></figure><h4 id="4-设置，附加安装路径，我将其安装在cmake文件夹下"><a href="#4-设置，附加安装路径，我将其安装在cmake文件夹下" class="headerlink" title="4.设置，附加安装路径，我将其安装在cmake文件夹下"></a>4.设置，附加安装路径，我将其安装在cmake文件夹下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bootstrap --prefix=/home/yaolab/install/cmake</div></pre></td></tr></table></figure><h4 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><h4 id="6-设置路径"><a href="#6-设置路径" class="headerlink" title="6.设置路径"></a>6.设置路径</h4><blockquote><p>gedit ~/.zshrc (1.ubuntu默认为bashrc命令，我这里改为了zshrc，下同，所以你可能下面所有的zshrc都需要改为bashrc  2.倘若你安装在/usr/目录下的话需要sudo获得权限，个人建议最好不要sudo su或者最高权限后进行操作，因为那样子所有的文件都是高权限的)</p></blockquote><p>最底部增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PATH=&quot;$PATH:/home/yaolab/install/cmake/bin/:.&quot;</div><div class="line">#其中/home/yaolab/install/cmake/需要替换为你的路径，下同</div><div class="line">source ~/.zshrc</div></pre></td></tr></table></figure><h4 id="6-查看是否安装好"><a href="#6-查看是否安装好" class="headerlink" title="6*.查看是否安装好"></a>6*.查看是否安装好</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmake</div></pre></td></tr></table></figure><h2 id="三-安装fftw"><a href="#三-安装fftw" class="headerlink" title="三.安装fftw"></a>三.安装fftw</h2><h3 id="方案一-gromacs安装时集成-推荐"><a href="#方案一-gromacs安装时集成-推荐" class="headerlink" title="方案一.gromacs安装时集成[推荐]"></a>方案一.gromacs安装时集成[推荐]</h3><h3 id="方案二-自行编译安装"><a href="#方案二-自行编译安装" class="headerlink" title="方案二.自行编译安装"></a>方案二.自行编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tar xvf fftw-3.3.4.tar.gz</div><div class="line">cd fftw-3.3.4</div><div class="line">./configure –enable-DFFTWF_INCLUDE_DIR –enable-shared</div><div class="line">make</div><div class="line">sudo make install</div><div class="line"></div><div class="line">#设置路径，或者gromacs那一步设置，由于不推荐这种方法，就不过多累述</div></pre></td></tr></table></figure><h2 id="四-安装openmpi"><a href="#四-安装openmpi" class="headerlink" title="四.安装openmpi"></a>四.安装openmpi</h2><p>openmpi可以在<a href="https://www.open-mpi.org/" target="_blank" rel="external">官方网站</a>进行<a href="https://www.open-mpi.org/software/ompi/v3.0/downloads/openmpi-3.0.0.tar.gz" target="_blank" rel="external">下载</a></p><h4 id="1-同样先要进入开始放置下载的目录："><a href="#1-同样先要进入开始放置下载的目录：" class="headerlink" title="1.同样先要进入开始放置下载的目录："></a>1.同样先要进入开始放置下载的目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /home/yaolab/install</div></pre></td></tr></table></figure><h4 id="2-解压缩和进入目录-将其安装在openmpi目录下："><a href="#2-解压缩和进入目录-将其安装在openmpi目录下：" class="headerlink" title="2.解压缩和进入目录,将其安装在openmpi目录下："></a>2.解压缩和进入目录,将其安装在openmpi目录下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xvf openmpi-1.10.tar.gz</div><div class="line"><span class="built_in">cd</span> openmpi-1.10</div><div class="line">./configure –prefix=/home/yaolab/install/openmpi</div></pre></td></tr></table></figure><h4 id="3-安装："><a href="#3-安装：" class="headerlink" title="3.安装："></a>3.安装：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make all</div><div class="line">make install</div></pre></td></tr></table></figure><h4 id="4-环境变量设置："><a href="#4-环境变量设置：" class="headerlink" title="4.环境变量设置："></a>4.环境变量设置：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#openmpi</span></div><div class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/yaolab/install/openmpi/lib:<span class="variable">$LD_LIBRARY_PATH</span></div><div class="line"><span class="built_in">export</span> PATH=/home/yaolab/install/openmpi/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure><h2 id="五-CUDA驱动安装"><a href="#五-CUDA驱动安装" class="headerlink" title="五.CUDA驱动安装"></a>五.CUDA驱动安装</h2><p>由于amber和gromacs等许多软件都需要用的，我另起一篇文章，具体可以<a href="http://kangsgo.com/40.html">点我查看</a></p><p>注意两种方法都需要设置路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># CUDA </div><div class="line">export PATH=&quot;$PATH:/usr/local/cuda-9.0/bin&quot;</div><div class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64“</div></pre></td></tr></table></figure></p><h2 id="六-GROMACS的安装"><a href="#六-GROMACS的安装" class="headerlink" title="六.GROMACS的安装"></a>六.GROMACS的安装</h2><p>千呼万唤始出来，终于到了<a href="http://manual.gromacs.org/documentation/" target="_blank" rel="external">gromacs</a>的安装了～其实gromacs的安装反而更加简单明了，我把其安装在/home/yaolab/install下面</p><h4 id="1-进入目录解压进入目录（由于是给予新手帮助，原谅我啰嗦）"><a href="#1-进入目录解压进入目录（由于是给予新手帮助，原谅我啰嗦）" class="headerlink" title="1.进入目录解压进入目录（由于是给予新手帮助，原谅我啰嗦）"></a>1.进入目录解压进入目录（由于是给予新手帮助，原谅我啰嗦）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/install</div><div class="line">tar xfz gromacs2018.tar.gz</div><div class="line"><span class="built_in">cd</span> gromacs2018</div></pre></td></tr></table></figure><h4 id="2-创建文件夹："><a href="#2-创建文件夹：" class="headerlink" title="2.创建文件夹："></a>2.创建文件夹：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir build</div></pre></td></tr></table></figure><h4 id="3-进入文件夹"><a href="#3-进入文件夹" class="headerlink" title="3.进入文件夹"></a>3.进入文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span>  build</div></pre></td></tr></table></figure><h4 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cmake .. -DGMX_BUILD_OWN_FFTW=ON -DGMX_GPU=ON -DGMX_MPI=ON -DCMAKE_INSTALL_PREFIX=/home/yaolab/install/gromacs</div><div class="line"><span class="comment">#倘若FFTW不是自动安装，要**手动**安装的话需要更改为：</span></div><div class="line"><span class="comment">#-DGMX_FFT_LIBRARY=fftw3 #-DFFTWF_LIBRARY="/usr/local/lib/libfftw3f.so"  -DFFTWF_INCLUDE_DIR="/usr/local/include/"</span></div><div class="line"><span class="comment">#这里就不详细说明了</span></div></pre></td></tr></table></figure><p>这里解释一下<br><code>DGMX_BUILD_OWN_FFTW</code>为是否自动安装FFTW，<code>DGMX_GPU</code>和<code>DGMX_MPI</code>为是否使用GPU模块和MPI模块，<code>DCMAKE_INSTALL_PREFIX</code>为安装路径。值得注意的是若为NVIDIA Tesla或者Quadro GPUS显卡最好增加<code>-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda</code>，能够达到最大利用率</p><h4 id="5-安装-1"><a href="#5-安装-1" class="headerlink" title="5.安装"></a>5.安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#（32表示make时使用32核，如果只用一个核，只需使用make）</span></div><div class="line">make -j 32</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure><h4 id="6-设置环境变量"><a href="#6-设置环境变量" class="headerlink" title="6.设置环境变量"></a>6.设置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gromacs</div><div class="line">source /home/kangsgo/mdinstall/md/gromacs/bin/GMXRC</div></pre></td></tr></table></figure><p>到此gromacs安装到此结束！</p><h4 id="7-遇到的一些问题"><a href="#7-遇到的一些问题" class="headerlink" title="7.遇到的一些问题"></a>7.遇到的一些问题</h4><p>出现类似如下信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvcc fatal   : Unsupported gpu architecture &apos;compute_20&apos;</div></pre></td></tr></table></figure></p><p>这个问题的原因为cuda9.0以上版本不支持compute_20造成的，解决办法可以下载最新版本的gromacs，或者<code>cmake/gmxManageNvccConfig.cmake</code>中将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list (APPEND GMX_CUDA_NVCC_GENCODE_FLAGS &quot;-gencode;arch=compute_20,code=sm_20&quot;)</div></pre></td></tr></table></figure></p><p>注释掉。</p><p>参考文章：</p><p>1.<a href="http://bioms.org/forum.php?mod=viewthread&amp;tid=1500&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D127" target="_blank" rel="external">【致谢飞天大神及各位坛友】ubuntu、gromacs、g_mmpbsa的安装</a></p><ol><li><a href="http://bioms.org/forum.php?mod=viewthread&amp;tid=1983&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D126" target="_blank" rel="external">GMX在ubuntu系统下的安装，小编个人的安装经验仅供参考！</a></li></ol><p>3.<a href="http://bioms.org/forum.php?mod=viewthread&amp;tid=1749" target="_blank" rel="external">安装的gromacs 5.0.4 bin 里没有g_solvate_mpi</a></p><p>4.<a href="http://bioms.org/forum.php?mod=viewthread&amp;tid=1519&amp;extra=page%3D1" target="_blank" rel="external">gromacs 5.0.2 mpi+GPU+gnu安装教程（联网+单机安装）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首次发布:2015-12-02&lt;/p&gt;
&lt;p&gt;第一次更新:2017-12-21&lt;/p&gt;
&lt;p&gt;第二次更新:2018-01-02&lt;/p&gt;
&lt;p&gt;gromacs2018版本其实和gromacs5.X版本差别不大，正好新电脑到了，这里以2018版本为例进行安装&lt;/p&gt;
&lt;p&gt;默认
      
    
    </summary>
    
      <category term="Gromacs" scheme="http://kangsgo.com/categories/Gromacs/"/>
    
    
  </entry>
  
  <entry>
    <title>Amber17的安装</title>
    <link href="http://kangsgo.com/77.html"/>
    <id>http://kangsgo.com/77.html</id>
    <published>2017-12-20T23:56:01.000Z</published>
    <updated>2017-12-27T15:00:18.284Z</updated>
    
    <content type="html"><![CDATA[<p>首次版本:2015-12-3</p><p>第一次更新日期:2017-9-11<br>第二次更新日期:2017-12-21</p><p>首先您可能需要安装<a href="http://kangsgo.com/40.html">CUDA</a>和<a href="http://kangsgo.com/31.html">Openmpi</a> 这里就不再详细说明，您阅读这篇文章时默认已经安装了这两个</p><p>我们以将amber安装在/home/kangsgo/mdinstall/md下为例：</p><h4 id="1-进入目录："><a href="#1-进入目录：" class="headerlink" title="1.进入目录："></a>1.进入目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /home/kangsgo/mdinstall/md</div></pre></td></tr></table></figure><h4 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar xvfj AmberTools17.tar.bz2</div><div class="line">tar xvfj Amber16.tar.bz2</div><div class="line"><span class="comment">#（注意：amber16需要购买,购买amber16后可以使用GPU加速，价格为500美金）</span></div><div class="line"></div><div class="line"><span class="comment">#（注意:虽然AmberTools17，但解压以后为amber16文件夹）</span></div></pre></td></tr></table></figure><h4 id="3-设置环境变量："><a href="#3-设置环境变量：" class="headerlink" title="3.设置环境变量："></a>3.设置环境变量：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> AMBERHOME=/home/kangsgo/mdinstall/md/amber16   <span class="comment"># (for bash,zsh,ksh,etc.)</span></div><div class="line"></div><div class="line">setenv AMBERHOME /home/kangsgo/mdinstall/md/amber16  <span class="comment"># (for csh,tcsh 一般不是这些终端)</span></div></pre></td></tr></table></figure><h4 id="4-预编译："><a href="#4-预编译：" class="headerlink" title="4.预编译："></a>4.预编译：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install csh flex gfortran g++ xorg-dev \</div><div class="line">zlib1g-dev libbz2-dev patch python-tk python-matplotlib</div></pre></td></tr></table></figure><h4 id="5-进入目录："><a href="#5-进入目录：" class="headerlink" title="5.进入目录："></a>5.进入目录：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$AMBERHOME</span>（也可以输入：/home/kangsgo/mdinstall/md/amber16 绝对路径）</div></pre></td></tr></table></figure><h4 id="6-设置"><a href="#6-设置" class="headerlink" title="6.设置"></a>6.设置</h4><p>一般采用默认安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">./configure gnu</div><div class="line"></div><div class="line"><span class="comment"># (提示安装miniconda选择安装,不会与自己安装的conda发生冲突，因为其不会写入环境变量)</span></div><div class="line"></div><div class="line"><span class="comment"># 若是编写脚本安装可以输入yes自动接收协议，如下</span></div><div class="line"></div><div class="line">yes | ./configure gnu</div></pre></td></tr></table></figure><p>若自己安装了conda，也可以使用自己的conda，方法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --with-python /home/kangsgo/anconda3/python gnu</div></pre></td></tr></table></figure></p><p>其中路径需要修改为自己的</p><p>这一步不要安装并行选项，并行需要在后面第10步再进行安装。</p><h4 id="7-设置环境变量："><a href="#7-设置环境变量：" class="headerlink" title="7.设置环境变量："></a>7.设置环境变量：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> /home/kangsgo/mdinstall/md/amber16/amber.sh <span class="comment"># for bash, zsh, ksh, etc.</span></div><div class="line"><span class="built_in">source</span> /home/kangsgo/mdinstall/md/amber16/amber.csh <span class="comment"># for csh, tcsh</span></div></pre></td></tr></table></figure><h4 id="8-安装："><a href="#8-安装：" class="headerlink" title="8.安装："></a>8.安装：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure><p>如果你没有amber16，那么最后会显示</p><p>/home/kangsgo/install/amber16/src/Makefile not found, or -noamber was set.</p><p>这是正常现象</p><h4 id="9-测试："><a href="#9-测试：" class="headerlink" title="9.测试："></a>9.测试：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make <span class="built_in">test</span></div></pre></td></tr></table></figure><p>注:这一步我报错了，但是终端给了提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test -f /home/kangsgo/install/amber16/amber.sh &amp;&amp; source /home/kangsgo/install/amber16/amber.sh</div></pre></td></tr></table></figure><p>输入以上命令后再 make test就成功了</p><p>这一步时间较久，可以能1个小时还没有完成，特别是经常屏幕没有反应这是正常现象不需要惊慌。</p><h4 id="10-设置环境变量"><a href="#10-设置环境变量" class="headerlink" title="10.设置环境变量"></a>10.设置环境变量</h4><p>以下是我自己的写法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> /home/kangsgo/install/amber16/amber.sh</div></pre></td></tr></table></figure><h4 id="11-多线程的安装"><a href="#11-多线程的安装" class="headerlink" title="11.多线程的安装"></a>11.多线程的安装</h4><p>“由于未用到，只是照搬教程”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$AMBERHOME</span></div><div class="line"></div><div class="line">./configure -mpi &lt;…other options…&gt;&lt;compiler-choice&gt;</div><div class="line"></div><div class="line">make install</div><div class="line"></div><div class="line"><span class="built_in">export</span> DO_PARALLEL=”mpirun -np 2″  <span class="comment">#核心数可以修改</span></div><div class="line"></div><div class="line">make <span class="built_in">test</span></div></pre></td></tr></table></figure><p>&nbsp;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://kangsgo.com/wp-content/uploads/2015/12/1.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>参考文献：Amber17官方教程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首次版本:2015-12-3&lt;/p&gt;
&lt;p&gt;第一次更新日期:2017-9-11&lt;br&gt;第二次更新日期:2017-12-21&lt;/p&gt;
&lt;p&gt;首先您可能需要安装&lt;a href=&quot;http://kangsgo.com/40.html&quot;&gt;CUDA&lt;/a&gt;和&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="软件安装" scheme="http://kangsgo.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
      <category term="amber" scheme="http://kangsgo.com/tags/amber/"/>
    
  </entry>
  
  <entry>
    <title>Open Babel API</title>
    <link href="http://kangsgo.com/15.html"/>
    <id>http://kangsgo.com/15.html</id>
    <published>2017-12-12T08:10:20.000Z</published>
    <updated>2017-12-17T05:27:12.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>此文章不完全翻译自官方文档，不定期更新，欢迎关注</p><p>Open Babel是一个非常优秀的支持多种分子格式的开源软件，同时可以进行2D 3D格式的转换，也可以编写脚本。编译安装方法可以查看我们之前的<a href="http://kangsgo.com/526.html">文章</a>。</p><p>对于python，Open Babel是支持的很好的，其包括了两个Python包，分别为<code>openbabel</code>模块和<code>Pybel</code>模块。</p><p>1.<code>Openbabel</code>模块</p><p>   其包含标准的Python粘合，来自于C++API，通过SWIG自动生成</p><p>2.<code>Pybel</code>模块<br>   这是一个轻量级的<code>openbabel</code>封装类和方法，其提供更多的便利和Pythonic方式来操控Open Babel工具</p><h3 id="openbabel模块"><a href="#openbabel模块" class="headerlink" title="openbabel模块"></a><code>openbabel</code>模块</h3><p>   包含基本类 OBMol，OBAtom，OBBond和OBResidue，以及转换框架 OBConversion</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>(以下均为python3测试通过)<br>普通的自编分子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> openbabel</div><div class="line"></div><div class="line"><span class="comment"># 创建实例</span></div><div class="line">mol=openbabel.OBMol()</div><div class="line">print(<span class="string">'Should print 0 (atoms)'</span>)</div><div class="line">print(mol.NumAtoms())</div><div class="line"></div><div class="line"><span class="comment"># 创建新原子</span></div><div class="line">a=mol.NewAtom()</div><div class="line"><span class="comment"># C原子,见元素周期表</span></div><div class="line">a.SetAtomicNum(<span class="number">6</span>)</div><div class="line"><span class="comment"># 设置坐标</span></div><div class="line">a.SetVector(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>)</div><div class="line"></div><div class="line">b = mol.NewAtom()</div><div class="line"><span class="comment"># 原子键索引为1</span></div><div class="line">mol.AddBond(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)  </div><div class="line"><span class="comment"># 输出原子树木</span></div><div class="line">print(mol.NumAtoms())</div><div class="line"><span class="comment"># 输出键树木</span></div><div class="line">print(mol.NumBonds())</div><div class="line"></div><div class="line">mol.Clear()</div></pre></td></tr></table></figure></p><p>当然也可以通过阅读SML码读取已有分子进行加氢，输出其他文件的操作，主要是使用<a href="http://openbabel.org/dev-api/classOpenBabel_1_1OBConversion.shtml" target="_blank" rel="external">OBConversion</a>框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> openbabel</div><div class="line"></div><div class="line">obConversion=openbabel.OBConversion()</div><div class="line">obConversion.SetInAndOutFormats(<span class="string">'smi'</span>,<span class="string">'mdl'</span>)</div><div class="line"></div><div class="line">mol=openbabel.OBMol()</div><div class="line">obConversion.ReadString(mol,<span class="string">"C1=CC=CS1"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 将会显示5个原子</span></div><div class="line">print(mol.NumAtoms())</div><div class="line"></div><div class="line"><span class="comment">#加氢</span></div><div class="line">mol.AddHydrogens()</div><div class="line"></div><div class="line"><span class="comment"># 将会显示9个原子</span></div><div class="line">print(mol.NumAtoms())</div><div class="line"></div><div class="line">outMDL=obConversion.WriteString(mol)</div></pre></td></tr></table></figure><p>当然也可以阅读文件模式进行阅读<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> openbabel</div><div class="line"></div><div class="line">obConversion = openbabel.OBConversion()</div><div class="line">obConversion.SetInAndOutFormats(<span class="string">"pdb"</span>, <span class="string">"mol2"</span>)</div><div class="line"></div><div class="line">mol = openbabel.OBMol()</div><div class="line">obConversion.ReadFile(mol, <span class="string">"1ABC.pdb.gz"</span>)   <span class="comment"># Open Babel will uncompress automatically</span></div><div class="line"></div><div class="line">mol.AddHydrogens()</div><div class="line"></div><div class="line">print(mol.NumAtoms())</div><div class="line">print(mol.NumBonds())</div><div class="line">print(mol.NumResidues())</div><div class="line"></div><div class="line">obConversion.WriteFile(mol, <span class="string">'1abc.mol2'</span>)</div></pre></td></tr></table></figure></p><h4 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h4><p>许多Open Babel工具包提供迭代器，其后缀为”iter”,所有的API可以在<a href="http://openbabel.sourceforge.net/api/current/annotated.shtml" target="_blank" rel="external">官网</a>查询</p><h3 id="Pybel模块"><a href="#Pybel模块" class="headerlink" title="Pybel模块"></a>Pybel模块</h3><p>Pybel我觉得是更加好用更加容易理解的工具，使用的方法也很容易，就是<code>import pybel</code>或者<code>from pybel import *</code></p><h4 id="原子和分子"><a href="#原子和分子" class="headerlink" title="原子和分子"></a>原子和分子</h4><p><a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule" target="_blank" rel="external">分子</a>可以通过三种方法进行创建:<br> 1.使用<a href="http://openbabel.org/dev-api/classOpenBabel_1_1OBMol.shtml" target="_blank" rel="external">OBMol</a><br> 2.从文件中阅读（见下）<br> 3.从字符串中阅读（见下）</p><p><a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Atom" target="_blank" rel="external">原子</a>可以通过两种方法创建:<br>  1.使用<a href="http://openbabel.org/dev-api/classOpenBabel_1_1OBAtom.shtml" target="_blank" rel="external">OBAtom</a><br>  2.分子中的<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.atoms" target="_blank" rel="external">原子</a></p><p>分子的话有如下属性:<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.atoms" target="_blank" rel="external">atoms</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.charge" target="_blank" rel="external">charge</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.data" target="_blank" rel="external">data</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.dim" target="_blank" rel="external">dim</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.energy" target="_blank" rel="external">energy</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.exactmass" target="_blank" rel="external">exactmass</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.formula" target="_blank" rel="external">formula</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.molwt" target="_blank" rel="external">molwt</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.spin" target="_blank" rel="external">spin</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.sssr" target="_blank" rel="external">sssr</a>,<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.title" target="_blank" rel="external">title</a>和<a href="http://openbabel.org/docs/current/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.unitcell" target="_blank" rel="external">unitcell</a>（这个需要晶体数据）,atoms属性主要是提供分子中的所有原子列表，data属性可以看作一个字典，可以阅读和编辑数据。</p><p>以下为一个示例，让我们假设有一个SD文件包含数据的描述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;此文章不完全翻译自官方文档，不定期更新，欢迎关注&lt;/p&gt;
&lt;p&gt;Open Babel是一个非常优秀的支持多种分子格式的开源软件，同时可以进行
      
    
    </summary>
    
      <category term="预处理" scheme="http://kangsgo.com/categories/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
    
      <category term="OpenBabel" scheme="http://kangsgo.com/tags/OpenBabel/"/>
    
  </entry>
  
  <entry>
    <title>gromacs中构建非标准氨基酸残基力场</title>
    <link href="http://kangsgo.com/13.html"/>
    <id>http://kangsgo.com/13.html</id>
    <published>2017-12-09T12:33:22.302Z</published>
    <updated>2017-12-10T05:13:21.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gromacs非标准残基构建"><a href="#Gromacs非标准残基构建" class="headerlink" title="Gromacs非标准残基构建"></a>Gromacs非标准残基构建</h1><p>李老师其实已经有非常详细的实例来讲解如何进行<a href="http://jerkwin.github.io/2017/09/20/GROMACS%E9%9D%9E%E6%A0%87%E5%87%86%E6%AE%8B%E5%9F%BA%E6%95%99%E7%A8%8B2-%E8%8A%8B%E8%9E%BA%E6%AF%92%E7%B4%A0%E5%B0%8F%E8%82%BD%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">非标准残基</a>的搭建方法，此方法是之前根据李老师的方法结合<a href="http://ambermd.org/tutorials/basic/tutorial5/index.htm" target="_blank" rel="external">amber教程</a>进行改编的方法，可以作为参考。</p><p>我们使用ser磷酸化的蛋白作为实验，由于还未发表文章，暂时不提供示例步骤下载。若有问题可以邮件联系我交流：kangsgo#vip.qq.com</p><h3 id="1-单独保存非标准残基"><a href="#1-单独保存非标准残基" class="headerlink" title="1.单独保存非标准残基"></a>1.单独保存非标准残基</h3><p>我们首先使用pymol将sep独立导出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select <span class="keyword">not</span> resn SEP</div><div class="line">remove sele</div></pre></td></tr></table></figure></p><p>将其保存为sep.pdb文件，当然也可以直接用<code>gedit</code>等打开文件，将SEP部分（HETAM）copy导出</p><p>sep文件内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ATOM      1  N   SEP A 219      10.386  -7.407  38.687  1.00 31.68           N  </div><div class="line">ATOM      2  CA  SEP A 219      10.979  -8.567  39.325  1.00 31.58           C  </div><div class="line">ATOM      3  C   SEP A 219      12.450  -8.306  39.481  1.00 28.97           C  </div><div class="line">ATOM      4  O   SEP A 219      13.189  -8.279  38.504  1.00 28.84           O  </div><div class="line">ATOM      5  CB  SEP A 219      10.724  -9.808  38.495  1.00  0.00           C  </div><div class="line">ATOM      6  OG  SEP A 219      11.474 -10.889  39.010  1.00  0.00           O  </div><div class="line">ATOM      7  P   SEP A 219      11.419 -12.337  38.313  1.00  0.00           P1+</div><div class="line">ATOM      8  O2P SEP A 219      12.339 -13.139  39.147  1.00  0.00           O1-</div><div class="line">ATOM      9  O1P SEP A 219       9.990 -12.703  38.422  1.00  0.00           O1-</div><div class="line">ATOM     10  O3P SEP A 219      11.893 -12.061  36.938  1.00  0.00           O1-</div><div class="line">ATOM     11  H   SEP A 219      10.767  -7.078  37.811  1.00 31.68           H  </div><div class="line">ATOM     12  HA  SEP A 219      10.534  -8.738  40.305  1.00 31.58           H  </div><div class="line">ATOM     13  HB2 SEP A 219       9.662 -10.058  38.502  1.00  0.00           H  </div><div class="line">ATOM     14  HB3 SEP A 219      11.035  -9.614  37.467  1.00  0.00           H</div></pre></td></tr></table></figure></p><p>不难看出带的电荷为-2</p><p>我们需要补全两端的氢键(封端)，我是用gview补全的，也可以用pymol,chimera等补全，但是需要注意的是要查看补全的氢键是否正确，我在chimera上补全的氢键就有问题，对于补全氢键，个人的经验觉得正确度排序为:gv&gt;chimera&gt;pymol</p><p>补全后如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">HETATM    1  N   SEP A 219      10.386  -7.407  38.687                       N</div><div class="line">HETATM    2  CA  SEP A 219      10.979  -8.567  39.325                       C</div><div class="line">HETATM    3  C   SEP A 219      12.450  -8.306  39.481                       C</div><div class="line">HETATM    4  O   SEP A 219      13.189  -8.279  38.504                       O</div><div class="line">HETATM    5  CB  SEP A 219      10.724  -9.808  38.495                       C</div><div class="line">HETATM    6  OG  SEP A 219      11.474 -10.889  39.010                       O</div><div class="line">HETATM    7  P   SEP A 219      11.419 -12.337  38.313                       P</div><div class="line">HETATM    8  O2P SEP A 219      12.339 -13.139  39.147                       O</div><div class="line">HETATM    9  O1P SEP A 219       9.990 -12.703  38.422                       O</div><div class="line">HETATM   10  O3P SEP A 219      11.893 -12.061  36.938                       O</div><div class="line">HETATM   11  H   SEP A 219      10.767  -7.078  37.811                       H</div><div class="line">HETATM   12  HA  SEP A 219      10.534  -8.738  40.305                       H</div><div class="line">HETATM   13  HB2 SEP A 219       9.662 -10.058  38.502                       H</div><div class="line">HETATM   14  HB3 SEP A 219      11.035  -9.614  37.467                       H</div><div class="line">HETATM   15 2H   SEP A 219      10.544  -6.657  39.329                       H</div><div class="line">HETATM   16  H   SEP A 219      12.857  -8.142  40.457                       H</div><div class="line">TER      16      SEP A 219</div><div class="line">END</div><div class="line">CONECT    1    2   11   15</div><div class="line">CONECT    2    1    3    5   12</div><div class="line">CONECT    3    2    4   16</div><div class="line">CONECT    4    3</div><div class="line">CONECT    5    2    6   13   14</div><div class="line">CONECT    6    5    7</div><div class="line">CONECT    7    6    8    9   10</div><div class="line">CONECT    8    7</div><div class="line">CONECT    9    7</div><div class="line">CONECT   10    7</div><div class="line">CONECT   11    1</div><div class="line">CONECT   12    2</div><div class="line">CONECT   13    5</div><div class="line">CONECT   14    5</div><div class="line">CONECT   15    1</div><div class="line">CONECT   16    3</div></pre></td></tr></table></figure></p><h3 id="2-制作高斯输入文件"><a href="#2-制作高斯输入文件" class="headerlink" title="2.制作高斯输入文件"></a>2.制作高斯输入文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antechamber -<span class="keyword">fi</span> pdb -i sep.pdb -fo gcrt -o sep.gjf -ch <span class="string">"sep.chk"</span> -gm <span class="string">"%mem=2048MB"</span> -gn <span class="string">"%nproc=4"</span> -nc -2</div></pre></td></tr></table></figure><p>如果按照李老师的方法还需要使用-ge 生成高斯esp文件，通过iop(6/50=1)，可以参考下面一条命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antechamber -<span class="keyword">fi</span> pdb -i sep.pdb  -o ligand.gjf -fo gcrt -pf y -gn <span class="string">"%nproc=8"</span> -gm <span class="string">"%mem=1000MB"</span> -ch <span class="string">"ligand"</span> -gk <span class="string">"#HF/6-31G* SCF=tight Test Pop=MK iop(6/33=2) iop(6/42=6) iop(6/50=1) opt"</span> -ge ligand.gesp -gv 1</div></pre></td></tr></table></figure></p><p>命令解释如下:<br><code>-fi</code>为输入格式<br><code>-i</code>为输入文件<br><code>-fo</code>为输出文件格式 gcrt为高斯gjf格式<br><code>-ch</code>为高斯chk文件<br><code>-gm -gn</code>为使用内存和核数<br><code>-nc</code> 为电荷数</p><h3 id="3-转化为gromacs文件"><a href="#3-转化为gromacs文件" class="headerlink" title="3.转化为gromacs文件"></a>3.转化为gromacs文件</h3><p>实际上与蛋白配体中的小分子制作方式是一样的，首先在这里下载<a href="http://svn.code.sf.net/p/ccpn/code/branches/stable/ccpn/python/acpype/" target="_blank" rel="external">ACPYPE</a>，注意需要下载<strong>sf版本</strong>,否则而面角的表达方式不对，首先生成mol2文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antechamber -<span class="keyword">fi</span> gout -i sep.log -rn SEP -fo mol2 -o sep.mol2 -c resp -pf y -at amber</div></pre></td></tr></table></figure></p><p>在这里最好修改一下原子名称，改成与sep.pdb对应，且需要对其进行修改，因为gromacs加氢从1开始，故将HB2,HB3改为HB1,HB2<br>最后的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">@&lt;TRIPOS&gt;ATOM</div><div class="line">      1 N            3.0030    -1.1500     0.1620 N         1 SEP      -1.141452</div><div class="line">      2 CA           1.8370    -0.4940    -0.4350 CT         1 SEP       0.462377</div><div class="line">      3 C            1.8020     0.9980    -0.1460 C          1 SEP       0.457721</div><div class="line">      4 O            2.8040     1.5940     0.1700 O          1 SEP      -0.633121</div><div class="line">      5 CB           0.5190    -1.1870    -0.0550 CT         1 SEP       0.192426</div><div class="line">      6 OG          -0.5100    -0.6800    -0.7990 OS         1 SEP      -0.641051</div><div class="line">      7 P           -1.7850     0.1390     0.0880 P          1 SEP       1.339193</div><div class="line">      8 O2P         -2.7260     0.5020    -1.0190 O2         1 SEP      -0.920441</div><div class="line">      9 O1P         -2.2370    -0.9110     1.0650 O2         1 SEP      -0.920441</div><div class="line">     10 O3P         -1.0110     1.2850     0.7110 O2         1 SEP      -0.920441</div><div class="line">     11 H            2.7710    -1.3680     1.1160 H          1 SEP       0.367588</div><div class="line">     12 HA           1.9150    -0.5690    -1.5210 H1         1 SEP      -0.041482</div><div class="line">     13 HB1          0.6570    -2.2570    -0.2470 H1         1 SEP      -0.007243</div><div class="line">     14 HB2          0.3490    -1.0790     1.0140 H1         1 SEP      -0.007243</div><div class="line">     15 H2           3.7290    -0.4600     0.2230 H          1 SEP       0.367588</div><div class="line">     16 H1           0.8340     1.4820    -0.2400 HA         1 SEP       0.046022</div><div class="line">....</div></pre></td></tr></table></figure></p><p>生成的mol2文件使用<code>parmchk2</code>进行补全参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parmchk2 -i sep.mol2 -f mol2 -o sep.frcmod</div></pre></td></tr></table></figure></p><p>创建<code>leap.in</code>文件，输入如下内容（注意sep修改成自己的名称）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">source leaprc.ff99SBildn</div><div class="line">source leaprc.gaff</div><div class="line">loadamberparams sep.frcmod</div><div class="line">lig=loadmol2 sep.mol2</div><div class="line">check lig</div><div class="line">saveamberparm lig sep.prmtop sep.inpcrd</div><div class="line">quit</div></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tleap -f leap.in</div></pre></td></tr></table></figure></p><p>运行acpype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python2.7 acpype.py -p sep.prmtop -x sep.inpcrd -d</div></pre></td></tr></table></figure></p><p>将会生成<code>SEP_GMX.top</code>和<code>SEP_GMX.gro</code>两个文件，其中<code>SEP_GMX.gro</code>我们用不着</p><h3 id="4-整理残基的rtp条目"><a href="#4-整理残基的rtp条目" class="headerlink" title="4.整理残基的rtp条目"></a>4.整理残基的rtp条目</h3><p>为了保存力场<code>rtp</code>信息，我们需要创建一个<code>sep.rtp</code>文件<br>我们需要对<code>SEP_GMX.gro</code>文件进行整理，即把虚拟的原子电荷附加到N端头和C端尾部的位置。<br>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[ atoms ]</div><div class="line">;   nr  type  resi  res  atom  cgnr     charge      mass       ; qtot   bond_type</div><div class="line">     1    N     1   SEP     N    1    -1.141453     14.01000 ; qtot -1.141</div><div class="line">     2   CT     1   SEP    CA    2     0.462377     12.01000 ; qtot -0.679</div><div class="line">     3    C     1   SEP     C    3     0.457721     12.01000 ; qtot -0.221</div><div class="line">     4    O     1   SEP     O    4    -0.633122     16.00000 ; qtot -0.854</div><div class="line">     5   CT     1   SEP    CB    5     0.192426     12.01000 ; qtot -0.662</div><div class="line">     6   OS     1   SEP    OG    6    -0.641052     16.00000 ; qtot -1.303</div><div class="line">     7    P     1   SEP     P    7     1.339196     30.97000 ; qtot 0.036</div><div class="line">     8   O2     1   SEP   O2P    8    -0.920442     16.00000 ; qtot -0.884</div><div class="line">     9   O2     1   SEP   O1P    9    -0.920442     16.00000 ; qtot -1.805</div><div class="line">    10   O2     1   SEP   O3P   10    -0.920442     16.00000 ; qtot -2.725</div><div class="line">    11    H     1   SEP     H   11     0.367588      1.00800 ; qtot -2.358</div><div class="line">    12   H1     1   SEP    HA   12    -0.041482      1.00800 ; qtot -2.399</div><div class="line">    13   H1     1   SEP   HB1   13    -0.007243      1.00800 ; qtot -2.406</div><div class="line">    14   H1     1   SEP   HB2   14    -0.007243      1.00800 ; qtot -2.414</div><div class="line">    15    H     1   SEP    H2   15     0.367588      1.00800 ; qtot -2.046</div><div class="line">    16   HA     1   SEP    H1   16     0.046022      1.00800 ; qtot -2.000</div></pre></td></tr></table></figure></p><p>1 N的电荷应该变为-1.141453+0.367588<br>3 C的电荷应该变为0.457721+0.046022</p><p>然后用我写的<a href="/images/2017/12/rtp.py">脚本</a>进行内容的提取:<br>首先创建<code>config.txt</code>文件，在其中写入需要删除的虚拟原子(每一行一个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">H</div><div class="line">HA</div></pre></td></tr></table></figure></p><p>然后运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python rtp.py SEP_GMX.top SEP&gt;data.txt</div></pre></td></tr></table></figure></p><p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[ bondedtypes ]</div><div class="line">; bonds  angles  dihedrals  impropers all_dihedrals nrexcl HH14 RemoveDih</div><div class="line">     1       1          9          4        1         3      1     0</div><div class="line">[ SEP ]</div><div class="line"> [ atoms ]</div><div class="line">      N     N         -0.773865     1</div><div class="line">...</div><div class="line"> [ bonds ]</div><div class="line">      N    CA        1.4620e-01     2.7506e+05</div><div class="line">      N     H        1.0130e-01     3.3740e+05</div><div class="line">     CA     C        1.5240e-01     2.6192e+05</div><div class="line">...</div><div class="line"> [ angles ]</div><div class="line">      N    CA     C      1.0906e+02        5.6066e+02</div><div class="line">      N    CA    CB      1.1161e+02        5.5153e+02</div><div class="line">      N    CA    HA      1.0888e+02        4.1706e+02</div><div class="line">     CA     N     H      1.1768e+02        3.8325e+02</div><div class="line">     CA     C     O      1.2320e+02        5.6400e+02</div><div class="line">...</div><div class="line"> [ dihedrals ] ; propers</div><div class="line">     N    CA     C         O    180.00   0.00000     9</div><div class="line">     N    CA    CB        OG      0.00   0.65084     9</div><div class="line">     N    CA    CB       HB1      0.00   0.65084     9</div><div class="line">     N    CA    CB       HB2      0.00   0.65084     9</div><div class="line">...</div><div class="line"> [ impropers ]</div></pre></td></tr></table></figure></p><p>我们需要在[bonds]中增加前一个氨基酸残基的联系连接,[impropers]中增加前后氨基酸残基的联系连接，可以简单的看非标准残基来源的氨基酸残基模板(aminoacids.rtp)或者查看<code>SEP_GMX.top</code>文件中删除的两个氢原子的部分，最后整理结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"> [ bonds ]</div><div class="line">     -C     N</div><div class="line">      N    CA        1.4620e-01     2.7506e+05</div><div class="line">      N     H        1.0130e-01     3.3740e+05</div><div class="line">     CA     C        1.5240e-01     2.6192e+05</div><div class="line">     CA    CB        1.5380e-01     2.5179e+05</div><div class="line">...</div><div class="line"> [ impropers ]</div><div class="line">    -C    CA     N     H</div><div class="line">    CA    +N     C     O</div></pre></td></tr></table></figure></p><h3 id="5-整理残基的hdb条目"><a href="#5-整理残基的hdb条目" class="headerlink" title="5.整理残基的hdb条目"></a>5.整理残基的hdb条目</h3><p>由于氢键一般有问题，我们需要重新绘制氢键，那么我们创建一个<code>sep.hdb</code>的文件，按照下图来进行设置(图片来源李老师博客):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/12/gmxhdb.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></p><p>结果如下图(可以抄SER的信息):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SEP  3</div><div class="line">1   1   H    N  -C   CA</div><div class="line">1   5   HA   CA  N   CB    C</div><div class="line">26HBCBCAOG</div></pre></td></tr></table></figure></p><h3 id="6-模拟尝试"><a href="#6-模拟尝试" class="headerlink" title="6.模拟尝试"></a>6.模拟尝试</h3><p>将gromacs 目录下(gromacs/share/gromacs/top)中的amber99sb-ildn.ff拷贝至实验目录下（如果找不到可以用which gmx_mpi），将<code>sep.rtp</code>文件和<code>sep.hdb</code>文件放到拷贝出来的amber99sb-ildn.ff目录下。且在top目录下的<code>residuetypes.dat</code>中申明SEP为蛋白，即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEP     Protein ; sep，增加部分</div><div class="line">ABUProtein</div><div class="line">ACEProtein</div><div class="line">AIBProtein</div><div class="line">ALA  Protein</div><div class="line">ARG  Protein</div><div class="line">ARGNProtein</div><div class="line">ASNProtein</div><div class="line">ASN1  Protein</div><div class="line">...</div></pre></td></tr></table></figure></p><p>最后进行模拟尝试看是否可以跑通<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gmx_mpi pdb2gmx -f model.pdb -o model_process.gro -water tip3p -ignh</div></pre></td></tr></table></figure></p><p>若提示前一个残基或者末端残基报错，那么检查是否是上述两个文件出错，若提示缺失（SEP的）原子，那么创建<code>sep.atp</code>文件，在<code>SEP_GMX.top</code>,找到提示的缺失原子，放入该文件中，最后将<code>sep.atp</code>文件放到拷贝出来的amber99sb-ildn.ff目录下。</p><p>参考资料:<br><a href="http://jerkwin.github.io/2017/09/20/GROMACS%E9%9D%9E%E6%A0%87%E5%87%86%E6%AE%8B%E5%9F%BA%E6%95%99%E7%A8%8B2-%E8%8A%8B%E8%9E%BA%E6%AF%92%E7%B4%A0%E5%B0%8F%E8%82%BD%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">GROMACS非标准残基教程2-芋螺毒素小肽实例</a><br><a href="http://blog.sina.com.cn/s/blog_6ceaa7650101du7w.html" target="_blank" rel="external">向gromacs中添加小分子力场方法 </a><br><a href="http://blog.csdn.net/sinat_23241095/article/details/53836200" target="_blank" rel="external">amber中非标准氨基酸残基的参数生成</a><br><a href="http://ambermd.org/tutorials/basic/tutorial5/" target="_blank" rel="external">Simulating the Green Fluorescent Protein</a><br><a href="https://jerkwin.github.io/2015/12/08/%E4%BD%BF%E7%94%A8AmberTools+ACPYPE+Gaussian%E5%88%9B%E5%BB%BA%E5%B0%8F%E5%88%86%E5%AD%90GAFF%E5%8A%9B%E5%9C%BA%E7%9A%84%E6%8B%93%E6%89%91%E6%96%87%E4%BB%B6/" target="_blank" rel="external">使用AmberTools+ACPYPE+Gaussian创建小分子GAFF力场的拓扑文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gromacs非标准残基构建&quot;&gt;&lt;a href=&quot;#Gromacs非标准残基构建&quot; class=&quot;headerlink&quot; title=&quot;Gromacs非标准残基构建&quot;&gt;&lt;/a&gt;Gromacs非标准残基构建&lt;/h1&gt;&lt;p&gt;李老师其实已经有非常详细的实例来讲解如何进行
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>mahotas进行细胞统计开胃菜</title>
    <link href="http://kangsgo.com/9.html"/>
    <id>http://kangsgo.com/9.html</id>
    <published>2017-11-27T04:27:23.000Z</published>
    <updated>2017-12-01T11:02:28.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-图像教程"><a href="#Python-图像教程" class="headerlink" title="Python 图像教程"></a>Python 图像教程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="需要用到的软件"><a href="#需要用到的软件" class="headerlink" title="需要用到的软件"></a>需要用到的软件</h4><ul><li>Python 3+</li><li>numpy</li><li>matplotlib</li><li>mahotas</li><li>ipython&amp;notebook</li></ul><h2 id="第一个项目-计算细胞核"><a href="#第一个项目-计算细胞核" class="headerlink" title="第一个项目:计算细胞核"></a>第一个项目:计算细胞核</h2><p>我们的第一个任务是进行细胞核的计算，你可以点击图像进行下载到本地跟着进行运行<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/dna.jpeg" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><br>首先导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> mahotas <span class="keyword">as</span> mh</div></pre></td></tr></table></figure><p>对于Python，有能够通过包来完成许多工具，而不是一个包。我们用numpy数组进行储存图像，在我们的案例中，其是一个二维数组（高X宽），或者，对于彩色图像，为三维数组（高X宽X3或者高X宽X4，其中3和4分别表示red，green，blue或者red，green，blue，alpha的元组，其中alpha为透明度）<br>首先我们读取图像进入内存:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dna=mh.imread(<span class="string">'dna.jpeg'</span>)</div></pre></td></tr></table></figure><h3 id="玩弄"><a href="#玩弄" class="headerlink" title="玩弄"></a>玩弄</h3><p>在交互模式，例如ipython，你可以查看使用如下方法查看图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.imshow(dna)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_6_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>你可能惊讶图片并不像原来的图片是黑色的，原因是plt默认展示的为jet()  bar，你可以通过切换colormap来切换成默认的灰度图，例如如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plt.imshow(dna)</div><div class="line">plt.gray()</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_8_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>你还可以探索如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(dna.shape)</div><div class="line">print(dna.dtype)</div><div class="line">print(dna.max())</div><div class="line">print(dna.min())</div></pre></td></tr></table></figure><pre><code>(1024, 1344)uint82520</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.imshow(dna // <span class="number">2</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_11_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>我们将图片所有性质除以2，然而得到的结果居然一样，实际上plt在展示图片之前会进行对比扩展</p><h3 id="一些实际的工作"><a href="#一些实际的工作" class="headerlink" title="一些实际的工作"></a>一些实际的工作</h3><p>现在我们开始实际的计算核酸的工作，我们对开篇导入的图片的物体（objects）进行计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T=mh.thresholding.otsu(dna)</div><div class="line">plt.imshow(dna&gt;T)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_13_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>在这里，我们又一次利用了dna是一个numpy数组，并在逻辑运算中使用它（dna&gt; T）的事实。 结果是一个布尔值的数组，这个pylab显示为一个黑白图像。<br>但是看起来不是那么美好，因为图像包含了许多小的物体。这里有两个方法解决它。一个简单的方法是使用Gaussian筛选抚平小的物体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dnaf = mh.gaussian_filter(dna, <span class="number">8</span>).astype(<span class="string">'uint8'</span>)</div><div class="line">T = mh.thresholding.otsu(dnaf)</div><div class="line">plt.imshow(dnaf&gt;T)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_15_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p><code>mh.gaussian_filter</code>接收图像并过滤器的标准偏差(以像素为单位)并返回过滤后的图像，但是一个更好的方法是使用mahotas筛选图像并且计算阈值，使用numpy操作创建的图像，并用plt展示他们，但是所有的工作都是数组完成的，这样的结果会更好。</p><p>我们现在进行一些细胞核的merged。 最后的计数只是一个额外的函数调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">labeled,nr_objects=mh.label(dnaf&gt;T)</div><div class="line">print(nr_objects)</div><div class="line">plt.imshow(labeled)</div><div class="line">plt.jet()</div><div class="line">plt.show()</div></pre></td></tr></table></figure><pre><code>18</code></pre><p><img src="/images/2017/11/output_18_1.png" alt="png"></p><p>我们拥有物体的图像为18个，展示的为标记的（labeled）图像，使用jet()进行着色<br>我们可以探索标记的物体，其是一个整数的数组，它的值是该位置上对象的标签，所以值的范围从0（背景）到nr_objects。</p><h2 id="第二个项目-分隔图像"><a href="#第二个项目-分隔图像" class="headerlink" title="第二个项目:分隔图像"></a>第二个项目:分隔图像</h2><p>通过第一个项目，我们完成的还是令人满意，但是仍然有一些核酸是黏在一起的，然我们to do better<br>这里有一个简单的，传统的想法:</p><ol><li>平滑图像</li><li>寻找区域最大值</li><li>使用区域最大值作为watershed的种子</li></ol><h3 id="寻找种子"><a href="#寻找种子" class="headerlink" title="寻找种子"></a>寻找种子</h3><p>但是且慢，有一些细胞在照片上重叠了，被我们算作一个细胞了。显然是这不科学的，因此我们需要更精确的计算方法。接下来我们要讨论的方法寻找团块的中心点并计算中心点的个数。这里我们假设在灰度图上，团块比较中心的地方比较亮，最亮的地方就是最中心的地方。这个东西叫regional maxima，相当于一片山脉中的最高峰。我们找到这个点之后，进行标亮，并且与原来的灰度图重叠在一起。首先我们进行如下的尝试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#plt.figure(figsize=(15,15))</span></div><div class="line">dnaf=mh.gaussian_filter(dna,<span class="number">8</span>).astype(<span class="string">'uint8'</span>)</div><div class="line">rmax=mh.regmax(dnaf)</div><div class="line">plt.imshow(mh.overlay(dna,rmax))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_20_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p><code>mh.overlay()</code>返回一个彩色图像，第一个参数给出灰度级分量，而第二个参数作为红色通道。 结果看起来不太好：<br>稍微摆弄一下后，我们决定用一个更大的sigma尝试相同的想法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">15</span>))</div><div class="line">dnaf=mh.gaussian_filter(dna,<span class="number">15</span>).astype(<span class="string">'uint8'</span>)</div><div class="line">rmax=mh.regmax(dnaf)</div><div class="line">plt.imshow(mh.overlay(dna,rmax))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_22_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>看起来好许多，我们可以方便的统计核算数量了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">seeds,nr_nuclei=mh.label(rmax)</div><div class="line">print(nr_nuclei)</div></pre></td></tr></table></figure><pre><code>22</code></pre><h3 id="Watershed"><a href="#Watershed" class="headerlink" title="Watershed"></a>Watershed</h3><p>我们打算将Watershed应用于阈值图像的距离变换(使用矩阵最大值减去矩阵内所有元素，使得矩阵元素的数值原来大的变小，小的变大,得到下图)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">T=mh.thresholding.otsu(dnaf)</div><div class="line">dist =  mh.distance(dnaf&gt;T)</div><div class="line">dist =  dist.max()-dist</div><div class="line">dist -= dist.min()</div><div class="line">dist  = dist/float(dist.ptp())*<span class="number">255</span></div><div class="line">dist  = dist.astype(np.uint8)</div><div class="line">plt.imshow(dist)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_26_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>现在，根据矩阵的元素的大小，以之前得到的一堆最高峰（seeds）为核心位置，观察每个核心与邻居核心之间的边界（元素数值的局域极大值），把这个边界标记出来。就得到了核心的区域划分图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nuclei=mh.cwatershed(dist,seeds)</div><div class="line">plt.imshow(nuclei)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/output_27_0.png" alt="png" title="">                </div>                <div class="image-caption">png</div>            </figure><p>参考资料:<br><a href="http://pythonvision.org/basic-tutorial/" target="_blank" rel="external">原文</a><br><a href="http://wiki.swarma.net/index.php?title=%E4%BD%BF%E7%94%A8python%E5%81%9A%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86&amp;variant=zh" target="_blank" rel="external">使用python做图像处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-图像教程&quot;&gt;&lt;a href=&quot;#Python-图像教程&quot; class=&quot;headerlink&quot; title=&quot;Python 图像教程&quot;&gt;&lt;/a&gt;Python 图像教程&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;head
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="mahotas" scheme="http://kangsgo.com/tags/mahotas/"/>
    
  </entry>
  
  <entry>
    <title>mahotas安装教程</title>
    <link href="http://kangsgo.com/8.html"/>
    <id>http://kangsgo.com/8.html</id>
    <published>2017-11-25T16:38:23.000Z</published>
    <updated>2017-11-25T16:56:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>hi!各位好久不见，小伙伴们的科研道路是否顺利。<br>我的导师告诉我要讲好故事，才能让人觉得生动有趣，所以我今天想用另外一种方式和大家分享今天发现的一个<strong>大</strong>玩意儿</p><p>故事的开始是我有一张图片，想计算图片里东西的长宽，如果一个一个数，一个个比，那太费劲了，所以就百度了一下，看一下有什么办法解决没有，然后谷歌到了一个python处理细胞细胞核的工具，觉得自己应该能够用的上（后面和大家分享），进一步挖掘发现他是用的<a href="https://github.com/luispedro/mahotas" target="_blank" rel="external">mathotas</a>这个包。</p><p>进一步进入github上发现其作者是如下光头男(luispedro):<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/lpc2013-small.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>luispedro是一个计算生物科学家（小伙伴们看到这里是否两眼发光），其原来是利用宏基因组分析微生物群体，对其机器学习和数学等打下了非常坚实的基础，现在主要是利用生物图像信息学进行<a href="https://en.wikipedia.org/wiki/Bioimage_informatics" target="_blank" rel="external">细胞亚定位分析</a>，现在其工作于<a href="http://murphylab.web.cmu.edu/" target="_blank" rel="external">Murphy Lab</a></p><p>所以小伙伴们有细胞等图像处理的时候可以关注一下这个包，我在后期也会分享一些包的应用给大家。今天仅仅简答介绍一下。</p><p>Mahotas 是一个快速的视觉算法的Python包，其主要是用C++写成，速度甚至超过了numpy数组计算操作。</p><p>现在有如下算法:</p><ul><li>watershed</li><li>convex points calculation</li><li>hit &amp; miss, thinning</li><li>Zernike &amp; Haralick, LBP, and TAS features</li><li>Speeded-Up Robust Features(SURF), a form of local features.</li><li>thresholding</li><li>convolution</li><li>Sobel edge detection</li><li>spline interpolation</li><li>SLIC super pixes</li></ul><p>现在Mahotas有超过100种的图像程序处理功能和计算机视觉功能，且现在还在增加。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>言归正传我，我们简单介绍一下安装方法，最简单的安装方法就是使用conda安装，其中conda加强包（conda-forge）具有mahots<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</div><div class="line">conda install mahotas</div></pre></td></tr></table></figure></p><p>其他方法包括pip安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mahotas</div></pre></td></tr></table></figure></p><p>windows 还可以进行包安装，地址为:<br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><p>不过还是建议用conda安装，是否安装成功仅需要<code>import mahotas as mh</code>导入一下看一下是否报错即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hi!各位好久不见，小伙伴们的科研道路是否顺利。&lt;br&gt;我的导师告诉我要讲好故事，才能让人觉得生动有趣，所以我今天想用另外一种方式和大家分享今天发现的一个&lt;strong&gt;大&lt;/strong&gt;玩意儿&lt;/p&gt;
&lt;p&gt;故事的开始是我有一张图片，想计算图片里东西的长宽，如果一个一个
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="mahotas" scheme="http://kangsgo.com/tags/mahotas/"/>
    
  </entry>
  
  <entry>
    <title>利用Pymol将周边图像虚化</title>
    <link href="http://kangsgo.com/7.html"/>
    <id>http://kangsgo.com/7.html</id>
    <published>2017-11-16T12:09:30.000Z</published>
    <updated>2017-11-16T12:09:45.494Z</updated>
    
    <content type="html"><![CDATA[<p><code>FocalBlur</code>是一个Pymol脚本可以创建非常cool的图像，将周边的的图像虚化，更加突出中心的object。<br>虚化图片如下:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/FocalBlur1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先加载<a href="https://github.com/Pymol-Scripts/Pymol-script-repo/raw/master/focal_blur.py" target="_blank" rel="external">FocalBlur</a>脚本:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run focal_blur.py</div></pre></td></tr></table></figure></p><p>然后在pymol中进行使用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FocalBlur aperture=<span class="number">2.0</span>,samples=<span class="number">20</span>,ray=<span class="number">1</span></div></pre></td></tr></table></figure></p><p>如果是python脚本运用的话那么:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FocalBlur(aperture=<span class="number">2.0</span>,samples=<span class="number">20</span>,ray=<span class="number">1</span>)</div></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>当时使用镭射(raytracing)，图像创建的时间将会变得更长，具体的时间和采样n设置的大小有关</li><li>aperture为相机孔隙，值越大越模糊</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/FocalBlur2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure><p>FocalBlur aperture=1,samples=100,ray=1</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/FocalBlur3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure><p>FocalBlur aperture=2,samples=100,ray=1</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/FocalBlur4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure><p>FocalBlur aperture=4,samples=400,ray=1</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/FocalBlur5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure><p>FocalBlur aperture=4,samples=400,ray=0</p><p>非常简单直观</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;FocalBlur&lt;/code&gt;是一个Pymol脚本可以创建非常cool的图像，将周边的的图像虚化，更加突出中心的object。&lt;br&gt;虚化图片如下:&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div c
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>使用python得到TCGA表格</title>
    <link href="http://kangsgo.com/6.html"/>
    <id>http://kangsgo.com/6.html</id>
    <published>2017-11-14T01:53:21.000Z</published>
    <updated>2017-11-14T02:17:38.013Z</updated>
    
    <content type="html"><![CDATA[<p>我们需要提取下面的表格到本地，具体图片如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/11/tcga1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><p>我们首先先点击表格右上角的JSON下载为JSON格式(假设保存的为<code>data.json</code>格式)，打开可以发现其数据与表格上的数据是有差别的，我们用如下代码进行处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"><span class="comment"># author:kangsgo</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">model=&#123;&#125;</div><div class="line"><span class="comment">#解码json</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> json_file:</div><div class="line">    model=json.load(json_file)</div><div class="line"></div><div class="line"><span class="comment">#写入到data.csv文件中</span></div><div class="line">f=open(<span class="string">'data.csv'</span>,<span class="string">'w'</span>)</div><div class="line">count=<span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> model:</div><div class="line">    a=[]</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i[<span class="string">'consequence'</span>]:</div><div class="line">        a.append(j[<span class="string">'transcript'</span>][<span class="string">'aa_change'</span>])</div><div class="line">    a=list(set(a))</div><div class="line">    f.write(i[<span class="string">'genomic_dna_change'</span>]+<span class="string">';'</span>+i[<span class="string">'ssm_id'</span>]+<span class="string">';'</span>+i[<span class="string">'mutation_subtype'</span>]+<span class="string">';'</span> \</div><div class="line">       +str(len(a))+<span class="string">'/567'</span>+<span class="string">';'</span>+str(len(i[<span class="string">'consequence'</span>]))+<span class="string">'/10188'</span>)</div><div class="line">    f.write(<span class="string">'\n'</span>)</div><div class="line">    count += <span class="number">1</span></div><div class="line">f.close()</div></pre></td></tr></table></figure></p><p>将会得到<code>data.csv</code>的csv文件，可以用excel等工具进一步处理分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们需要提取下面的表格到本地，具体图片如下:&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overl
      
    
    </summary>
    
      <category term="Python" scheme="http://kangsgo.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>SMINA教程以CDPK1为例</title>
    <link href="http://kangsgo.com/5.html"/>
    <id>http://kangsgo.com/5.html</id>
    <published>2017-11-08T07:04:21.000Z</published>
    <updated>2017-11-12T06:29:44.946Z</updated>
    
    <content type="html"><![CDATA[<p>SMINA教程以CDPK1为例</p><p>原作者:David Ryan Koes<br>翻译:康文渊</p><p>若进行精读建议查看原文以及参考文献，本文是我根据教程快速阅读做的笔记</p><blockquote><p>Q1:我们有autodock vina，为什么还要SMINA？</p><p>A1:SMINA有更加优秀的速度和更加的扩展性</p><p>Q2:用该对接软件有什么优势？</p><p>A2:首先该对接软件为免费/学术免费软件，其次其有非常良好的对接准确度，甚至在商业软件中都为上乘，同时可以很好的运用SMINA进行得分改造，进一步提升性能和速度</p></blockquote><p>本教程是一个使用SMINA进行对<em>E.tenella</em>中的钙依赖性蛋白激酶1(calcium-dependent protein kinase 1 CDPK1)进行的结构为基础的虚拟筛选的教程。<em>E.tenella</em>是一种感染幼禽并且导致潜在致命球虫病的寄生虫。尽管这种酶并未解析晶体结构（译者翻译时该结构已经被解析，pdb:4YSJ），但是有相关寄生虫的该种酶的结构。<em>C. parvum</em> 和 <em>T. gondii</em>的该种酶结构已经被解析，并且有生物活性数据表明他们的小分子竭抗剂。<br>我们将会对怎么分析已知结构，评价SMINA对于这些结构的表现，对于对接结果创建自定义的得分函数，使用SWISS-MODEL创建<em>E.tenella</em>的结构模型，并且进行<em>E.tenella</em>CDPK1的虚拟筛选。（个人认为作者提到的<em>E.tenella</em>均表示的为<em>E.tenella</em>CDPK1）。</p><h2 id="假设和惯例"><a href="#假设和惯例" class="headerlink" title="假设和惯例"></a>假设和惯例</h2><p>假设读者对Linux命令行有一定的了解，并对一些用到的软件熟悉。教程在Ubuntu Linux12.04（原作者）和Ubuntu Linux16.04（译者）测试通过。bash命令行如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"Hello"</span></div></pre></td></tr></table></figure></p><p>python基础的PyMOL环境展示如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#python2.x</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello"</span></div></pre></td></tr></table></figure></p><p>以下为（译者）用到的软件:<br>|–Software–|–License–|–Source–|<br>|—|—|—|<br>|<a href="/images/2017/smina/color_by_mutation.py">color_by_mutation</a>|GNU|<a href="http://www.pymolwiki.org/index.php/Color_By_Mutations|" target="_blank" rel="external">http://www.pymolwiki.org/index.php/Color_By_Mutations|</a><br>|PyMOL 1.7.x|Python|<a href="http://sourceforge.net/projects/pymol/|" target="_blank" rel="external">http://sourceforge.net/projects/pymol/|</a><br>|RDKit 2017_03|BSD Style|<a href="http://rdkit.org/|" target="_blank" rel="external">http://rdkit.org/|</a><br>|smina|GPLv2|<a href="http://sourceforge.net/projects/smina/|" target="_blank" rel="external">http://sourceforge.net/projects/smina/|</a></p><h1 id="1-检查C-parvum和T-gondii晶体结构"><a href="#1-检查C-parvum和T-gondii晶体结构" class="headerlink" title="1. 检查C.parvum和T.gondii晶体结构"></a>1. 检查<em>C.parvum</em>和<em>T.gondii</em>晶体结构</h1><p>该部分内容可以参考早期博客文章同源建模系列<br>首先我们分析<em>E.tenella</em>序列和验证三个结构的异同（三个寄生虫中改结构）。然后我们使用<em>C.parvum</em>和<em>T.gondii</em>创建一个虚拟筛选的测试集，并且对接这些测试集化合物。我们使用这些对接结果来进行晶体结构的筛选和模型的增加。</p><h2 id="1-1-靶标分析"><a href="#1-1-靶标分析" class="headerlink" title="1.1 靶标分析"></a>1.1 靶标分析</h2><p>首先，我们分析<em>E.tenella</em>序列和<em>C.parvum</em>和<em>T.gondii*</em>结构</p><h3 id="1-1-1-E-tenella序列分析"><a href="#1-1-1-E-tenella序列分析" class="headerlink" title="1.1.1 E.tenella序列分析"></a>1.1.1 <em>E.tenella</em>序列分析</h3><p>1.复制或者下载<em>E.tenella</em>的FASTA序列,你可以点击<a href="http://www.ncbi.nlm.nih.gov/protein/CAA96439" target="_blank" rel="external">这里</a>进入网址,同样也可以<a href="/images/2017/smina/CDPK1.fasta">下载</a>我们已经下载好的。</p><p>2.进行BLAST搜索，若你为进入的网址，可以直接点击ncbi右侧的BLAST进行搜寻（如下图）。若为下载的文件可以进入<a href="http://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastp" target="_blank" rel="external">BLAST页面</a>上传fasta文件进行搜寻。<br>   <img src="/images/2017/smina/SMINA1.png" alt="图1"></p><p>3.进入页面。</p><p>   <img src="/images/2017/smina/SMINA2.png" alt="图2"><br>4.点击<strong>BLAST</strong>。</p><p>5.结果如图3,可以发现得分最高的为已经解析的结构，相似度为99%，但是我们在这里假装没有。排第二的为Neospora Caninum（4M97），但是更加相近的为<em>T.gondii</em>的几个结构（4M7N，3KU2,<a href="/images/2017/smina/3i79.pdb">3I79</a>,3HX4,3I7C），相似度大于80%。<em>C.parvum</em>的首次命中（3IGO）相似度为62%。</p><p>   <img src="/images/2017/smina/SMINA3.png" alt="图3"></p><p>从中我们得出的结论为<em>T.gondii</em>的CDPK1相比于<em>C.parvum</em>具有更高的相似度。建议<em>T.gondii</em>结构选为同源建模的模板更为合理。</p><h3 id="1-1-2-结构分析"><a href="#1-1-2-结构分析" class="headerlink" title="1.1.2 结构分析"></a>1.1.2 结构分析</h3><p>为了鉴定<em>T.gondii</em>和<em>E.tenella</em>之间CDPK1结合位点的差别，我们创建了一个<em>E.tenella</em>同源模型。并且使用<a href="/images/2017/smina/color_by_mutation.py">color_by_mutation</a>和PyMOL进行结构可视化序列的不同。<br>1.在<a href="http://swissmodel.expasy.org/" target="_blank" rel="external">SWISS-MODEL</a>进行自动建模，你也可以参考之前的教程 </p><blockquote><p>译者注：我认为该方法并不是建模的最佳方法，最佳方法为找到具有共同抑制剂的晶体结构进行基于配体的多模板建模，这样可以保证重要的活性腔的相似，而不是使用没有结合配体的晶体结构进行建模。</p></blockquote><p>2.输入<em>E.tenella</em>的FASTA序列和3I79进行建模（图4）</p><p>  <img src="/images/2017/smina/SMINA4.png" alt="图4"></p><p>3.下载结果文件，你可以在这里<a href="/images/2017/smina/swissmodel.pdb">下载</a>我已经建模好的。</p><p>4.在PyMOL中加载模型，3I79和3NCG</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">load swissmodel.pdb</div><div class="line">fetch <span class="number">3</span>I79</div><div class="line">fetch <span class="number">3</span>NCG</div></pre></td></tr></table></figure><blockquote><p>译者注：在这里<code>3NCG</code>来的有点突然，搜索一下可以发现3NCG为<em>C.parvum</em>的激活状态下的晶体结构</p></blockquote><p>5.比对结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alignto</div></pre></td></tr></table></figure><p>6.从3NCG中提取BK1配体，并且隐藏该pdb的其余结构，因为3I79为非结合状态，我们使用这个配体来占有结合位点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extract bk1,resn BK1</div><div class="line">hide (/<span class="number">3</span>NCG/)</div></pre></td></tr></table></figure><p>7.探索模型和3I79结合位点周围的残基，值得注意的是SWISS-MODEL忠实的复制了侧链构像。</p><p>8.着色两者之间的突变位点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">run color\_by\_mutation.py</div><div class="line">color\_by\_mutation swissmodel,<span class="number">3</span>i79</div></pre></td></tr></table></figure><p>9.探索结合位点，注意的是3I79中GLY128在<em>E.tenella</em>模型中被突变为THR 108，其余在结合位点是大体不变的。</p><p>  <img src="/images/2017/smina/SMINA5.png" alt="图5"></p><p>10.重复分析3NCG，可以发现<em>C.parvum</em>在结合位点附近具有更多的突变</p><h2 id="1-2-测试集的创建"><a href="#1-2-测试集的创建" class="headerlink" title="1.2 测试集的创建"></a>1.2 测试集的创建</h2><p>PubChem上有<em>T.gondii</em>和<em>C.parvum</em>的CDPK1诘抗击。我们使用这些数据作为虚拟筛选的测试集对这两个靶标进行筛选.</p><h3 id="1-2-1组装活性化合物"><a href="#1-2-1组装活性化合物" class="headerlink" title="1.2.1组装活性化合物"></a>1.2.1组装活性化合物</h3><p>(a)在<a href="http://pubchem.ncbi.nlm.nih.gov" target="_blank" rel="external">PubChem</a>搜索CDPK1然后排序活性化合物,每个靶点选择三个最大的化合物数据集,为了保证和教程一致,我们选择的为和原教程相同的数据集.<br>    <em>T.gondii</em><br>    aid:677062,600378,672956<br>    <em>C.parvum</em><br>    aid:600379,672955,66097</p><p>(b)选择active,然后点击Structures下载,之后选择没有压缩的SMILES格式,可以点此<a href="/images/2017/smina/SMINA.tar.gz">下载</a>我们下载好的</p><p>(c)修正SMILES结构。下载的SMILES文件字符串和标题顺序相反。另外，我们需要去除salt，并将关键字“active”添加到所有活性化合物的标题中。我们每个文献执行如下命令（例如aid677062.txt为例）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $2,$1"_active"&#125;'</span> aid677062.txt | sed <span class="string">'s/\.Cl//'</span> &gt; aid677062.smi</div></pre></td></tr></table></figure></p><p>awk主要是进行了前后的颠倒，并且在标题后增加active标签，sed主要是将Cl进行替换，替换成空，中间用管道链接，输出到smi文件格式。</p><p>(d)将每个靶点的内容合并为单个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat aid*.smi &gt; activaes.msi</div></pre></td></tr></table></figure><p><em>T.gondii</em>和<em>C.pavum</em>分别包含156个和89个活性化合物。你可以在这里<a href="/images/2017/smina/SMINA2.tar.gz">下载</a>合并好的文件。</p><h3 id="1-2-2-创建诱饵数据集"><a href="#1-2-2-创建诱饵数据集" class="headerlink" title="1.2.2 创建诱饵数据集"></a>1.2.2 创建诱饵数据集</h3><p>   <strong>该在线网站说只需要10min，实际上需要1-2天左右时间</strong><br>   由于这些靶点的无活性配体数量较少，我们使用诱饵数据库Database of Useful Decoys：Enhanced（DUDE）方法来从ZINC数据库中进行采样。这些诱饵被选择的方法为化学性质不相同（即和有活性的配体相比较不相似，认为是不结合的）。但分子质量，logP，旋转键和氢键受体供体这些简单的分子参数是相同的。</p><p>(a)使用<a href="http://dude.docking.org/generate" target="_blank" rel="external">DUDE</a>网站创建诱饵数据集,将会生成dude-decoys.tar.gz文件，里面包含50个参数匹配的诱饵。</p><p>(b)将诱饵结合进入单个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat decoys/* | grep -v ligand &gt; decoys.msi</div></pre></td></tr></table></figure><p>点此<a href="/images/2017/smina/SMINA3.tar.gz">下载</a>decoys文件，(<em>T.gondii</em>诱饵和活性化合物。<em>C.pavum</em>诱饵和活性化合物)。</p><h3 id="1-2-3-生成三维结构"><a href="#1-2-3-生成三维结构" class="headerlink" title="1.2.3 生成三维结构"></a>1.2.3 生成三维结构</h3><p>  我们将使用开源软件RDKit利用2D SMILES生成3D构像</p><p>(a)将RDKit写入你的PYTHONPATH，并且执行<a href="/images/2017/smina/rdconf.py">rdconf.py</a>脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://bits.csb.pitt.edu/tdtCDPK1/rdconf.py</div><div class="line">chmod + x rdconf.py</div></pre></td></tr></table></figure><p>(b)每个active/decoy生成单一构像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rdconf.py --maxconfs 1 decoys.smi decoys.sdf</div><div class="line">rdconf.py --maxconfs 1 actives.smi actives.sdf</div></pre></td></tr></table></figure><p>(c)将文件合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat actives.sdf decoys.sdf &gt; combined.sdf</div></pre></td></tr></table></figure><blockquote><p>由于有两个文件，我们将<em>T.gondii</em>和<em>C.pavum</em>分别命令为gondii.sdf和parvum.sdf</p></blockquote><h2 id="1-3-对接"><a href="#1-3-对接" class="headerlink" title="1.3 对接"></a>1.3 对接</h2><p>我们使用SMINA通过对接化合物进入受体结构进行虚拟筛选,采用AutoDock Vina得分功能。由于我们对一个固定的受体对接，所以我们选择一个好的受体结构是非常重要的。我们将会使用CDPK1的测试集来模拟评价我们的对接工具和选择受体结构。</p><p>1.鉴定PDB中所有<em>C.parvum</em>和<em>T.gondii</em>文件，搜索’calcium-dependent protein kinase 1’,并且选择恰当的生物（organism.）</p><p>  <em>C. parvum</em>: 2QG5 2WEI 3DFA 3F3Z 3HKO 3IGO 3L19 3LIJ 3MWU 3NCG</p><p>  <em>T. gondii</em>: 3I79 3I7B 3I7C 3KU2 3N51 3NYV 3SX9 3SXF 3T3U 3T3V 3UPX 3UPZ 3V51 3V5P 3V5T 4M84</p><blockquote><p>由于教程较老，故和自己搜索有差异</p></blockquote><p>2.下载这些pdb文件,你可以用如下的简单方法，或者直接<a href="/images/2017/smina/SMINA4.tar.gz">下载</a>我下载好的。</p><p>将以下代码保存为脚本，例如<code>down.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash  </span></div><div class="line">  </div><div class="line">str=<span class="string">"2QG5 2WEI 3DFA 3F3Z 3HKO 3IGO 3L19 3LIJ 3MWU 3NCG"</span>  </div><div class="line">arr=(<span class="variable">$&#123;str// / &#125;</span>)  </div><div class="line">  </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span>  </div><div class="line"><span class="keyword">do</span>  </div><div class="line">    wget https://files.rcsb.org/download/<span class="variable">$i</span>.pdb </div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p><p>执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x down.sh</div><div class="line">./down.sh</div></pre></td></tr></table></figure><p>3.比对和提取结构。在pymol中打开靶标pdb文件。比对他们。除去水和原子。提取每个配体到自己的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pymol中执行</span></div><div class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</div><div class="line"><span class="keyword">for</span> fil <span class="keyword">in</span> glob(<span class="string">"*.pdb"</span>): cmd.load(fil)</div><div class="line">alignto</div><div class="line">remove solvent</div><div class="line">remove metal</div><div class="line">remove GOL</div><div class="line"><span class="comment">#选择配体BK1周围5埃外的小分子，并且删除，因为并未在结合位点内，不是配体</span></div><div class="line">select unligand,byres resname BK1 gap <span class="number">5</span> <span class="keyword">and</span> hetatm</div><div class="line">remove unligand</div><div class="line"><span class="comment">#选择配体</span></div><div class="line">select ligand,hetatm</div><div class="line">extract parvum,ligand</div><div class="line"><span class="comment">#保存配体</span></div><div class="line">save parvumlig.pdb,parvum</div><div class="line">remove ligand</div></pre></td></tr></table></figure><p>4.保存受体和配体文件，注意的是<code>3LI9</code>没有酶结构域，<code>3DFA</code>和<code>2QG5</code>为未结合态结构，综合考虑我们将其删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">remove <span class="number">3L</span>I9 <span class="keyword">and</span> <span class="number">3</span>DFA <span class="keyword">and</span> <span class="number">2</span>QG5</div></pre></td></tr></table></figure><p>保存(注意一下需要保存为python文件后<code>run</code>进行操作)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> cmd.get_names():cmd.save(name + <span class="string">".pdb"</span> , name )</div></pre></td></tr></table></figure><p>5.将配体导入进单一文件，由于我们之前做了，该步骤无需做</p><p>6.对接测试集化合物到每个受体结构，例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smina --seed 0 --autobox_ligand parvumlig.pdb -r 2WEI.pdb \</div><div class="line">-l combined.sdf -o 2WEI_docked.sdf.gz</div></pre></td></tr></table></figure><p>在这里我们制定了一个随机种子。结合盒子采用<code>autobox_ligand</code>设置，创建的盒子大小为对于提供的配体8埃缓冲。配体，受体和输出文件可以使用任意OpenBabel支持的格式。</p><p>7.获取每个化合物<a href="/images/2017/smina/2WEI_docked.txt">输出</a>得分最高的对接姿势。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sdsorter -sort minimizedAffinity -reduceconfs 1 2WEI_docked.sdf.gz \</div><div class="line">-<span class="built_in">print</span> -c &gt; 2WEI_docked.txt</div></pre></td></tr></table></figure><p>8.分析对接结果，原文是使用的R进行的分析，大家可以以下做参考，当然也可以依葫芦画瓢使用Python进行处理。</p><p>(a)R版本方法如下:</p><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"pROC"</span>)</div><div class="line"><span class="keyword">library</span>(<span class="string">"pROC"</span>)</div><div class="line"></div><div class="line">rarr=list()</div><div class="line"><span class="keyword">for</span> (file <span class="keyword">in</span> Sys.glob(<span class="string">"*docked.txt"</span>)) &#123;</div><div class="line"> d = read.table(file,header=<span class="literal">T</span>)</div><div class="line"> r = roc(grepl(<span class="string">"active"</span>,d $Title) , d$minimizedAffinity,direction=<span class="string">"&gt;"</span>)</div><div class="line"> rarr[[length(rarr)+<span class="number">1</span>]]=r</div><div class="line">&#125;</div><div class="line">names(rarr) = Sys.glob(<span class="string">"*docked.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> (n <span class="keyword">in</span> names(rarr)) &#123;</div><div class="line"> r = rarr[[n]]</div><div class="line"> a = auc(r,partial.auc=c(<span class="number">1</span>,<span class="number">.9</span>),partial.auc.correct= <span class="literal">T</span> )</div><div class="line"> s = sprintf(<span class="string">"%s %.4 f%.4f\n"</span> , sub(<span class="string">"_docked.txt"</span> ,<span class="string">""</span>,n),r$auc[<span class="number">1</span>],a[<span class="number">1</span>])</div><div class="line"> cat(s)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>图大致如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/smina/SMINA6.png" alt="图6" title="">                </div>                <div class="image-caption">图6</div>            </figure><p>   AUC和Partial AUC的值分别为<code>0.8520</code>,<code>0.6485</code>。此数据运用的为官方数据，python版本为我自己写的方法，供参考</p><p>(b) ython版本如下:</p><p>首先我们使用<code>awk</code>处理一下原始文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'BEGIN&#123;FS='</span>_<span class="string">';OFS='</span>\t<span class="string">'&#125;&#123;print $1,$2&#125;'</span> 2WEI_docked.txt rocdata.txt</div><div class="line"><span class="comment">#打开文件，在Title后加type项</span></div></pre></td></tr></table></figure><p>得到的文件可以从这里<a href="/images/2017/smina/rocdata.txt">下载</a>，python脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"><span class="comment">#python=3.x</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, roc_auc_score</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># 读取数据</span></div><div class="line">df=pd.read_csv(<span class="string">'rocdata.txt'</span>,sep=<span class="string">'\t'</span>)</div><div class="line"></div><div class="line">df.loc[<span class="keyword">lambda</span> df: df.type==<span class="string">'active'</span>,[<span class="string">'type'</span>]]=<span class="string">'1'</span></div><div class="line">df.loc[<span class="keyword">lambda</span> df: df.type==<span class="string">'unactive'</span>,[<span class="string">'type'</span>]]=<span class="string">'0'</span></div><div class="line">df[<span class="string">'minimizedAffinity'</span>]=df[<span class="string">'minimizedAffinity'</span>]/<span class="number">-10.76520</span></div><div class="line">y=df[<span class="string">'type'</span>].astype(<span class="string">'int64'</span>)</div><div class="line">scores=df[<span class="string">'minimizedAffinity'</span>]</div><div class="line"></div><div class="line"><span class="comment"># ROC</span></div><div class="line">fpr,tpr,thresholds=roc_curve(y,scores,pos_label=<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">#auc值</span></div><div class="line">auc=roc_auc_score(df[<span class="string">'type'</span>].astype(<span class="string">'int64'</span>),scores)</div><div class="line"></div><div class="line"><span class="comment">#绘图</span></div><div class="line">plt.figure()</div><div class="line">plt.plot(fpr,tpr,color=<span class="string">'darkorange'</span>,lw=<span class="number">2</span>,label=<span class="string">'pavum ROC curve,auc %0.2f'</span> % auc)</div><div class="line">plt.xlim([<span class="number">0.0</span>,<span class="number">1.0</span>])</div><div class="line">plt.ylim([<span class="number">0.0</span>,<span class="number">1.05</span>])</div><div class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],color=<span class="string">'navy'</span>,lw=<span class="number">2</span>,linestyle=<span class="string">'--'</span>)</div><div class="line">plt.xlabel(<span class="string">'False Positive Rate'</span>)</div><div class="line">plt.ylabel(<span class="string">'True Positive Rate'</span>)</div><div class="line">plt.title(<span class="string">'2WEI ROC curve'</span>)</div><div class="line">plt.legend(loc=<span class="string">"lower right"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/smina/SMINA9.png" alt="图9" title="">                </div>                <div class="image-caption">图9</div>            </figure><h1 id="2-E-tenella-CDPK1-模型和-测试集预测"><a href="#2-E-tenella-CDPK1-模型和-测试集预测" class="headerlink" title="2. E.tenella CDPK1 模型和 测试集预测"></a>2. <em>E.tenella</em> CDPK1 模型和 测试集预测</h1><p>现在我们创建一个<em>E.tenella</em>模型来进行虚拟筛选和发展基于先前得分结果的用户自定义的得分功能。</p><h2 id="2-1-建模"><a href="#2-1-建模" class="headerlink" title="2.1 建模"></a>2.1 建模</h2><p>基于之前章节的对接结果，<em>T.gondii</em>在全局和结合位点的序列中是更加接近<em>E.tenella</em>的.3T3U是<em>T.gondii</em>最优得分性能的一个结构（AUC和早期经验性AUC评价），因此我们使用SWISS-Model构建swissmodel3T3U.pdb</p><h2 id="2-2-对接测试集"><a href="#2-2-对接测试集" class="headerlink" title="2.2 对接测试集"></a>2.2 对接测试集</h2><p>这里有提供<a href="/images/2017/smina/cdpk1_externaltestset.txt">22个化合物</a>和<a href="/images/2017/smina/tdt2014.xlsx">详细实验数据</a>作为模型的测试集</p><p>1.转化为SMILES格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">' NR&gt;1&#123;print $2, $1&#125; '</span> tdt2-challenge3-cdpk1_externaltestset.txt \</div><div class="line">&gt; testset.smi</div></pre></td></tr></table></figure><p>2.生成构像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdconf.py --maxconfs 1 testset.smi testset.sdf</div></pre></td></tr></table></figure><p>3.对接测试集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smina --autobox_ligand allligs.pdb -r swissmodel3T3U.pdb  \</div><div class="line">   -l ../testset.sdf -o testset_docked.sdf --seed 0</div></pre></td></tr></table></figure><p>4.选择和排序得分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sdsorter -sort minimizedAffinity testset_docked.sdf -reduceconfs 1 \</div><div class="line">testset_docked_best.sdf -<span class="built_in">print</span> -c &gt; testset_default_ranking.txt</div></pre></td></tr></table></figure><p>最佳得分构像如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2017/smina/SMINA8.png" alt="图7" title="">                </div>                <div class="image-caption">图7</div>            </figure><h2 id="2-3-用户自定义得分"><a href="#2-3-用户自定义得分" class="headerlink" title="2.3 用户自定义得分"></a>2.3 用户自定义得分</h2><p>我们发展了用户自定义得分功能用以<em>T.gondii</em>测试集参数化。增加到默认的得分功能上。</p><p>1.删除atom-types项目（如果考虑所有可能的原子类型组合，这将是一个非常大的项目），同样包括默认的第二Gaussian项目，他同样存在于默认得分之中。所有的权重均设为1.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">smina --print_terms | \</div><div class="line">  grep -v -E <span class="string">'atom_type|constant|num_|ligand_length'</span> &gt; allterms </div><div class="line"><span class="built_in">echo</span> <span class="string">"gauss(o=3,_w=2,_c=8)"</span> &gt;&gt; allterms </div><div class="line">sed -i <span class="string">'s/^/1.0 /'</span> allterms</div></pre></td></tr></table></figure><blockquote><p><code>grep -v -E</code>的用法比较少，<code>-v</code>表示不包含匹配文本的所有行，<code>-E</code>为启用正则表达式</p></blockquote><p>2.得分最高的构像3T3U测试集拿来进行比较,由于我这里只做了2WEI，所以实际上此步我用的2WEI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 提取最高得分构像</span></div><div class="line">sdsorter -sort minimizedAffinity -reduceconfs 1 \</div><div class="line">    3T3U_docked.sdf.gz 3T3U_docked_single.sdf.gz</div><div class="line"><span class="comment"># 重新打分，不用再继续跑</span></div><div class="line">smina --custom_soring allterms --score_only </div><div class="line">    -l 3T3U_docked_single.sdf.gz -r 3T3U.pdb | \</div><div class="line">    grep <span class="string">"##"</span> | sed <span class="string">"s/##//"</span> | \</div><div class="line">    awk <span class="string">'&#123;print $1 ~ /_active/, $0&#125;'</span> &gt; allscores</div></pre></td></tr></table></figure><blockquote><p>原文档中最后一行为/active/，但是个人觉得并没有达到区分active和unactive的用途，故本人对其进行了修改。可以从此<a href="/images/2017/smina/allscores">下载文件</a>。</p></blockquote><p>3.作者使用R中的<code>rms</code>包和<strong>logistical</strong>回归来进行后向变量选择来契合活性数据的得分。为了防止过拟合，只选择p-值较低的功能（&lt;.0001）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"rms"</span>)</div><div class="line"><span class="keyword">library</span>(rms)</div><div class="line">scores=read.table(<span class="string">"allscores"</span>,header=<span class="literal">T</span>)[c(-<span class="number">2</span>)]   <span class="comment">#remove Name  colum</span></div><div class="line">colnames(scores)[<span class="number">1</span>]=<span class="string">"activity"</span></div><div class="line">formula=reformulate(name(scores)[c(-<span class="number">1</span>)],respinse=<span class="string">"activity"</span>)</div><div class="line">fit=lrm(formula,data=scores,x=<span class="literal">T</span>,y=<span class="literal">T</span>)</div><div class="line">fit2=fastbw(fit,rule=<span class="string">"p"</span>,sls=<span class="number">0.0001</span>)</div><div class="line"><span class="keyword">for</span>(n <span class="keyword">in</span> names(fit2$coefficients))&#123;</div><div class="line">  cat(sprintf(<span class="string">"%f %s\n"</span>,fit2$coefficients[[n]],n))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.保存测定的系数coefficients以创建新的评分函数。因为项目名称中包含特征符，其在R中是无效命名，所以需要编辑输入以重新储存适当的terms，得分函数的结果如图下:</p><p>   <img src="/images/2017/smina/SMINA10.png" alt="图10"></p><p>5.通过将系数乘以每一项的平均值来创建该评分函数中每个项的贡献的平均估计</p><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">aves=apply(scores[name(coef(fit2))[-<span class="number">1</span>]],<span class="number">2</span>,mean)*coef(fit2)[-<span class="number">1</span>]</div><div class="line"><span class="keyword">for</span>(n <span class="keyword">in</span> names(aves))&#123;</div><div class="line">  cat(sprintf(<span class="string">"%f %s\n"</span>,aves[[n]],n))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>   结果如下图</p><p>   <img src="/images/2017/smina/SMINA11.png" alt="图11"></p><p>   疏水性，VDW，氢键和溶剂化为有利相互作用，非疏水性，排斥性和受体-受体为负相关作用。VDW和gauss具有非常强的权重，线性氢键和Lennard Jones氢键展示了一些权重。</p><p>4*.Python包实现，Python的scikit-learn中对于logistical并没有P-值，译者对与R也不是特别理解，不知道能否领会作者的含义，以下仅供参考。 我们采用scikit-learn包中的logistical回归，同时将数据为训练集（75%）与测试集，检测是否过拟合，若没有测试集效果也不错，就使用所有的作为训练集再次训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"></div><div class="line"><span class="comment"># 首先将文件的两个空格，替换为一个空格，或者sep 写成`空格+`</span></div><div class="line">df=pd.read_table(<span class="string">'allscores'</span>,sep=<span class="string">' '</span>)</div><div class="line"></div><div class="line"><span class="comment"># 采用的为分层采样，以避免训练集和测试集不均匀的现象</span></div><div class="line">X_train,X_test,y_train,y_test=train_test_split(df.iloc[:,<span class="number">2</span>:],df[<span class="string">'type'</span>],test_size=<span class="number">0.15</span>,stratify=df[<span class="string">'type'</span>])</div><div class="line"></div><div class="line"><span class="comment"># sklearn是机器学习库，而非统计库，所以去掉不相关的feature的话可以使用l1 regularization，默认的阈值为0.0001，相同</span></div><div class="line">regr=linear_model.LogisticRegression(penalty=<span class="string">'l1'</span>)</div><div class="line">regr.fit(X_train,y_train)</div><div class="line"></div><div class="line">print(<span class="string">'Coefficients:%s,intercept %s'</span>%(regr.coef_,regr.intercept_))</div><div class="line">print(<span class="string">'Score: %.2f'</span> % regr.score(X_test,y_test))</div></pre></td></tr></table></figure><p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Coefficients:[[-0.03864204  0.40028821 -0.00676393 -0.09159704 -0.0345586  -0.10145013</div><div class="line">   2.79993056  0.38033068  0.          0.         -0.00837466  0.</div><div class="line">   0.04403177]],intercept [-3.04932666]</div><div class="line">Score: 0.82</div></pre></td></tr></table></figure></p><p>译者计算出来和原作者计算出来有差异，主要就是hydrophobic和non_hydrophobic项两者的权重都为负数,项和值上也有差异。接下来我们乘上平均值得到最终权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.iloc[:,<span class="number">2</span>:].mean()*regr.coef_[<span class="number">0</span>]</div></pre></td></tr></table></figure><p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gauss(o=0,_w=0.5,_c=8)                          -2.447950</div><div class="line">repulsion(o=0,_c=8)                              0.602891</div><div class="line">hydrophobic(g=0.5,_b=1.5,_c=8)                  -0.331807</div><div class="line">non_hydrophobic(g=0.5,_b=1.5,_c=8)              -5.150272</div><div class="line">vdw(i=6,_j=12,_s=1,_^=100,_c=8)                 20.386651</div><div class="line">non_dir_h_bond_lj(o=-0.7,_^=100,_c=8)            1.535267</div><div class="line">non_dir_anti_h_bond_quadratic(o=0,_c=8)          0.205500</div><div class="line">non_dir_h_bond(g=-0.7,_b=0,_c=8)                 0.000000</div><div class="line">acceptor_acceptor_quadratic(o=0,_c=8)            0.000000</div><div class="line">donor_donor_quadratic(o=0,_c=8)                  0.000000</div><div class="line">gauss(o=3,_w=2,_c=8)                           -13.474894</div><div class="line">electrostatic(i=2,_^=100,_c=8)                   0.000000</div><div class="line">ad4_solvation(d-sigma=3.6,_s/q=0.01097,_c=8)     0.797093</div></pre></td></tr></table></figure></p><p>6.评价这个新的得分函数，使用这个新的得分函数fitscore（<strong>个人觉得是第一次得出的权重进行的计算，因为我用第二次的权重进行计算数值很大，此处待考</strong>）除了重新打分最高的对接姿势以外，我们重新打分和重新排序所有的对接姿势。值得注意的是这个得分函数是预测的活性而不是亲和力。越大的positive值表示的是复合物可能具有活性的概率更大，所以复合物在选择最佳构像排序的时候需要逆转数字顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">smina --score_only -r 3T3U.pdb -l 3T3U_docked_single.sdf.gz \</div><div class="line">        --custom_scoring fitscore -o 3T3U_docked_single_rescore.sdf.gz</div><div class="line"></div><div class="line">sdsorter  -<span class="built_in">print</span> -c 3T3U_docked_single_rescore.sdf.gz &gt; 3T3U_docked_single_rescore.txt</div><div class="line"></div><div class="line">smina --score_only -r 3T3U.pdb -l 3T3U_docked.sdf.gz \</div><div class="line">         --custom_scoring fitscore -o 3T3U_dcoked_rescore.sdf.gz</div><div class="line"></div><div class="line">sdsorter -reversesort minimizedAffinity -reduceconfs 1 -<span class="built_in">print</span> -c \</div><div class="line">          3T3U_docked_rescore.sdf.gz &gt;3T3U_docked_rescore.txt</div></pre></td></tr></table></figure><blockquote><p>译者在做的时候对第6条不是很理解</p></blockquote><p>7.使用新的得分函数对接<code>E.tenella</code>化合物集:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">smina --custom_scoring fitscore --score_only -l testset_docked.sdf \</div><div class="line">         -r swissmodel3T3U.pdb -o testset_rescored.sdf</div><div class="line">sdsorter -<span class="built_in">print</span> -c testset_rescored.sdf -reversesort minimizedAffinity \</div><div class="line">           -reduceconfs 1 testset_rescored_best.sdf \</div><div class="line">           &gt; testset_custom_ranking.txt</div></pre></td></tr></table></figure><p>   应该使用在这个测试集上表现更好的评分函数来进行完整的虚拟筛选选择化合物，结果可以从此<a href="images/SMINA5.tar.gz">下载</a></p><blockquote><p>译者认为自定义得分并未达到非常好的效果，可以进一步优化</p></blockquote><h1 id="3-虚拟筛选"><a href="#3-虚拟筛选" class="headerlink" title="3.虚拟筛选"></a>3.虚拟筛选</h1><p>  已经阐明精心设计的自定义得分可以很好的应用在<em>E.tenella</em>结构模型，我们进行筛选eMolecules化合物库。需要注意的是我们的自定义得分函数并不使用于对接，而是参数化预测已经对接好的姿势的活性。</p><p>1.下载eMolecules数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://downloads.emolecules.com/ordersc/2017-11-01/parent.smi.gz</div><div class="line">gunzip parent.smi.gz</div></pre></td></tr></table></figure><p>2.根据环境切割不同大小。例如，10000每块进行切割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">split -n 1/10000 parent.smi -d -a 4 split_</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> split*; <span class="keyword">do</span> mv <span class="variable">$i</span> <span class="variable">$&#123;i&#125;</span>.smi; <span class="keyword">done</span></div></pre></td></tr></table></figure><p>3.生成构像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdconf.py --maxconfs 1 split_0000.smi split_0000.sdf.gz</div></pre></td></tr></table></figure><p>4.对接每个块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smina --autobox_ligand allligs.pdb -r swissmodel3T3U.pdb \</div><div class="line">          -l split_0000.sdf.gz -o docked_0000.sdf.gz --seed 0</div></pre></td></tr></table></figure><p>5.对获得的最高排名姿势使用默认的得分和自定义得分进行评价</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sdsorter -sort minimizedAffinity -reduceconfs 1 -nbest 100 \</div><div class="line">        docked_0000.sdf.gz best_default_0000.sdf.gz</div><div class="line">smina --custom_scoring fitscore --score_only -l docked_0000.sdf.gz \</div><div class="line">        -r swissmodel3T3U.pdb -o rescored_0000.sdf.gz</div></pre></td></tr></table></figure><p>6.将对接姿势放入一个文件并排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">zcat bets_default_*.sdf.gz | gzip &gt; best_default.sdf.gz</div><div class="line">zcat best_custom_*.sdf.gz | gzip &gt; best_custom.sdf.gz</div><div class="line">sdsorter -sort- minimizedAffinity best_default.sdf.gz \</div><div class="line">        -nbest 1000 top1000_default.sdf.gz -<span class="built_in">print</span> -c \ </div><div class="line">         &gt; top1000_default.txt</div><div class="line">sdsorter -reversesort minimizedAffinity best_custom.sdf.gz \</div><div class="line">        -nbest 1000 top1000_custom.sdf.gz -<span class="built_in">print</span> -c \</div><div class="line">        &gt; top1000_custom.txt</div></pre></td></tr></table></figure><p>参考文献:<br>Ojo KK, Larson ET, Keyloun KR, Castaneda LJ, Derocher AE, Inampudi KK, Kim JE, Arakaki TL, Murphy RC, Zhang L, Napuli AJ, Maly DJ, Verlinde CL, Buckner FS, Parsons M, Hol WG, Merritt EA, Van Voorhis WC. (2010) Toxoplasma gondii calcium-dependent protein kinase 1 is a target for selective kinase inhibitors. Nat Struct Mol Biol. 17:602-7. PMID: 20436472 PMCID: PMC2896873</p><p>Murphy RC, Ojo KK, Larson ET, Castellanos-Gonzalez A, Perera BG, Keyloun KR, Kim JE, Bhandari JG, Muller NR, Verlinde CL, White AC, Merritt EA, Van Voorhis WC, Maly DJ. (2010) Discovery of Potent and Selective Inhibitors of Calcium-Dependent Protein Kinase 1 (CDPK1) from C. parvum and T. gondii. (2010) ACS Med Chem Lett. 1(7):331-335. PMID: 21116453 PMCID: PMC2992447</p><p>Johnson SM, Murphy RC, Geiger JA, Derocher A, Zhang Z, Ojo K, Larson E, Perera BG, Dale E, He P, Fox A, Mueller N, Merritt EA, Fan E, Reid M, Parsons M, Van Voorhis WC, Maly DJ. (2012) Development of Toxoplasma gondii Calcium-Dependent Protein Kinase 1 (TgCDPK1) Inhibitors with Potent Anti-Toxoplasma Activity. J Med Chem. 55(5):2416-26. PMID: 22320388 PMCID: PMC3306180</p><p>Larson ET, Ojo KK, Murphy RC, Johnson SM, Zhang Z, Kim JE, Leibly DJ, Fox AM, Reid MC, Dale EJ, Perera BG, Kim J, Hewitt SN, Hol WG, Verlinde CL, Fan E, Van Voorhis WC, Maly DJ, Merritt EA. (2012) Multiple Determinants for Selective Inhibition of Apicomplexan Calcium-Dependent Protein Kinase CDPK1. J Med Chem. 55(6):2803-10. PMID: 22369268 PMCID: PMC3336864</p><p>Ojo KK, Pfander C, Mueller NR, Burstroem C, Larson ET, Bryan CM, Fox AMW, Reid MC, Johnson SM, Murphy RC, Kennedy M, Henning Mann H, Leibly DJ, Hewitt SN, Verlinde CLMJ. Kappe S, Merritt EA, Maly DJ, Billker O, Van Voorhis WC. (2012) Transmission of malaria to mosquitoes blocked by bumped kinase inhibitors.  J. Clin. Invest. 122(6):2301–2305. doi: 10.1172/JCI61822  PMID:22565309 PMCID: PMC3366411</p><p>Zhang Z, Ojo KK, Johnson SM, Larson ET, He P, Geiger JA, Castellanos-Gonzalez A, White AC Jr, Parsons M, Merritt EA, Maly DJ, Verlinde CL, Van Voorhis WC, Fan E. (2012) Benzoylbenzimidazole-based selective inhibitors targeting Cryptosporidium parvum and Toxoplasma gondii calcium-dependent protein kinase-1. Bioorg Med Chem Lett. 22:5264-7. PMID: 22795629 PMCID: PMC3420979</p><p>Castellanos-Gonzalez A, A. White AC Jr, Ojo KK, Vidadala R, Zhang Z, Reid MC, Fox AMW, Keyloun KR, Rivas K, Irani A, Dann SM, Fan E, Maly DJ,  Wesley C Van Voorhis. (2013). A novel Calcium Dependent Protein Kinase Inhibitor as a lead compound for treating Cryptosporidiosis. J Infect. Dis. PMID: 23878324  2013 Jul 21. [Epub ahead of print]</p><p>Ojo KK, Eastman RT, Vidadala R, Zhang Z, Rivas KL, Choi R, Lutz JD, Reid MC, Fox AMW, Hulverson MA, Kennedy M, Isoherranen N, Kim LM, Comess KM, Kempf DJ, Verlinde CLMJ, Su X-Z, Kappe S, Maly DJ, Fan E, &amp; Van Voorhis WC. (2013) Specific inhibitor of PfCDPK4 blocks malaria transmission: Chemical-genetic validation. J Infect Dis. 2013 Oct 10. [Epub ahead of print] PMID: 24123773</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SMINA教程以CDPK1为例&lt;/p&gt;
&lt;p&gt;原作者:David Ryan Koes&lt;br&gt;翻译:康文渊&lt;/p&gt;
&lt;p&gt;若进行精读建议查看原文以及参考文献，本文是我根据教程快速阅读做的笔记&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1:我们有autodock vina，为什
      
    
    </summary>
    
      <category term="分子对接" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E5%AF%B9%E6%8E%A5/"/>
    
    
      <category term="dock" scheme="http://kangsgo.com/tags/dock/"/>
    
  </entry>
  
</feed>
