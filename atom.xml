<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小康学习</title>
  
  <subtitle>计算化学与分子模拟爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kangsgo.com/"/>
  <updated>2018-06-01T08:01:40.541Z</updated>
  <id>http://kangsgo.com/</id>
  
  <author>
    <name>kangsgo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站域名修改为cn后缀</title>
    <link href="http://kangsgo.com/48.html"/>
    <id>http://kangsgo.com/48.html</id>
    <published>9999-12-05T09:09:30.000Z</published>
    <updated>2018-06-01T08:01:40.541Z</updated>
    
    <content type="html"><![CDATA[<p>因为网站<a href="https://kangsgo.cn" target="_blank" rel="external">kangsgo.cn</a>进行了备案，以后请访问这个域名，谢谢啦^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为网站&lt;a href=&quot;https://kangsgo.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kangsgo.cn&lt;/a&gt;进行了备案，以后请访问这个域名，谢谢啦^_^&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="http://kangsgo.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>分子模拟网站推荐</title>
    <link href="http://kangsgo.com/2.html"/>
    <id>http://kangsgo.com/2.html</id>
    <published>9999-11-27T18:37:22.000Z</published>
    <updated>9999-11-12T12:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：待编辑</p><h3 id="1-内容性推荐"><a href="#1-内容性推荐" class="headerlink" title="1.内容性推荐"></a><span style="color: #3366ff;">1.内容性推荐</span></h3><h4 id="综合性网站推荐："><a href="#综合性网站推荐：" class="headerlink" title="综合性网站推荐："></a>综合性网站推荐：</h4><p><a href="http://emuch.net/bbs/forumdisplay.php?fid=322" target="_blank" rel="external">小木虫论坛</a>：一个综合性的论坛，项目非常杂，但是里面有非常多的资料分享。感觉对于交流和求知比较欠缺 。</p><p><a href="http://www.bioms.org" target="_blank" rel="external">bioms分子模拟论坛</a>：是一个专业性质的论坛，主要集中讨论计算机辅助药物设计这一快，氛围非常好，但是最近活跃度有所下降。</p><p><a href="http://jerkwin.github.io/" target="_blank" rel="external">哲科文</a>：李继存老师的个人博客，主要是gromacs的一些中文教程，老师人也非常好</p><p><a href="http://platinhom.github.io/" target="_blank" rel="external">勤力既懒猪</a>：一些模拟方面的教程</p><p><a href="http://bbs.keinsci.com/forum.php" target="_blank" rel="external">计算化学公社</a>：有论坛和门户网站，具体没有发掘~主要是看到了VMD的教程</p><p><a href="http://sobereva.com/54" target="_blank" rel="external">思想家公社的门口</a>：博客</p><p><a href="http://spaces.ac.cn/" target="_blank" rel="external">科学空间</a>: 并不是一个严格的分子模拟网站，更多的是算法相关的资源分享，还是非常推荐查看的</p><p><a href="http://blog.sina.com.cn/aj426q" target="_blank" rel="external">吴钩白的博客</a>: 我最崇拜的学长之一，知识渊博，喜欢亲切的叫他一声老师</p><p><a href="http://howiedlut.top/" target="_blank" rel="external">Howie</a>：永远相信美好的事情终将发生</p><p><a href="http://blog.csdn.net/u012325865?viewmode=contents" target="_blank" rel="external">AspirinCode</a> 和 <a href="http://www.aspirincode.com/" target="_blank" rel="external">Hexo版本</a>:  建民兄的博客，其对药物设计有非常独特的见解</p><p><a href="https://liuyujie714.github.io/" target="_blank" rel="external">Liu Yujie</a> 杰哥的博客，对gromacs有非常深的见解！</p><p><a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=950202" target="_blank" rel="external">陈照强的博客</a> 强哥的博客，CADD大牛，对Python见解深刻</p><h4 id="QQ群："><a href="#QQ群：" class="headerlink" title="QQ群："></a>QQ群：</h4><p>BioMS分子模拟-药物设计 <span style="color: #ff6600;">68093966  </span> 【十分活跃】</p><p>药物研发科学计算 <span style="color: #ff6600;">205448601</span></p><p>GROMACS中文组 <span style="color: #ff6600;">132266540    </span>【专一性强，很热心】</p><p>「药设之道」医药R&amp;D <span style="color: #ff6600;">426442973</span></p><p>分子模拟技术交流 <span style="color: #ff6600;">397981984     <span style="color: #000000;">【田老师组织的群，很活跃】</span></span></p><p>计算生命科学  <span style="color: #ff6600;">496548248</span></p><h4 id="微信公众号："><a href="#微信公众号：" class="headerlink" title="微信公众号："></a>微信公众号：</h4><p><span style="color: #ff6600;">生物研究生</span> 分子模拟牛人小9创立的一个分享分子模拟方面内容的微信公众号</p><p><span style="color: #ff6600;">分子模拟之道</span> 李老师创办的生物模拟资讯公众号，内容不多但是篇篇精华</p><p><span style="color: #ff6600;">王初课题组</span> 好文章的推荐公众号</p><p><span style="color: #ff6600;">生信杂谈</span> 分子模拟与生物信息杂交体</p><p><span style="color: #ff6600;">克里科学苑</span>  致力于组织生命科学及医学领域科研及应用培训的专业机构</p><p><span style="color: #ff6600;">药设之道</span>  致力于向大众和专业工作者传播药物设计新方法的公众号</p><h3 id="2-软件推荐与教程"><a href="#2-软件推荐与教程" class="headerlink" title="2.软件推荐与教程"></a><span style="color: #3366ff;">2.软件推荐与教程</span></h3><p>1.序列比对</p><p>ClustaX ：  没有做过多深入了解</p><p>2.蛋白建模</p><p>2.1同源建模</p><p><a href="https://salilab.org/modeller/" target="_blank" rel="external">Modeller</a>：同源建模经典网站</p><p>Easymodeller：Modeller的可视化界面，深入学习的话不建议学</p><p><a href="http://www.swissmodel.expasy.org/" target="_blank" rel="external">Swiss-model</a>：在线建模网站，质量不错，可操控性高</p><p><a href="http://seoklab.github.io/GalaxyFill/" target="_blank" rel="external">GalaxyFill</a>: 补充收尾缺失结构，可以用来制作融合蛋白</p><p>2.2从头建模</p><p><a href="http://zhanglab.ccmb.med.umich.edu/" target="_blank" rel="external">I-TASSER</a>：Zhang实验室制作的一个从头建模在线服务器</p><p>Rostta：综合性软件，学术免费</p><p>2.3模型评价</p><p><a href="http://services.mbi.ucla.edu/SAVES/" target="_blank" rel="external">SAVES</a>：包含XdVal | MTZdump | Ramachandran Plot | pdbU | pdbSNAFU  | PROCHECK | Verify3D | ERRAT 多种评价，其中常用Ramachandran Plot和ERRAT2</p><p>2.4 结构准备</p><p><a href="http://openbabel.org/" target="_blank" rel="external">OpenBabel</a>：一个格式转换工具，具有本地编译包和多种语言的API</p><p><a href="http://kinemage.biochem.duke.edu/software/reduce.php" target="_blank" rel="external">Reduce</a>： 一个加氢删氢的命令行工具，仅支持PDB格式</p><p>3.分子对接</p><p><a href="http://dock.compbio.ucsf.edu/DOCK_6/index.htm" target="_blank" rel="external">DOCK</a>: UCSF DOCK,现在是第6版，同样具有柔性对接和刚性对接，对接的结果评价中等，学术免费，需要搭配Chimera使用。平台：linux</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">AutoDock</a>：最为经典的对接软件，有一款HIV药物据说就是它的功劳，使用广泛，但是速度和准确度很低，据飞天说能量打分尚可。平台：linux/windows</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">AutoDock Vina</a>： 与AutoDock为同一实验室不同课题组产物，速度和准确度都有较大的提高，算是免费里面做的最好之一了。平台：linux/windows</p><p><a href="http://gemdock.life.nctu.edu.tw/dock/igemdock.php" target="_blank" rel="external">Igemdock</a>：台湾设计的一款对接软件，选择活性区域位点比较麻烦，但是准确度高（据华中师大-精灵测试）。平台：linux/windows</p><p>LibDock： 对接速度快，Discover Studio集成，不是一般人买得起。平台：linux/windows</p><p>CDOCK：相对于LibDock更为精确。平台：linux/windows</p><p>LigandFit： 柔性对接，同上，这三款都是DS集成的对接。平台：linux/windows</p><p><a href="http://pc1664.pharmazie.uni-marburg.de/drugscore/" target="_blank" rel="external">DrugScoreX</a>： DrugScoreX是一个较新的，对于蛋白配体打分具有比DrugScore更高精度的软件，其打分功能是基于统计势能？(statistical potentials)</p><p><a href="http://kangsgo.com/665.html">LigScore</a>： 与DrugScore的算法类似,提供本地(IMP 工具包)以及在线服务。</p><p><a href="http://poseview.zbh.uni-hamburg.de/" target="_blank" rel="external">PoseViewWeb</a> : 在线的对接2D相互关系图形显示工具</p><p>4.分子模拟/分子动力学 MD</p><p><a href="http://www.gromacs.org/" target="_blank" rel="external">gromacs</a>: 一个开源的分子动力学模拟软件</p><p><a href="http://ambermd.org/" target="_blank" rel="external">Amber</a>: 一个以生物为主导的分子动力学模拟软件，GPU加速模块收费</p><p><a href="http://openmm.org/" target="_blank" rel="external">OpenMM</a>： 一个开源的分子动力学模拟软件，发展很好，但是社区和一类模拟软件还是有差距</p><p><a href="http://openmd.org/" target="_blank" rel="external">OpenMD</a>: 小型模拟软件</p><p><a href="http://www.cgmartini.nl/index.php" target="_blank" rel="external">Martini</a>: 最为流行的粗粒化力场</p><p><a href="http://kangsgo.com/681.html">LigParGen: </a>配体OPLS/CM1A力场在线生成</p><p>4.1 体积检测：</p><p><a href="http://kangsgo.com/306.html">Epock</a>   Epock是一个可以动态计算结合腔大小的一个软件，由于有VMD的可视化软件，所以非常的容易上手，简单~</p><p><a href="http://kangsgo.com/443.html"> fpocket2</a>  具有在线服务器的体积检测软件，在线服务:<a href="http://bioserv.rpbs.univ-paris-diderot.fr/services/fpocket/" target="_blank" rel="external">点我进去</a></p><p>4.2 综合轨迹分析工具</p><p><a href="http://mdtraj.org/1.9.0/" target="_blank" rel="external">MDTraj</a>  可以进行轨迹转化，氢键分析等较为底层的工具包，但是非常好用</p><p><a href="http://www.mdanalysis.org/" target="_blank" rel="external">MDAnalysis</a>  完全用Python编写的分析工具包</p><p><a href="http://www.plumed.org/" target="_blank" rel="external">PLUMED</a>  一个非常有名的分子模拟分析工具，暂时没有看</p><p>5.药效团构建</p><p>6.毒理测试</p><p>7.可视化软件</p><p><a href="http://openastexviewer.net/web/" target="_blank" rel="external">AstexViewer3.0</a>  是一个基于java的轻量级软件，虽然功能简单，但是五脏俱全，特别是可以进行电子密度图查看，相对于pymol和vmd比较容易上手，其一些软件的设置方式与pymol和vmd类似，适合新学者或者编写脚本批量分析。</p><p><a href="http://www.pymol.org/" target="_blank" rel="external">Pymol </a> 一个跨平台的可视化开源软件，后因被薛定谔公司收购，有一部分发展为闭源更新</p><p><a href="http://www.ks.uiuc.edu/Research/vmd/" target="_blank" rel="external">VMD </a> 一个以命令行为主的开源可视化软件，个人感觉发展势头优于pymol，且可以和gromacs较好的连用，NAMD，amber的集成性也较好</p><p><a href="http://www.cgl.ucsf.edu/chimera/" target="_blank" rel="external">Chimera</a>  UCSF chimera 功能强大，可以与dock连用</p><p><a href="https://www.cgl.ucsf.edu/chimerax/" target="_blank" rel="external">ChimeraX</a> 下一代可视化软件，作图美丽但是功能暂时比较少</p><p><a href="http://autodock.scripps.edu/" target="_blank" rel="external">PMV</a> Autodock/Autodock搭配的可视化软件，使用的人较少，一般都是用autodock搭配着使用的</p><p>8.开发库</p><p><a href="http://biopython.org/wiki/Main_Page" target="_blank" rel="external">Biopython</a>：一个Python工具包，中文文档可以<a href="http://biopython-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">点此</a>查看</p><p><a href="http://scikit-bio.org/" target="_blank" rel="external">scikit-bio</a>: 一个提供多种生物科学功能，数据结构和算法的Python包</p><p>9.综合性软件</p><p>最后更新:2017/12/09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：待编辑&lt;/p&gt;
&lt;h3 id=&quot;1-内容性推荐&quot;&gt;&lt;a href=&quot;#1-内容性推荐&quot; class=&quot;headerlink&quot; title=&quot;1.内容性推荐&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color: #3366ff;&quot;&gt;1.内容性推荐&lt;/span&gt;&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="推荐" scheme="http://kangsgo.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>系列笔记整理</title>
    <link href="http://kangsgo.com/87.html"/>
    <id>http://kangsgo.com/87.html</id>
    <published>9999-10-03T18:32:44.000Z</published>
    <updated>2018-04-25T11:42:47.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Gromacs笔记整理"><a href="#1-Gromacs笔记整理" class="headerlink" title="1.Gromacs笔记整理"></a>1.Gromacs笔记整理</h2><h3 id="1-1-安装篇"><a href="#1-1-安装篇" class="headerlink" title="1.1.安装篇"></a>1.1.安装篇</h3><p><a href="http://kangsgo.com/31.html">Gromacs2018 详细安装</a>  (兼容gromacs5.X版本)</p><p><a href="http://kangsgo.com/577.html">Gromacs CUDA版一键安装脚本</a></p><h3 id="1-2-核心教程"><a href="#1-2-核心教程" class="headerlink" title="1.2.核心教程"></a>1.2.核心教程</h3><h4 id="1-2-1-James-Wes-Barnett教程"><a href="#1-2-1-James-Wes-Barnett教程" class="headerlink" title="1.2.1 James (Wes) Barnett教程"></a>1.2.1 James (Wes) Barnett教程</h4><p><a href="http://kangsgo.com/42.html">Gromacs教程</a></p><p><a href="http://kangsgo.com/41.html">GROMACS教程1-水</a></p><p><a href="http://kangsgo.com/41.html">GROMACS教程2-水中的单个甲烷</a></p><h4 id="1-2-2-简单教程"><a href="#1-2-2-简单教程" class="headerlink" title="1.2.2 简单教程"></a>1.2.2 简单教程</h4><p><a href="http://kangsgo.com/670.html">GROMACS之水中部分載脂蛋白</a></p><h4 id="1-2-3-蛋白配体教程"><a href="#1-2-3-蛋白配体教程" class="headerlink" title="1.2.3 蛋白配体教程"></a>1.2.3 蛋白配体教程</h4><p><a href="http://kangsgo.com/681.html">LigParGen:配体OPLS/CM1A力场在线生成</a></p><p><a href="http://kangsgo.com/94.html">gromacs下蛋白-配体复合物模拟[GAFF]</a></p><p><a href="http://kangsgo.com/13.html">gromacs中构建非标准氨基酸残基力场</a></p><p><a href="http://kangsgo.com/156.html">gromacs下蛋白配体复合物分析</a></p><h4 id="1-2-4-g-mmpbsa教程"><a href="#1-2-4-g-mmpbsa教程" class="headerlink" title="1.2.4 g_mmpbsa教程"></a>1.2.4 g_mmpbsa教程</h4><p><a href="http://kangsgo.com/18.html">g_mmpbsa之简单教程/结合自由能计算</a></p><p><a href="http://kangsgo.com/17.html">g_mmpbsa之参数注释</a></p><p><a href="http://kangsgo.com/295.html">GMXPBSAtool安装与使用经验教程</a></p><h4 id="1-2-5-其他不完善教程"><a href="#1-2-5-其他不完善教程" class="headerlink" title="1.2.5 其他不完善教程"></a>1.2.5 其他不完善教程</h4><p><a href="http://kangsgo.com/694.html">Gromacs 5.1.2做拉伸动力学的几点笔记</a></p><h3 id="1-3-小技巧合集"><a href="#1-3-小技巧合集" class="headerlink" title="1.3.小技巧合集"></a>1.3.小技巧合集</h3><p><a href="http://kangsgo.com/106.html">Gromacs共轭梯度法mdp设置</a></p><h2 id="2-Rosetta笔记整理"><a href="#2-Rosetta笔记整理" class="headerlink" title="2.Rosetta笔记整理"></a>2.Rosetta笔记整理</h2><h3 id="2-1-安装篇"><a href="#2-1-安装篇" class="headerlink" title="2.1.安装篇"></a>2.1.安装篇</h3><h3 id="2-2-完整教程"><a href="#2-2-完整教程" class="headerlink" title="2.2.完整教程"></a>2.2.完整教程</h3><p><a href="http://kangsgo.com/647.html">Rosetta蛋白蛋白对接</a></p><p><a href="http://kangsgo.com/657.html">Rosetta从头结构预测</a></p><h2 id="3-Pymol笔记整理"><a href="#3-Pymol笔记整理" class="headerlink" title="3.Pymol笔记整理"></a>3.Pymol笔记整理</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p><a href="http://kangsgo.com/47.html">Pymol安装与问题解决</a></p><h3 id="3-2-基本手册"><a href="#3-2-基本手册" class="headerlink" title="3.2 基本手册"></a>3.2 基本手册</h3><p><a href="http://kangsgo.com/706.html">Pymol选择速查手册</a></p><h3 id="3-3-笔记"><a href="#3-3-笔记" class="headerlink" title="3.3 笔记"></a>3.3 笔记</h3><p><a href="http://kangsgo.com/68.html">Pymol插件：Autodock/Vina</a></p><p><a href="http://kangsgo.com/181.html">[转]pymol小技巧-选择配体周围氨基酸残基</a></p><p><a href="http://kangsgo.com/243.html">使用Pymol的Modevectors脚本绘画豪猪图</a></p><p><a href="http://kangsgo.com/714.html">Pymol小脚本之Rotkit</a></p><p><a href="http://kangsgo.com/7.html">利用Pymol将周边图像虚化</a></p><p><a href="http://kangsgo.com/23.html">Pymol核酸绘图</a></p><p><a href="http://kangsgo.com/22.html">Pymol渲染（Ray）笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Gromacs笔记整理&quot;&gt;&lt;a href=&quot;#1-Gromacs笔记整理&quot; class=&quot;headerlink&quot; title=&quot;1.Gromacs笔记整理&quot;&gt;&lt;/a&gt;1.Gromacs笔记整理&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装篇&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gromacs使用额外水模型</title>
    <link href="http://kangsgo.com/46.html"/>
    <id>http://kangsgo.com/46.html</id>
    <published>2018-05-07T11:27:12.000Z</published>
    <updated>2018-05-07T11:40:00.656Z</updated>
    
    <content type="html"><![CDATA[<p>在我们MD中我们有时候很少进行水模型的选择，很多时候我们对于不要求精确的体系使用<code>spc</code>水模型，对于相对要求精确的模型一般使用<code>tip3p</code>模型，对于离子或者小分子的研究有时候使用<code>tip4p</code>的模型，这些在gromacs中都是含有的，但是水模型一直在发展，不同的体系可能对于水模型有较大的变化，具体可以查看水模型的<a href="http://www1.lsbu.ac.uk/water/water_models.html" target="_blank" rel="external">综述页面</a>。例如核酸中用的较多的除了<code>tip4p-eW</code>水模型以外还有<code>OPC</code>水模型，但是该水模型并未在gromacs中自带，所以需要自己构建，以下简单介绍方法:</p><h3 id="关于OPC水模型"><a href="#关于OPC水模型" class="headerlink" title="关于OPC水模型"></a>关于OPC水模型</h3><p>简化的经典水模型是实际原子模拟中不可缺少的组成部分。然而，尽管经过几十年的深入研究，这些模型还远未完善。我们开发了一种新的方法来构建广泛使用的点电荷水模型，这与主流水模型参数化技术完全不同。与传统方法相比，除了对称性之外，我们不对模型施加任何几何约束。相反，我们优化点电荷的分布以最好地描述水分子的“静电”。我们使用这种新方法开发了4点OPC和3点OPC3刚性水模型，与常用的刚性模型相比，该模型显示出更为精确地重现大部分的性质。</p><h3 id="以OPC水模型为例"><a href="#以OPC水模型为例" class="headerlink" title="以OPC水模型为例"></a>以OPC水模型为例</h3><p>首先进行<a href="https://bioinformatics.cs.vt.edu/~izadi/OPC_Gromacs/opc.top" target="_blank" rel="external">下载</a>GROMACS的OPC，topol文件，若没有带拓扑文件，可以使用例如ACPYPE进行转化。<br>OPC水模型的topol文件完整如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">[ atomtypes ]</div><div class="line">OW            OW      0.0000  0.0000  A   3.16655e-01  8.903586e-01</div><div class="line">HW            HW      0.0000  0.0000  A   0.00000e+00  0.00000e+00</div><div class="line">MW            MW      0.0000  0.0000  A   0.00000e+00  0.00000e+00</div><div class="line"></div><div class="line">[ moleculetype ]</div><div class="line">; molname       nrexcl</div><div class="line">SOL             2</div><div class="line"></div><div class="line">[ atoms ]</div><div class="line">; id  at type     res nr  res name  at name  cg nr  charge    mass</div><div class="line">  1   OW          1       SOL       OW       1       0        16.00000</div><div class="line">  2   HW          1       SOL       HW1      1       0.67914   1.00800</div><div class="line">  3   HW          1       SOL       HW2      1       0.67914   1.00800</div><div class="line">  4   MW          1       SOL       MW       1      -1.35828   0.00000</div><div class="line"></div><div class="line">#ifndef FLEXIBLE</div><div class="line"></div><div class="line">[ settles ]</div><div class="line">; i     funct   doh     dhh</div><div class="line">1       1       0.08724 0.13712</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">[ bonds ]</div><div class="line">; i     j       funct   length  force.c.</div><div class="line">1       2       1       0.08724 502416.0 0.08724        502416.0</div><div class="line">1       3       1       0.08724 502416.0 0.08724        502416.0</div><div class="line"></div><div class="line">[ angles ]</div><div class="line">; i     j       k       funct   angle   force.c.</div><div class="line">2       1       3       1       103.6   628.02  103.6  628.02</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line">[ virtual_sites3 ]</div><div class="line">; Vsite from                    funct   a               b</div><div class="line">4       1       2       3       1       0.147722363     0.147722363</div><div class="line"></div><div class="line"></div><div class="line">[ exclusions ]</div><div class="line">1       2       3       4</div><div class="line">2       1       3       4</div><div class="line">3       1       2       4</div><div class="line">4       1       2       3</div><div class="line"></div><div class="line"></div><div class="line">; The position of the virtual site is computed as follows:</div><div class="line">;</div><div class="line">;               O</div><div class="line">;             </div><div class="line">;               V</div><div class="line">;         </div><div class="line">;       H               H</div><div class="line">;</div><div class="line">; Ewald OPC:</div><div class="line">; const = distance (OV) / [ cos (angle(VOH))    * distance (OH) ]</div><div class="line">;         0.01594 nm     / [ cos (51.8 deg)     * 0.0872433 nm    ]</div><div class="line">;       then a = b = 0.5 * const = 0.147722363</div><div class="line">;</div><div class="line">; Vsite pos x4 = x1 + a*(x2-x1) + b*(x3-x1)</div></pre></td></tr></table></figure><p>我们可以在<code>topol</code>或者<code>ffnobonded.itp</code>中恰当的位置写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">;opc</div><div class="line">HW_opc       1       1.008   0.0000  A   0.00000e+00  0.00000e+00</div><div class="line">OW_opc       8      16.00    0.0000  A   3.16655e-01  8.903586e-01</div></pre></td></tr></table></figure></p><p>为了防止污染我把原拓扑中的原子类型增加了后缀，以免报错。然后将原top中的[ <code>atomtypes</code> ]部分删除，重命名为<code>opc.itp</code>.</p><p>由于我们使用的为4点电荷，我是使用的gromacs中<code>tip4p</code>那一套，反正要进行预平衡的，当然也可以自己预平衡一个水，制作一个gro文件。简单介绍一下我用tip4p选择水模型以后，仅需将topol文件中的水拓扑文件替换为如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">; Include water topology</div><div class="line">#include &quot;./amber_na.ff/opc.itp&quot;</div></pre></td></tr></table></figure><p>值得注意的是opc水模型在md过程中需要进行长程色散校正或者使用Lennard Jones PME,即以下mdp设置二选一（默认的gromacs教程中有1设置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. DispCorr = EnerPres (Tested)</div><div class="line">2. vdwtype = PME</div></pre></td></tr></table></figure><p>参考资料:<a href="https://bioinformatics.cs.vt.edu/~izadi/" target="_blank" rel="external">https://bioinformatics.cs.vt.edu/~izadi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们MD中我们有时候很少进行水模型的选择，很多时候我们对于不要求精确的体系使用&lt;code&gt;spc&lt;/code&gt;水模型，对于相对要求精确的模型一般使用&lt;code&gt;tip3p&lt;/code&gt;模型，对于离子或者小分子的研究有时候使用&lt;code&gt;tip4p&lt;/code&gt;的模型，这些
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Gromacs" scheme="http://kangsgo.com/tags/Gromacs/"/>
    
  </entry>
  
  <entry>
    <title>Pymol之保存</title>
    <link href="http://kangsgo.com/45.html"/>
    <id>http://kangsgo.com/45.html</id>
    <published>2018-05-05T13:09:30.000Z</published>
    <updated>2018-05-05T13:11:05.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h2><p>简单的保存笔记，仅个人之用，所以可能有点潦草</p><p>PyMOL可以使用<code>save</code>命令：<br>保存 .pdb, .pqr, .mol, .sdf, .pkl, .pkla, .mmd, .out, .dat, .mmod, .pmo, .pov, .png, .pse, .psw, .aln, .fasta, .obj, .mtl, .wrl, .idtf, .dae, or .mol2格式</p><p>同样可以保存PyMOL缓存文件.pse</p><p>另外还可以保存CLUSTALW类似比对文件.aln</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>一般格式为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save file [,(selection) [,state [,format]] ]</div></pre></td></tr></table></figure></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 只保存alpha 碳原子</span></div><div class="line">save onlyCAs.pdb, n. CA</div><div class="line"></div><div class="line"><span class="comment"># 保存轨迹文件</span></div><div class="line">save myTraj.pdb, myMDTrajectory, state=<span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment"># 保存为PyMOL 缓存文件</span></div><div class="line">save thisSession.pse</div></pre></td></tr></table></figure><h3 id="PYMOL-API"><a href="#PYMOL-API" class="headerlink" title="PYMOL API"></a>PYMOL API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd.save(filename[, selection[, state[, format]]])</div></pre></td></tr></table></figure><h2 id="保存高质量图片"><a href="#保存高质量图片" class="headerlink" title="保存高质量图片"></a>保存高质量图片</h2><p>有时候我们需要科研制图，保存高质量如300dpi的图片，新的（2.0）PyMOL版本可以直接在ray的时候进行选择修改，相当方便，如果是用的老版本或者喜欢用命令的朋友，可以使用如下方法:</p><p>渲染的时候进行dpi的的更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ray 长,宽</div></pre></td></tr></table></figure></p><p>保存的时候进行dpi的更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">png fileName, dpi=300</div></pre></td></tr></table></figure></p><p>当然也可以进行长宽的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">png filename[, width[, height[, dpi[, ray[, quiet]]]]]</div></pre></td></tr></table></figure><p>其中<code>ray</code>模式表示是否在保存之前进行渲染</p><p>如果需要设置透明背景，可以如下操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set ray_opaque_background, 0</div></pre></td></tr></table></figure></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">png ~/Desktop/test.png, width=<span class="number">10</span>cm, dpi=<span class="number">300</span>, ray=<span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 渲染</span></div><div class="line">ray <span class="number">576</span>,<span class="number">576</span>   <span class="comment"># 8inch * 72dpi</span></div><div class="line">ray <span class="number">800</span>,<span class="number">800</span>   <span class="comment"># 8inch * 100dpi; or a 4inch * 200 DPI photo; or 1x800.</span></div><div class="line">ray <span class="number">2400</span>,<span class="number">2400</span> <span class="comment"># 8inch * 300dpi; 6"x400dpi, etc...</span></div></pre></td></tr></table></figure><h3 id="PyMOL-API"><a href="#PyMOL-API" class="headerlink" title="PyMOL API"></a>PyMOL API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd.png(string filename, int width=0, int height=0, float dpi=-1, int ray=0, int quiet=0)</div></pre></td></tr></table></figure><p>参考资料:<a href="https://pymolwiki.org/index.php/Save" target="_blank" rel="external">Save</a></p><pre><code>[Png](https://pymolwiki.org/index.php/Png)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;保存文件&quot;&gt;&lt;a href=&quot;#保存文件&quot; class=&quot;headerlink&quot; title=&quot;保存文件&quot;&gt;&lt;/a&gt;保存文件&lt;/h2&gt;&lt;p&gt;简单的保存笔记，仅个人之用，所以可能有点潦草&lt;/p&gt;
&lt;p&gt;PyMOL可以使用&lt;code&gt;save&lt;/code&gt;命令：&lt;br
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>Pymol加载对称单元</title>
    <link href="http://kangsgo.com/44.html"/>
    <id>http://kangsgo.com/44.html</id>
    <published>2018-05-05T09:09:30.000Z</published>
    <updated>2018-05-07T10:49:27.939Z</updated>
    
    <content type="html"><![CDATA[<p>有时候有一些蛋白是对称单元组成的，如铁蛋白，但是晶体结构pdb坐标只有一部分，另外一部分写在信息里，我们如果想看全部或者需要全部的pdb坐标，可以使用如下方法实现:</p><h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2><p><strong>该功能需要PyMOL 1.8以上</strong><br>设置对称单元，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set assembly, <span class="string">""</span></div><div class="line">fetch <span class="number">3</span>bw1, asu, <span class="keyword">async</span>=<span class="number">0</span></div><div class="line"></div><div class="line">set assembly, <span class="number">1</span></div><div class="line">fetch <span class="number">3</span>bw1, assembly1, <span class="keyword">async</span>=<span class="number">0</span></div><div class="line"></div><div class="line">set grid_mode</div></pre></td></tr></table></figure><h2 id="BiologicalUnit-Quat"><a href="#BiologicalUnit-Quat" class="headerlink" title="BiologicalUnit/Quat"></a>BiologicalUnit/Quat</h2><p>该方法可以重构pdb的另外一边</p><h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">(c) 2010-2011 Thomas Holder, MPI for Developmental Biology</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">Module for reading REMARK records from PDB files and in particular</span></div><div class="line"><span class="string">generate quaterny structure from REMARK 350.</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys, os</div><div class="line"><span class="keyword">from</span> pymol <span class="keyword">import</span> cmd, stored</div><div class="line"></div><div class="line">local_mirror_divided = <span class="string">'/mnt/bio/db/pdb.divided'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pdbremarks</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    Read REMARK lines from PDB file. Return dictionary with remarkNum as key</span></div><div class="line"><span class="string">    and list of lines as value.</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    remarks = dict()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(filename, basestring):</div><div class="line">        f = filename</div><div class="line">    <span class="keyword">elif</span> filename[<span class="number">-3</span>:] == <span class="string">'.gz'</span>:</div><div class="line">        <span class="keyword">import</span> gzip</div><div class="line">        f = gzip.open(filename)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        f = open(filename)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        recname = line[<span class="number">0</span>:<span class="number">6</span>]</div><div class="line">        <span class="keyword">if</span> recname == <span class="string">'REMARK'</span>:</div><div class="line">            num = int(line[<span class="number">7</span>:<span class="number">10</span>])</div><div class="line">            lstring = line[<span class="number">11</span>:]</div><div class="line">            remarks.setdefault(num, []).append(lstring)</div><div class="line">    <span class="keyword">return</span> remarks</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quat350</span><span class="params">(rem350)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    Get transformation matrices for biomolecule 1 from REMARK 350.</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    biomt = dict()</div><div class="line">    chains = tuple()</div><div class="line">    seenbiomolecule = <span class="keyword">False</span></div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> rem350:</div><div class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'BIOMOLECULE:'</span>):</div><div class="line">            <span class="keyword">if</span> seenbiomolecule:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            seenbiomolecule = <span class="keyword">True</span></div><div class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'APPLY THE FOLLOWING TO CHAINS:'</span>):</div><div class="line">            chains = tuple(chain.strip() <span class="keyword">for</span> chain <span class="keyword">in</span> line[<span class="number">30</span>:].split(<span class="string">','</span>))</div><div class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'                   AND CHAINS:'</span>):</div><div class="line">            chains += tuple(chain.strip() <span class="keyword">for</span> chain <span class="keyword">in</span> line[<span class="number">30</span>:].split(<span class="string">','</span>))</div><div class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'  BIOMT'</span>):</div><div class="line">            row = int(line[<span class="number">7</span>])</div><div class="line">            num = int(line[<span class="number">8</span>:<span class="number">12</span>])</div><div class="line">            vec = line[<span class="number">12</span>:].split()</div><div class="line">            vec = map(float, vec)</div><div class="line">            biomt.setdefault(chains, dict()).setdefault(num, []).extend(vec)</div><div class="line">    <span class="keyword">return</span> biomt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quat</span><span class="params">(name=None, filename=None, prefix=None, quiet=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">DESCRIPTION</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Read REMARK 350 from `filename` and create biological unit</span></div><div class="line"><span class="string">    (quaternary structure)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">USAGE</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    quat [name [, filename [, prefix]]]</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">ARGUMENTS</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    name = string: name of object and basename of PDB file, if</span></div><div class="line"><span class="string">    filename is not given &#123;default: first loaded object&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    filename = string: file path &#123;default: &lt;name&gt;.pdb&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    prefix = string: prefix for new objects &#123;default: &lt;name&gt;&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">EXAMPLE</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    fetch 1rmv, type=pdb</span></div><div class="line"><span class="string">    quat 1rmv</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    quiet = int(quiet)</div><div class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        name = cmd.get_object_list()[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> prefix <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        prefix = name</div><div class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        candidates = [</div><div class="line">            <span class="string">'%s.pdb'</span> % (name),</div><div class="line">            <span class="string">'%s/%s.pdb'</span> % (cmd.get(<span class="string">'fetch_path'</span>), name),</div><div class="line">            <span class="string">'%s/%s/pdb%s.ent.gz'</span> % (local_mirror_divided, name[<span class="number">1</span>:<span class="number">3</span>], name),</div><div class="line">        ]</div><div class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> candidates:</div><div class="line">            <span class="keyword">if</span> os.path.exists(filename):</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'please provide filename'</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> quiet:</div><div class="line">            <span class="keyword">print</span> <span class="string">'loading from %s'</span> % (filename)</div><div class="line">    remarks = pdbremarks(filename)</div><div class="line">    <span class="keyword">if</span> <span class="number">350</span> <span class="keyword">not</span> <span class="keyword">in</span> remarks:</div><div class="line">        <span class="keyword">print</span> <span class="string">'There is no REMARK 350 in'</span>, filename</div><div class="line">        <span class="keyword">return</span></div><div class="line">    quat = quat350(remarks[<span class="number">350</span>])</div><div class="line">    <span class="keyword">for</span> chains <span class="keyword">in</span> quat:</div><div class="line">        matrices = quat[chains]</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> matrices:</div><div class="line">            mat = matrices[num][<span class="number">0</span>:<span class="number">12</span>]</div><div class="line">            mat.extend([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</div><div class="line">            copy = <span class="string">'%s_%d'</span> % (prefix, num)</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> quiet:</div><div class="line">                <span class="keyword">print</span> <span class="string">'creating %s'</span> % (copy)</div><div class="line">            cmd.create(copy, <span class="string">'/%s//%s'</span> % (name, <span class="string">'+'</span>.join(chains)))</div><div class="line">            cmd.alter(copy, <span class="string">'segi="%d"'</span> % (num))</div><div class="line">            cmd.transform_object(copy, mat)</div><div class="line">    cmd.disable(name)</div><div class="line">    cmd.group(<span class="string">'%s_quat'</span> % (prefix), <span class="string">'%s_*'</span> % (prefix))</div><div class="line"></div><div class="line">cmd.extend(<span class="string">'quat'</span>, quat)</div><div class="line"></div><div class="line"><span class="comment"># vi:expandtab:smarttab</span></div></pre></td></tr></table></figure><p>使用方法非常简单:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch <span class="number">3</span>bw1, type=pdb</div><div class="line">quat <span class="number">3</span>bw1</div><div class="line"><span class="keyword">as</span> cartoon</div></pre></td></tr></table></figure></p><p>以下是前后的区别:<br>前:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/5/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>后:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/5/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>参考资料:<a href="https://pymolwiki.org/index.php/BiologicalUnit/Quat" target="_blank" rel="external">BiologicalUnit</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候有一些蛋白是对称单元组成的，如铁蛋白，但是晶体结构pdb坐标只有一部分，另外一部分写在信息里，我们如果想看全部或者需要全部的pdb坐标，可以使用如下方法实现:&lt;/p&gt;
&lt;h2 id=&quot;Assembly&quot;&gt;&lt;a href=&quot;#Assembly&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>Gromacs教程2-水中的单个甲烷</title>
    <link href="http://kangsgo.com/43.html"/>
    <id>http://kangsgo.com/43.html</id>
    <published>2018-04-25T10:32:12.000Z</published>
    <updated>2018-04-25T11:26:08.737Z</updated>
    
    <content type="html"><![CDATA[<p>原文：James (Wes) Barnett<br>翻译：谷歌/康文渊-湖南大学</p><p>在本教程中，我将向您展示如何在一个盒子的TIP4PEW水中创建一个包含一个OPLS力场甲烷的系统。</p><p>##设置<br>和以前一样，我们需要一个结构文件，一个拓扑文件和参数文件。我们将使用GROMACS工具<em>gmx pdb2gmx</em>从pdb文件生成拓扑。</p><h2 id="用pdb2gmx设置残基"><a href="#用pdb2gmx设置残基" class="headerlink" title="用pdb2gmx设置残基"></a>用pdb2gmx设置残基</h2><p>对于这个分子，我们将使用OPLS力场。 力场位于顶层力场目录（可能是<code>/usr/share/gromacs/top</code>或类似的东西）。</p><p>如果您不确定您的GROMACS安装位置在哪里，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> $ GMXPREFIX</div></pre></td></tr></table></figure><p>如果您sourcing 了GROMACS配置文件，则会为您提供安装位置。在该目录中找到<code>share/gromacs/top</code>并进入它（例如，如果GMXPREFIX是<code>/usr</code>，则转到<code>/usr/share/gromacs/top</code>）。或者你可以简单地转到<code>$GMXDATA/top</code>。</p><p>我们来看看force field目录的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> oplsaa.ff</div><div class="line">$ ls</div></pre></td></tr></table></figure><p>你会看到几个文件，但我们现在只对其中的一些文件感兴趣。注意<code>forcefield.itp</code>。这是模拟中使用的主要文件。在里面你会看到一个[<code>defaults</code>]部分以及包含两个其他文件 - 一个用于键联系，另一个用于非键联系。我们也对<code>atomtypes.atp</code>感兴趣，它给出了难以理解的<code>opls _ ####</code>术语的描述以及<code>aminoacids.rtp</code>，它们给出了用于<em>gmx pdb2gmx</em>命令能够识别的氨基酸残基列表。</p><p>用你的文本编辑器打开<code>atomtypes.atp</code>,比如用vim打开它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim atomtypes.atp</div></pre></td></tr></table></figure><p>转到<code>opls_138</code>的行。请注意，注释是否为<code>alkane CH4</code>。但是，请注意第二列中的mass - 这只是CH4组的碳，所以我们也需要氢。这是一个“全原子”模型 - 每个原子都被表示出来。相应的氢是<code>opls_140</code>。您可能还需要查看<a href="http://pubs.acs.org/doi/suppl/10.1021/ja9621760/suppl_file/ja11225.pdf" target="_blank" rel="external">OPLS force field 论文</a>的支持信息。论文中的参数应该与我们刚刚看到的参数相匹配。现在记下这两种原子类型并关闭文件。</p><p>让我们来看看这两种原子类型的ffnonbonded.itp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep opls_138 ffnonbonded.itp</div><div class="line">$ grep opls_140 ffnonbonded.itp</div></pre></td></tr></table></figure><p>在这里，我们看到原子类型的名称，键类型，质量，电荷，ptype，sigma和epsilon。记下每个类型的电荷 - 我们将需要它来构建我们新的氨基酸残基。作为一个方面说明，<code>ffbonded.itp</code>将使用键类型，键类型和二面角类型。</p><p>在继续之前，您可能希望将您的顶级力场目录复制到别的地方，例如您的主目录，因为我们将修改它并添加一些文件。将其复制到您的主目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp -r <span class="variable">$GMXDATA</span>/top <span class="variable">$HOME</span>/GMXLIB</div></pre></td></tr></table></figure><p>你可能需要root权限执行它。现在将<code>$ GMXLIB</code>环境变量更改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> GMXLIB = $ HOME/GMXLIB</div></pre></td></tr></table></figure><p>将上述内容添加到<code>.bash_profile</code>中以使其成为永久性的,然后进行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> $ GMXLIB</div></pre></td></tr></table></figure><p>您现在处于刚刚拷贝的副本中，所有模拟将使用该目录而不是GROMACS默认目录中提供的目录。</p><p>现在进入<code>oplsaa.ff</code>并打开<code>aminoacids.rtp</code>。您会注意到文件中已有多个残基。我们将为我们的甲烷添加一个名为<code>methane.rtp</code>的新文件，其中包含我们称之为CH4的残基。关闭<code>aminoacids.rtp</code>。我们需要告诉<em>gmx pdb2gmx</em>我们的残差文件中原子的原子和键。我们也可以告诉它角度，但是我们会将它们排除在外，因为<em>gmx pdb2gmx</em>会为我们解决这个问题。现在需要在<code>oplsaa.ff</code>目录中创建以下内容并另存为<code>methane.rtp</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[ bondedtypes ]</div><div class="line">; bonds  angles  dihedrals  impropers all_dihedrals nrexcl HH14 RemoveDih</div><div class="line">  1      1       3          1         1             3      1    0</div><div class="line"></div><div class="line">; Methane</div><div class="line">[ CH4 ]</div><div class="line"> [ atoms ]</div><div class="line">   C      opls_138    -0.240     1</div><div class="line">   H1     opls_140     0.060     1</div><div class="line">   H2     opls_140     0.060     1</div><div class="line">   H3     opls_140     0.060     1</div><div class="line">   H4     opls_140     0.060     1</div><div class="line"> [ bonds ]</div><div class="line">   C      H1</div><div class="line">   C      H2</div><div class="line">   C      H3</div><div class="line">   C      H4</div></pre></td></tr></table></figure><p>关于上述文件的一些注意事项：[<code>bondedtypes</code>]来自<code>aminoacids.rtp</code>并且是必需的。 在[<code>atoms</code>]下的名字可以随便命名，但是需要匹配稍后构建pdb文件中的名字。 注意在第一列中我们给出了原子名称，然后我们给出了原子类型，电荷，然后是电荷组。 在[<code>bonds</code>]下，我们只是告诉它每个原子如何连接到其他原子。 在这种情况下，<code>C</code>与每个氢都有连接。我们可以选择添加[<code>angles</code>]，但是如前所述，GROMACS会为我们搞定。 现在关闭文件。 有关这方面的更多信息，请参阅第5.6节。</p><h2 id="创建pdb文件并且运行gmx-pdb2gmx"><a href="#创建pdb文件并且运行gmx-pdb2gmx" class="headerlink" title="创建pdb文件并且运行gmx pdb2gmx"></a>创建pdb文件并且运行<em>gmx pdb2gmx</em></h2><p>现在我们准备创建pdb文件。 有几个程序可以创建分子结构文件。例如 <a href="http://avogadro.cc/wiki/Main_Page" target="_blank" rel="external">Avogadro</a>。 另一种方法是使用AmberTools软件包中的“xleap”。 将这个文件保存为methane.pdb。 你的文件应该看起来像这样。 将其保存在您的主目录中的某个位置，但不在<code>$ GMXLIB</code>中的任何位置。</p><p>在<code>methane.pdb</code>中将LIG更改为CH4。还要将第一个H更改为H1，将第二个更改为H2等等。PDB文件是固定格式，因此请将每列的开头保留在相同的位置。CONNECT和MASTER记录也不需要，因此可以删除它们。同时继续并将<code>UNNAMED</code>更改为<code>METHANE</code>。你修改过的文件应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">COMPND    METHANE</div><div class="line">AUTHOR    GENERATED BY OPEN BABEL 2.3.2</div><div class="line">HETATM    1  C   CH4     1      -0.370   0.900   0.000  1.00  0.00           C  </div><div class="line">HETATM    2  H1  CH4     1       0.700   0.900   0.000  1.00  0.00           H  </div><div class="line">HETATM    3  H2  CH4     1      -0.727   0.122   0.643  1.00  0.00           H  </div><div class="line">HETATM    4  H3  CH4     1      -0.727   0.731  -0.995  1.00  0.00           H  </div><div class="line">HETATM    5  H4  CH4     1      -0.727   1.845   0.351  1.00  0.00           H  </div><div class="line">END</div></pre></td></tr></table></figure><p>保存文件为<code>methane.pdb</code>.</p><p>现在我们可以使用<em>gmx pdb2gmx</em>创建GROMACS .conf和.top文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx pdb2gmx -f methane.pdb</div></pre></td></tr></table></figure><p>系统会提示您选择力场。选择OPLS。如果您在两个不同的力场目录之间有一个选项，请选择您所复制目录中的OPLS。对于水模型选择TIP4PEW。如果您发现GROMACS找不到残基CH4的错误，您可能会使用错误的力场。</p><p>将创建三个文件：<code>conf.gro</code>，<code>posre.itp</code>和<code>topol.top</code>。<code>conf.gro</code>是我们的文件，只包含一个甲烷，<code>topol.top</code>是系统的拓扑文件，<code>posre.itp</code>是我们溶质（甲烷）的可选位置限制文件。我们不会使用那个。在<code>topol.top</code>文件中注意到有一个[<code>angles</code>]部分。您还需要在<code>topol.top</code>中重命名化合物。看看并探索每个文件。 GROMACS手册的第5章将帮助您更多地了解拓扑文件。</p><p><strong>注意</strong>：<code>topol.top</code>和<code>methane.pdb</code>将在其他教程中再次使用。</p><p>对于那些使用<em>gmx pdb2gmx</em>生成大型蛋白质拓扑的人来说，事情会变得更加复杂。这仅仅是一个简单的例子，我们可能真的可以在其他地方找到这种拓扑。</p><h3 id="溶剂体系"><a href="#溶剂体系" class="headerlink" title="溶剂体系"></a>溶剂体系</h3><p>我们的结构文件和拓扑文件到目前为止只有我们的甲烷。我们需要通过使用<em>gmx solvate</em>来添加水：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx solvate -cp conf.gro -o conf.gro -cs tip4p -p topol.top -box 2.3 2.3 2.3</div></pre></td></tr></table></figure><h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><p>我们将使用前一教程中的相同<a href="http://wbarnett.us/tutorials/1_tip4pew_water/mdp.tar.gz" target="_blank" rel="external">文件</a>。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>我们将使用与上次相同的流程。这假定您的<code>mdp</code>文件位于名为<code>mdp</code>的目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ gmx grompp -f mdp/min.mdp -o min -pp min -po min</div><div class="line">$ gmx mdrun -deffnm min</div><div class="line">$ gmx grompp -f mdp/min2.mdp -o min2 -pp min2 -po min2 -c min -t min</div><div class="line">$ gmx mdrun -deffnm min2</div><div class="line">$ gmx grompp -f mdp/eql.mdp -o eql -pp eql -po eql -c min2 -t min2</div><div class="line">$ gmx mdrun -deffnm eql</div><div class="line">$ gmx grompp -f mdp/eql2.mdp -o eql2 -pp eql2 -po eql2 -c eql -t eql</div><div class="line">$ gmx mdrun -deffnm eql2</div><div class="line">$ gmx grompp -f mdp/prd.mdp -o prd -pp prd -po prd -c eql2 -t eql2</div><div class="line">$ gmx mdrun -deffnm prd</div></pre></td></tr></table></figure><p>您可以把它当作脚本来使用，在头部添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">set -e</div></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x run</div></pre></td></tr></table></figure><p>运行脚本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./run</div></pre></td></tr></table></figure></p><p>其中<code>set -e</code>表示如果有错误立马停止</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们来计算一下称为<a href="https://en.wikipedia.org/wiki/Radial_distribution_function" target="_blank" rel="external">径向分布函数</a>的东西。首先，我们需要创建一个索引文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx make_ndx -f conf.gro</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; a C</div><div class="line">&gt; a OW</div><div class="line">&gt; q</div></pre></td></tr></table></figure><p>然后运行 <em>gmx rdf</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx rdf -f prd.xtc -n index.ndx</div></pre></td></tr></table></figure><p>在提示时选择<code>C</code>作为参考组。 然后选择<code>OW</code>。 然后输入<code>CTRL-D</code>结束。 数据的第1列和第3列中的结果图将通过在gnuplot中执行以下操作来绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; plot &apos;rdf.xvg&apos; u 1:3 w l</div></pre></td></tr></table></figure><p>它应该看起来像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/2_methane_in_water/rdf.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本教程中，我们学习了如何创建一个用于<em>gmx pdb2gmx</em>的残基模板文件（.rtp）。 我们为OPLS甲烷创建了一个结构，并为其生成了一个拓扑。我们用gmx solvated对它周围进行了加水。在此之后，我们进行了仿真，就像上次一样。最后，我们使用<em>gmx rdf</em>发现了C-OW径向分布函数。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个<a href="https://github.com/wesbarnett/wesbarnett.github.io/issues/new" target="_blank" rel="external">问题</a>，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">GROMACS文档</a>。 您还可以将关于GROMACS的一般问题通过查阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">邮件列表</a>来解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：James (Wes) Barnett&lt;br&gt;翻译：谷歌/康文渊-湖南大学&lt;/p&gt;
&lt;p&gt;在本教程中，我将向您展示如何在一个盒子的TIP4PEW水中创建一个包含一个OPLS力场甲烷的系统。&lt;/p&gt;
&lt;p&gt;##设置&lt;br&gt;和以前一样，我们需要一个结构文件，一个拓扑文件和
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Gromacs" scheme="http://kangsgo.com/tags/Gromacs/"/>
    
  </entry>
  
  <entry>
    <title>Gromacs教程1-水</title>
    <link href="http://kangsgo.com/41.html"/>
    <id>http://kangsgo.com/41.html</id>
    <published>2018-04-23T10:32:12.000Z</published>
    <updated>2018-04-23T07:48:47.783Z</updated>
    
    <content type="html"><![CDATA[<p>原文：James (Wes) Barnett<br>翻译：谷歌/康文渊-湖南大学</p><p>在本入门教程中，我将向您展示如何创建一个盒子的水，并在恒定的温度和压力下对其进行简单模拟。 最后我们会找出水的密度。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>每个GROMACS模拟需要三个基本文件：结构（.gro / .pdb），拓扑（.top）和参数（.mdp）。 结构文件包含系统中每个原子位点的笛卡尔坐标。 该拓扑文件包含有关每个原子位点与其他原子位点进行联系的信息，无论该位点是处于非键联系还是键联系。 这个信息由力场提供。 非键相互作用包括范德华相互作用和库仑相互作用。 键相互作用包括键长，角度和二面角。 参数文件包括运行模拟的时间，时间步长，温度和压力耦合等信息。下面我们将获取/创建这些文件。</p><p>在这一点上，我会建议创建一个目录来存储本教程的文件。</p><h2 id="拓扑文件"><a href="#拓扑文件" class="headerlink" title="拓扑文件"></a>拓扑文件</h2><p>我们将从拓扑文件开始。 通常，拓扑文件使用<code>#include</code>语句来包含要使用的力场。 这个力场包括[<code>atomtypes</code>]，[<code>bondtypes</code>]，[<code>angletypes</code>]和[<code>dihedraltypes</code>]指令。 然后在拓扑文件中通常我们指定包含[<code>atoms</code>]，[<code>bond</code>]和[<code>dihedrals</code>]的不同[<code>moleculetype</code>]指令，这些指令指向力场。 现在不要担心这个太多。 对我们来说水模型包括上述说的所有这些。有关更多信息，请参阅参考手册的第5章。</p><p>用以下文本创建一个名为<code>topol.top</code>的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &quot;oplsaa.ff/forcefield.itp&quot;</div><div class="line">#include &quot;oplsaa.ff/tip4pew.itp&quot;</div><div class="line"></div><div class="line">[ System ]</div><div class="line">TIP4PEW</div><div class="line"></div><div class="line">[ Molecules ]</div></pre></td></tr></table></figure></p><p>正如你所看到的，我们已经包含了OPLS-AA的力场。 另外我们还包括了TIP4PEW水模型。 之后你会看到一个[<code>System</code>]指令，其中只包括系统的名称，可以是任何你想要的。 最后，我们列出每种分子类型以及[<code>Molecules</code>]下的分子类型。 现在我们没有（不过马上我们将要得到这些）。</p><h2 id="结构文件"><a href="#结构文件" class="headerlink" title="结构文件"></a>结构文件</h2><p>TIP4PEW的结构已由GROMACS在拓扑目录中提供。 这个标准位置通常是<code>/usr/share/gromacs/top</code>，但是我已经将它安装在不同的目录中。 如果您正确采购GMXRC，那么它将位于<code>$GMXDATA/top</code>。 在该目录中，您会看到几个<code>.gro</code>文件，其中之一是<code>tip4p.gro</code>。您还会看到上面我们的拓扑文件中包含的文件夹<code>oplsaa.ff</code>。没有特别的<code>TIP4PEW</code>结构文件。<code>TIP4P</code>和<code>TIP4PEW</code>的四点水结构基本相同。 他们仅是力场参数不同。</p><p>要使用该结构文件创建一盒水，请执行以下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx solvate -cs tip4p -o conf.gro -box 2.3 2.3 2.3 -p topol.top</div></pre></td></tr></table></figure></p><p>如果你打开<code>topol.top</code>文件，你会看到最后添加了一行<code>SOL</code>和number。<code>SOL</code>是在<code>oplsaa.ff/tip4pew.itp</code>中定义的<code>moleculetype</code>的名称。 当我们运行<em>gmx solvate</em>时，GROMACS在每个方向2.3 nm的盒子中添加了足够的水分子。</p><h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><p>现在我们需要一组参数文件，以便GROMACS知道如何处理我们的起始结构。 模拟几乎总是有三个主要部分：最小化，平衡和生产。 最小化和平衡可以分解为多个步骤。 这些都需要它自己的参数文件。 在这种情况下，我们将进行两次最小化，两次平衡和一次生产运行。</p><p>我们将要使用的文件可以从<a href="http://wbarnett.us/tutorials/1_tip4pew_water/mdp.tar.gz" target="_blank" rel="external">这里下载</a>。</p><p>我们所有五个文件都有一些共同点。 在每个描述中，我只给出一个非常小的注释。有关每个选项的更多信息，请参阅<a href="http://manual.gromacs.org/documentation/5.1/user-guide/mdp-options.html" target="_blank" rel="external">GROMACS页面</a>。</p><table><thead><tr><th>参数</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>cutoff-scheme</td><td>Verlet</td><td>用于创建邻近列表。 这是现在的默认设置，但我们在这里提供它以避免任何注释。</td></tr><tr><td>coulombtype</td><td>PME</td><td>使用 Particle-Mesh Ewald for long-range (k-space) 点荷联系.</td></tr><tr><td>rcoulomb</td><td>1.0</td><td>Cut-off for real/k-space for PME (nm).</td></tr><tr><td>vdwtype</td><td>Cut-off</td><td>van der Walls forces cut-off at rvdw</td></tr><tr><td>rvdw</td><td>1.0</td><td>Cut-off for VDW (nm).</td></tr><tr><td>DispCorr</td><td>EnerPress</td><td>VDW对能量和压力的长程校正。</td></tr></tbody></table><p>应该设置截断距离，同时要记住力场是如何参数化的。换句话说，看看描述力场如何创造的期刊文章是一个好主意。我们在这里选择了1.0纳米作为截止点，这对于OPLS来说已经足够普遍了，但是您可以确定系统选择其他方法。</p><p>此外，在每个部分中，我们还将输出能量文件，日志文件和压缩轨迹文件。输出的速率（在模拟步骤中）分别使用<code>nstenergy</code>，<code>nstlog</code>和<code>nstxout-compressed</code>进行设置。我们将在生产运行中输出更多信息。</p><p>对于每个部分，除了第二次最小化之外，我们还将通过设置<code>constraint-algorithm = lincs</code>和<code>constraints = h-bonds</code>，使用LINCS算法约束所有涉及氢的键。这使我们能够使用比其他更大的时间步骤。</p><p>对于第一次最小化，我们使用最陡峭下降算法，通过设置<code>integrator = steep</code>来最小化系统能量，最大步长为1000步（<code>nsteps = 1000</code>）。如果在此之前能量收敛，则最小化将停止。另外我们进行<code>define = -DFLEXIBLE</code>。这让GROMACS知道使用灵活的水，因为默认情况下所有的水模型都是使用<code>SETTLE</code>算法为刚性模型。在我们拥有的水模型的拓扑文件中，有一个if语句查找要定义的<code>FLEXIBLE</code>变量。第一次最小化的目的是使分子处于良好的起始位置，这样我们就可以无任何错误地打开<code>SETTLE</code>。</p><p>在第二个最小化中，我们只需删除<code>define = -DFLEXIBLE</code>并将最大步数增加到50,000。</p><p>最后三部分-两个平衡和生产-都使用<code>integrator = md</code>。此外，通过设置<code>dt=0.002</code>来使用2fs时间步长。</p><p>对于第一个平衡步骤，有几点需要注意。我们正在添加如下所示的几个参数：</p><table><thead><tr><th>–参数–</th><th>–值–</th><th>–解释–</th></tr></thead><tbody><tr><td>gen-vel</td><td>yes</td><td>根据Maxwell-Boltzmann分布为每个原子位点生成速度。<strong>只为您的第一个平衡步骤生成速度</strong>。这使我们接近我们将耦合系统的温度。</td></tr><tr><td>gen-temp</td><td>298.15</td><td>K中的温度用于<code>gen-vel</code>。 除非你正在做一些奇怪的/有趣的事情，否则这应该与ref-t相同。</td></tr><tr><td>tcoupl</td><td>Nose-Hoover</td><td>用于温度耦合的算法。 Nose-Hoover 为经典温度耦合算法。</td></tr><tr><td>tc-grps</td><td>System</td><td>要结合哪些组。 你可以将不同的原子组分开，但我们只需要耦合整个系统。</td></tr><tr><td>tau-t</td><td>2.0</td><td>耦合的时间常数。 详情请参阅手册。</td></tr><tr><td>ref-t</td><td>298.15</td><td>以K为单位的温度。</td></tr><tr><td>nhchainlength</td><td>1</td><td>Leap-frog integrator 只支持1，但默认情况下这是10。这是设置，所以GROMACS不会发出警告。</td></tr></tbody></table><p>第一次平衡的关键是在加压耦合之前让我们达到正确的温度（298.15 K）。 同时添加温度和压力耦合可能会导致系统不稳定并发生崩溃。 我们不想在一开始就震惊我们的系统。 另外，我们设置了<code>nsteps = 50000</code>，所以以2fs的时间步长，这意味着它将运行100ps。 这对我们在这里所做的工作是足够的，但是在更大/更复杂的系统中，您可能需要更长时间的平衡。</p><p>第二个平衡增加了压力耦合。 请注意，我们并没有再次产生速度，因为那样会取消我们刚刚做的一些工作。 我们还为约束设置了<code>continuation = yes</code>，因为我们从第一次平衡开始继续进行模拟。 这部分将运行1ns。 同样，对于其他系统，这可能需要更长一些。</p><table><thead><tr><th>–参数–</th><th>–值–</th><th>–解释–</th></tr></thead><tbody><tr><td>pcoupl</td><td>Parrinello-Rahman</td><td>用于压力耦合的算法。 Parrinello-Rahman在与Nose-Hoover一起使用时正确地产生了等压等温线。</td></tr><tr><td>tau-p</td><td>2.0</td><td>耦合的时间常数。 详情请参阅手册。</td></tr><tr><td>ref-p</td><td>1.0</td><td>压力耦合常数</td></tr><tr><td>compressibility</td><td>4.46e-5</td><td>系统压缩系数</td></tr></tbody></table><p>对于生产运行，除了输出更多数据并运行10 ns外，所有内容与上次平衡完全相同。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>我们现在有了我们需要的所有文件来运行模拟的每个部分。 每个部分通常运行<em>gmx grompp</em>，以将我们现在具有的三个文件（.gro，.top和.mdp）预处理为.tpr文件（有时也称为拓扑文件）。</p><h3 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h3><p>首先，通过执行以下操作来执行我们的两个最小化步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ gmx grompp -f mdp/min.mdp -o min -pp min -po min</div><div class="line">$ gmx mdrun -deffnm min</div><div class="line"></div><div class="line">$ gmx grompp -f mdp/min2.mdp -o min2 -pp min2 -po min2 -c min -t min</div><div class="line">$ gmx mdrun -deffnm min2</div></pre></td></tr></table></figure></p><p>在每个部分，我们都使用<code>-f</code>标志在.mdp文件中读取。默认情况下，如果未指定<code>-c</code>和<code>-p</code>标志，GROMACS将使用<code>conf.gro</code>和<code>topol.top</code>作为结构和拓扑文件。此外，我们正在输出处理后的拓扑文件<code>-pp</code>和mdp文件<code>-po</code>。这些是可选的，但可能值得一看，尤其是处理过的mdp文件，因为它已被评论。</p><p>在接下来的每一步中，我们使用<code>-c</code>和<code>-t</code>标志读入前一步的最后一个结构文件或检查点文件。默认情况下，GROMACS每15分钟和最后一步输出检查点文件。如果检查点文件不存在，GROMACS将使用由<code>-c</code>定义的结构文件，因此指定两者都是一种很好的做法。在每个<em>gmx mdrun</em>中，我们都告诉GROMACS为每个输入和输出文件使用默认名称，因为会输出多个文件。</p><p>注意我们使用<code>-maxwarn 1</code>来进行第二次最小化。只有使用这个标志，如果你知道你在做什么！在这种情况下，我们会收到关于我们可以安全绕过的L-BFGS效率的警告。</p><p>为了了解发生了什么，让我们使用GROMACS命令<em>gmx energy</em>来提取这两个部分的势能。执行以下操作并输入与<code>Potential</code>对应的数字，然后再次输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx energy -f min.edr -o min-energy.xvg</div></pre></td></tr></table></figure></p><p>相似的行为进行第二次能量最小化的阅读<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx energy -f min2.edr -o min2-energy.xvg</div></pre></td></tr></table></figure></p><p>结果<code>.xvg</code>的标题。 文件将包含供Grace绘图程序使用的信息。 我使用gnuplot，所以这些行中的一些会导致错误。 我用<code>.xvg</code>中的<code>＃</code>替换每个<code>@</code>字符。然后我可以使用gnuplot。首先启动gnuplot进行绘图：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gnuplot</div></pre></td></tr></table></figure></p><p>在gnuplot终端输入如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; plot <span class="string">'min-energy.xvg'</span> w l</div></pre></td></tr></table></figure></p><p>第二次如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; plot <span class="string">'min2-energy.xvg'</span> w l</div></pre></td></tr></table></figure></p><p>第一次的结果类似如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/1_tip4pew_water/min-pot.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>第二次结果没有改变，所以未在此绘出</p><h3 id="Equilibration-1-NVT"><a href="#Equilibration-1-NVT" class="headerlink" title="Equilibration 1 (NVT)"></a>Equilibration 1 (NVT)</h3><p>现在我们有了一个好的起始结构，让我们通过添加温度耦合来完成第一个平衡步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gmx grompp -f mdp/eql.mdp -o eql -pp eql -po eql -c min2 -t min2</div><div class="line">$ gmx mdrun -deffnm eql</div></pre></td></tr></table></figure></p><p>我们来看看整个模拟过程中温度如何变化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx energy -f eql.edr -o eql-temp.xvg</div></pre></td></tr></table></figure></p><p>在提示符下选择与温度相对应的数字，然后再次输入。 像上面那样在gnuplot中绘制它。 你应该看到像这样的东西：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/1_tip4pew_water/eql-temp.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>请注意，温度最初会波动很大，但最终会稳定下来。</p><h3 id="Equilibration-2-NPT"><a href="#Equilibration-2-NPT" class="headerlink" title="Equilibration 2 (NPT)"></a>Equilibration 2 (NPT)</h3><p>如前所述，对于我们上次的平衡，我们添加了一个压力耦合：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gmx grompp -f mdp/eql2.mdp -o eql2 -pp eql2 -po eql2 -c eql -t eql</div><div class="line">$ gmx mdrun -deffnm eql2</div></pre></td></tr></table></figure></p><p>您可以使用上述<code>gmx energy</code>检查温度和压力。绘图类似如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/1_tip4pew_water/eql2-press.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>请注意，压力波动很大，这是正常的。 在这种情况下，完全平衡后的平均值应接近1 bar。</p><h3 id="正式模拟"><a href="#正式模拟" class="headerlink" title="正式模拟"></a>正式模拟</h3><p>正式模拟部分如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gmx grompp -f mdp/prd.mdp -o prd -pp prd -po prd -c eql2 -t eql2</div><div class="line">$ gmx mdrun -deffnm prd</div></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在<code>prd.edr</code>上使用上面的<code>gmx energy</code>，得到平均温度，压力和密度。 他们是你期望的吗？</p><p>这是我的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Energy                      Average   Err.Est.       RMSD  Tot-Drift</div><div class="line">-------------------------------------------------------------------------------</div><div class="line">Temperature                 298.145      0.019    8.65629  0.0338992  (K)</div><div class="line">Pressure                    3.25876       0.97    688.616   -2.75083  (bar)</div><div class="line">Density                     995.381       0.15      12.92  0.0705576  (kg/m^3)</div></pre></td></tr></table></figure></p><p>如果你看图4中的TIP4PEW论文，你可以看到我们已经达到了正确的密度。 另外请注意，Wolfram Alpha表示标准条件下的水密度为997 kg /立方米。</p><p>你也可以使用像vmd这样的程序来模拟你的模拟。 用<a href="http://www.ks.uiuc.edu/Research/vmd/" target="_blank" rel="external">vmd</a>打开正式模拟的轨迹：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vmd prd.gro prd.xtc</div></pre></td></tr></table></figure></p><p>快照如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/1_tip4pew_water/water1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>进行周期性处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gmx trjconv -f prd.xtc -s prd.tpr -pbc mol -o prd-mol.xtc</div></pre></td></tr></table></figure></p><p>后结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wbarnett.us/tutorials/1_tip4pew_water/water2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本教程中，我们使用<em>gmx solvate</em>物产生一盒TIP4PEW水。 我们在五个不同的部分对它进行了模拟：最小化1，最小化2，平衡1，平衡2和生产。 每个部分都使用自己的.mdp文件进行了解释。 在每个部分，我们使用<em>gmx energy</em>来提取有关模拟的有用信息。 生产运行后，我们能够找到TIP4PEW水的密度。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个<a href="https://github.com/wesbarnett/wesbarnett.github.io/issues/new" target="_blank" rel="external">问题</a>，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">GROMACS文档</a>。 您还可以将关于GROMACS的一般问题通过查阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">邮件列表</a>来解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：James (Wes) Barnett&lt;br&gt;翻译：谷歌/康文渊-湖南大学&lt;/p&gt;
&lt;p&gt;在本入门教程中，我将向您展示如何创建一个盒子的水，并在恒定的温度和压力下对其进行简单模拟。 最后我们会找出水的密度。&lt;/p&gt;
&lt;h2 id=&quot;设置&quot;&gt;&lt;a href=&quot;#设置&quot; 
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Gromacs" scheme="http://kangsgo.com/tags/Gromacs/"/>
    
  </entry>
  
  <entry>
    <title>Gromacs教程</title>
    <link href="http://kangsgo.com/42.html"/>
    <id>http://kangsgo.com/42.html</id>
    <published>2018-04-23T10:27:12.000Z</published>
    <updated>2018-04-23T07:40:02.606Z</updated>
    
    <content type="html"><![CDATA[<p>这些是针对初学者的一些<a href="http://www.gromacs.org/" target="_blank" rel="external">GROMACS</a>教程。没有必要按顺序完成教程，但前两个教程在进入其他教程之前是必不可少的，因为后续教程全部使用了来自教程2的甲烷的结构文件(<code>methane.pdb</code>)和拓扑文件(<code>topol.top</code>)。这些教程是为GROMACS 5.1及更高版本设计的。如果您使用的是旧版本，则某些命令或参数可能已更改。 特别要注意的是，自5.0和更早版本以来，伞状采样的代码已经发生了变化。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>我假设你有一些关于命令行的相关知识。具体而言，您应该知道如何创建目录，更改目录，编辑文本文件以及将文件下载到系统中。 当您看到<code>$</code>或<code>&gt;</code>时，这是命令行中的提示，并指示您应该输入它后面的文本。 如果命令行对您来说是新手，请考虑通过<a href="https://www.codecademy.com/en/courses/learn-the-command-line/" target="_blank" rel="external">CodeAcademy教程</a>进行学习。</p><p>我还假设你已经在可用的机器上安装了GROMACS。 源代码和安装说明可以在GROMACS文档页面找到。</p><p>在整个教程中，我们将使用OPLS(力场)甲烷和TIP4PEW水。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol><li>水 - 建立基础模拟。找出TIP4PEW水的密度。</li><li>一个甲烷在水中 - 如何为分子创建拓扑文件并将其溶剂化。获取径向分布函数。</li><li>几个甲烷在水中 - 如何将多种溶质放入系统中。获得甲烷-甲烷之间的平均力势(PMF)。</li><li>甲烷溶剂化自由能 - 如何在偶联分子时进行自由能模拟。使用MBAR获取结果。</li><li>伞状采样 - 使用pull代码从伞状采样中获得甲烷-甲烷的平均力势。</li><li>测试颗粒插入 - 使用测试颗粒插入获得甲烷的过量化学势。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果您对翻译有什么问题，可以通过kangsgo at. vip.qq.com发邮件与我联系。如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个<a href="https://github.com/wesbarnett/wesbarnett.github.io/issues/new" target="_blank" rel="external">问题</a>，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">GROMACS文档</a>。 您还可以将关于GROMACS的一般问题通过查阅<a href="http://manual.gromacs.org/documentation" target="_blank" rel="external">邮件列表</a>来解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些是针对初学者的一些&lt;a href=&quot;http://www.gromacs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GROMACS&lt;/a&gt;教程。没有必要按顺序完成教程，但前两个教程在进入其他教程之前是必不可少的，因为后续教程全部使用了来自
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Gromacs" scheme="http://kangsgo.com/tags/Gromacs/"/>
    
  </entry>
  
  <entry>
    <title>Rosetta系列-FloppyTail构建蛋白柔性尾</title>
    <link href="http://kangsgo.com/35.html"/>
    <id>http://kangsgo.com/35.html</id>
    <published>2018-04-10T10:27:12.000Z</published>
    <updated>2018-04-11T05:11:24.931Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载请联系，且保留链接</strong></p><p>使用这个代码需要蛋白具有长的柔性尾，在晶体结构中是缺失的，生物化学证据表明已知结合伴侣上尾部的特定结合位点.该代码旨在模拟长柔性尾巴的范围并确定假设的结合位点是否合理。</p><p>该工具更有用于测试关于可能的构象的假设，并探索可用的构象空间，而不是找到“唯一真正的结合模式”。 如果你的尾巴真的很灵活，它可能没有一个“真正的结合模式”。</p><h2 id="代码和演示"><a href="#代码和演示" class="headerlink" title="代码和演示"></a>代码和演示</h2><p>代码位于<code>rosetta/main/source/src/apps/public/scenarios/FloppyTail/</code></p><p>演示位于<code>rosetta/main/tests/integration/tests/FloppyTail/</code></p><h2 id="FloppyTail哲学-怎么解决问题"><a href="#FloppyTail哲学-怎么解决问题" class="headerlink" title="FloppyTail哲学-怎么解决问题"></a>FloppyTail哲学-怎么解决问题</h2><p>FloppyTail旨在“约束对接”。 当你有一个或多个相对刚性的结构时，可以使用它，并用linker链接。 对于一些情况，如最初的柔性尾巴，问题是“这条尾巴可以对接进入刚性尾巴？”对于某些情况，例如两个结构域之间的linker区域，可能是“这两个区域对接，鉴于一些构象是不可能的，因为linker不能伸展那么远？“</p><p>一般来说，FloppyTail为 FLEXIBLE linkers发挥作用。 这有两个问题。 首先，Rosetta能量函数被参数化为折叠良好的晶体蛋白质。 它只适用于灵活的linkers，因为它的物理观点不允许非结构化的可溶性蛋白质。 其次，灵活的linkers在时间上是灵活的，但是静态结构没有时间域，因此通过查看得分高的模型并不能非常有用的表达linker区域的状态。 因此，使用FloppyTail并解释其结果需要仔细考虑结果的价值。</p><p>如果你的目标是“我有两种相互连接的蛋白质，我想知道它会是什么样子” - 这是一个昂贵的问题，成功率很低。</p><p>如果你没有实验数据，你可以使用FloppyTail生成假说。看看你的结果集合，看看更好的模型中经常发生什么样的相互作用，然后考虑如何通过实验测试这些相互作用是否真实（如通过交叉链接或者突变）</p><p>也许你有一个可能存在的构象的概念，你想在试验之前进行计算检查。 在这种情况下，尝试使用约束您感兴趣的构象，以查看系统是否可以适应它。 如果你淘汰那些仍然没有你想要的互动模式，或者只能通过非常别扭的几何来实现它，那么FloppyTail就会产生一个负面结果。</p><p>如果你拥有实验结果-非常棒！约束想要走的路子。运行约束，你将获得更高质量的模型假设。或者，可以使用约束来过滤不受限制的结果，或者只是使用它们来判断模型总体是否现实。这使您可以生成系统可能执行的与您的约束条件一致的“信封”，可根据需要将其用于进一步的实验循环。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>该算法非常简单：在质心模式下，小/剪切/碎片移动将尾部折叠成某种形式的折叠构型，而小/剪切随重新包装而移动以改善其位置。 这在概念上类似于abinitio折叠的工作方式，虽然它不是为此目的而精炼的</p><p>该代码与质心阶段中的约束兼容（通过命令行传入）。 早期的建模使用约束和一些小小的黑科技来帮助指导模型到假设的尾结合位置。 最终，这对于原始系统来说不是必需的，但代码保留了使用约束等的能力。<strong> 更新</strong>：代码与两个阶段的约束兼容。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>该代码无法进行“半-从头建模”的工作，即知道一半的结构，求另一半。改代码仅测试用于构建真实情况下是松软，无序的尾巴。该代码的目的并不是折叠进精炼结构。</p><p>如果想要实现上述不能实现的目的，可以考虑使用<a href="https://www.rosettacommons.org/docs/latest/scripting_documentation/TopologyBroker/BrokeredEnvironment" target="_blank" rel="external">Topology Broker</a>‘s 的<a href="https://www.rosettacommons.org/docs/latest/scripting_documentation/TopologyBroker/ClientMovers" target="_blank" rel="external">RigidChunk</a>环境。</p><h2 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h2><p>可以在<code>tests/integration/tests/FloppyTail/</code>查看例子</p><ul><li>首先需要处理PDB文件，删除杂原子，多重定义原子和水等等</li><li>该代码不会为您扩展添加。 您需要为灵活的尾部添加起始坐标（虽然无意义).把它直接指向空间（就像它在演示中一样）。 或者，使用PyRosetta脚本 <code>/ pyrosetta / public/floppy_tail_utility/</code>,可以更新输入结构（存在无序残基）这样可以扩展或者增加尾部（那样你就无需添加尾部起始坐标）。</li><li><a href="https://www.rosettacommons.org/docs/latest/rosetta_basics/file_types/fragment-file" target="_blank" rel="external">fragment file </a>和<a href="https://www.rosettacommons.org/docs/latest/rosetta_basics/file_types/constraint-file" target="_blank" rel="external">constraint file </a>查看怎么输入和约束</li></ul><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>也可以进行两个区域之间的内部柔性区域的建模</p><ul><li>如果需要构建大的尾部，需要进行长时间的轨迹模拟，2.3Hz的电脑大约完成30000/天 轨迹</li><li>约束条件是一种极好的方式，可以使建模偏向于测试假设的构想是否可行。</li><li>如果不是重复文献不要运行<code>-publication</code>标签</li><li>在建模终端柔性区域（尾部）时，在细化阶段，可以使用<code>short_tail_xxx</code>选项将协议引导为针对部分精化模式对尾部的较短部分建模。 原因在于，即使重新包装（质心往往对于这种对接来说有点太小），在质心模式下的结构中尾部可能与结合伴侣过于接近。 通过在改进的第一部分重塑尾巴的尖端，您可以放松碰撞而不将尾巴摆回太空。</li><li>如果您有单链（一种蛋白质），如果灵活区域比C端更接近N端，可以使用<code>C_root</code>选项来加快计算速度。</li><li>如果构建N端尾，必须使用<code>C_root</code>设置</li><li>使用<code>force_linear_fold_tree</code>，当你需要进行折叠C到N之间的链</li></ul><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="FloppyTail设置"><a href="#FloppyTail设置" class="headerlink" title="FloppyTail设置"></a>FloppyTail设置</h3><table><thead><tr><th>参数</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td><code>-flexible_start_resnum</code></td><td>-integer</td><td>PDB中的柔性尾起始编号，如果使用，那么同时要求<code>-flexible_chain</code>的设置</td></tr><tr><td><code>flexible_stop_resnum</code></td><td>-integer</td><td>不使用此选项意味着flexible_start_resnum之后的整个链。如果使用，那么同时要求<code>-flexible_chain</code>的设置</td></tr><tr><td><code>-flexible_chain</code></td><td>- string</td><td>该字符串的第一个字符被解释为灵活区域的PDB链; 任何其他字符都将被忽略。</td></tr><tr><td><code>-shear_on</code></td><td>- real</td><td>在质心模式下，当尾部仍大部分延伸时，剪切移动在初期完全无效。 该值给出剪切移动允许时的质心周期分数。例如，传递0.333意味着对于质心模式的前三分之一，剪切移动将被禁止。</td></tr><tr><td><code>-short_tail::short_tail_fraction</code></td><td>-real</td><td>Fraction of the tail used in the short tail fraction of refinement mode. 0.1 would mean the last tenth of the tail is flexible. Not compatible with non-terminal flexible regions.</td></tr><tr><td><code>-short_tail::short_tail_off</code></td><td>-real</td><td>Fraction of refinement cycles dedicated to refining only the short part of the tail. 0.33 means the first third of refinement cycles will be with the shorter flexible region.</td></tr><tr><td><code>-pair_off</code></td><td>- boolean</td><td>如果为真，关闭静电Epair，一般不用</td></tr><tr><td><code>-publication</code></td><td>- boolean</td><td>一般不用</td></tr><tr><td><code>-FloppyTail::cen_weights</code></td><td>- string</td><td>使用自定义质心得分函数，对于质心建模时期，一般不用</td></tr></tbody></table><h3 id="Kinematics设置"><a href="#Kinematics设置" class="headerlink" title="Kinematics设置"></a>Kinematics设置</h3><table><thead><tr><th>参数</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td><code>-C_root</code></td><td>- boolean</td><td>如果为真，重构C端折叠树，如果构建N端尾时使用</td></tr><tr><td><code>-force_linear_fold_tree</code></td><td>- boolean</td><td>强制线性折叠树。 如上所述使用C_root并重新排序输入PDB中的链，以确保正确的运动。</td></tr></tbody></table><h3 id="蒙特卡罗采样设置"><a href="#蒙特卡罗采样设置" class="headerlink" title="蒙特卡罗采样设置"></a>蒙特卡罗采样设置</h3><table><thead><tr><th>参数</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td><code>-FloppyTail::perturb_temp</code></td><td>-real</td><td>Monte Carlo temperature for perturb phase (0.8 used for production)</td></tr><tr><td><code>-FloppyTail::perturb_cycles</code></td><td>-unsigned integer</td><td>number of perturb phase cycles (5000 used for production)</td></tr><tr><td><code>-FloppyTail::perturb_show</code></td><td>-boolean</td><td>- if true, outputs centroid poses after perturbation</td></tr><tr><td><code>-FloppyTail::debug</code></td><td>-debug</td><td>- if true, outputs poses for each monte carlo cycle</td></tr><tr><td><code>-FloppyTail::refine_temp</code></td><td>-real</td><td>Monte Carlo temperature for refine phase (0.8 used for production)</td></tr><tr><td><code>-FloppyTail::refine_cycles</code></td><td>-unsigned integer</td><td>number of refine phase cycles (3000 used for production)</td></tr><tr><td><code>-FloppyTail::refine_repack_cycles</code></td><td>-unsigned interger</td><td>Perform a repack/minimize every N cycles of refine mode (30 used for production)</td></tr></tbody></table><h3 id="一般设置"><a href="#一般设置" class="headerlink" title="一般设置"></a>一般设置</h3><table><thead><tr><th>参数</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td><code>-packing::resfile</code></td><td>-string</td><td><a href="https://www.rosettacommons.org/docs/latest/rosetta_basics/file_types/resfiles" target="_blank" rel="external">Resfile</a>文件</td></tr><tr><td><code>-packing::repack_only</code></td><td>-boolean</td><td>告诉代码不要执行设计。 设计是默认执行的，因为PackerTasks的行为就是这样。</td></tr><tr><td><code>-in::file::frag3</code></td><td>-string</td><td>片段文件</td></tr><tr><td><code>-run::min_type</code></td><td>-string</td><td>Minimizer type. dfpmin_armijo_nonmonotone used for production.</td></tr><tr><td><code>-nstruct</code></td><td>-integer</td><td>生成的结构数量</td></tr><tr><td><code>-constraints::cst_file</code></td><td>-string</td><td>约束文件（质心）</td></tr><tr><td><code>-constraints::cst_weight</code></td><td>-real</td><td>约束权重（质心）</td></tr><tr><td><code>-constraints::cst_fa_file</code></td><td>-string</td><td>约束文件（全原子）</td></tr><tr><td><code>-constraints::cst_cst_fa_weight</code></td><td>-real</td><td>顾名思义</td></tr></tbody></table><h2 id="多柔性linkers模式"><a href="#多柔性linkers模式" class="headerlink" title="多柔性linkers模式"></a>多柔性linkers模式</h2><p>略，主要使用movemap</p><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>你可能是使用这个模型进行未知结构区域的建模。你不应该花大量的时间在单独的结构中。</p><p>一般而言，您应该选择模型预测的一些指标（如果您阅读论文，您会发现它是后来发现可化学交联的两个残基之间的距离）。 然后，您可以挖掘模型群体，以查看这个指标在模型的最高分数中的样子。 <code>extra_analysis</code>功能将有助于此。 我建议直方图。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/Rosetta/main/source/bin/FloppyTail..mpi.linuxgccrelease: </div><div class="line">error while loading shared libraries: libsqlite3.so: </div><div class="line">cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure><p>如报这样的错误，ubuntu用户可以使用如下解决:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libsqlite3-dev</div></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="原例子"><a href="#原例子" class="headerlink" title="原例子"></a>原例子</h3><p>位于<br><code>rosetta/main/tests/integration/tests/FloppyTail/</code><br> 可以打开查看pdb文件<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/4/t-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br> 直接运行即可结果如下:<br>  <img src="/images/2018/4/t-2.png" alt=""><br>  数据库修正以后<br>  <img src="/images/2018/4/t-3.png" alt=""><br>其设置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">-restore_talaris_behavior </div><div class="line"></div><div class="line">#输入 PDB</div><div class="line">-s complex_readytail_final_nozn.pdb.gz</div><div class="line"></div><div class="line">-use_input_sc</div><div class="line"></div><div class="line">-packing:repack_only</div><div class="line"></div><div class="line">#最小化类型</div><div class="line">-run:min_type dfpmin_armijo_nonmonotone</div><div class="line"></div><div class="line">#尾部起始点</div><div class="line">-FloppyTail:flexible_start_resnum 180</div><div class="line">#尾部终止点，因为终止到最后，所以不需要</div><div class="line">#-FloppyTail:flexible_stop_resnum </div><div class="line">#加尾链</div><div class="line">-FloppyTail:flexible_chain C</div><div class="line">#used for preventing loss of compactness at centroid/fa switch; see documentation</div><div class="line">-FloppyTail:short_tail:short_tail_off 0</div><div class="line">-FloppyTail:short_tail:short_tail_fraction 1.0</div><div class="line"></div><div class="line">#见文档</div><div class="line">-FloppyTail:shear_on .33333333333333333333</div><div class="line"></div><div class="line">#将其关闭以用于其他用途; 激活为设置出版物相关指标</div><div class="line">-FloppyTail:publication true</div><div class="line"></div><div class="line">#repacking频率; 10 一般用于测试</div><div class="line">#-FloppyTail:refine_repack_cycles 100</div><div class="line">-FloppyTail:refine_repack_cycles 10</div><div class="line"></div><div class="line">#最终产出数量</div><div class="line">#-FloppyTail:perturb_cycles 5000</div><div class="line">#-FloppyTail:refine_cycles 3000</div><div class="line">#-nstruct 5000</div><div class="line"></div><div class="line">#runs in 26 seconds on my machine</div><div class="line">-FloppyTail:perturb_cycles 100</div><div class="line">-FloppyTail:refine_cycles 20</div><div class="line">-nstruct 1</div></pre></td></tr></table></figure></p><p>具体内容可以参考文献3.的支撑材料</p><h3 id="E-Coli-Hfq-例子"><a href="#E-Coli-Hfq-例子" class="headerlink" title="E.Coli Hfq 例子"></a><em>E.Coli</em> Hfq 例子</h3><ol><li>首先获得<em>E.Coli</em>的晶体结构</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://www.rcsb.org/pdb/files/1HK9.pdb</div></pre></td></tr></table></figure><ol><li>删除非ATOM的行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep ATOM 1hk9.pdb &gt; 1hk9.clean.pdb</div></pre></td></tr></table></figure><p>在这里需要安装<code>PyRosetta</code>，安装步骤和简单介绍可以查看<a href="http://kangsgo/36.html" target="_blank" rel="external">这里</a></p><ol><li>在<code>PyRosetta</code>里的<code>apps/floppy_tail_utility</code>路径里的所有脚本拷贝到实验路径下，<code>extend_terminus.py</code>脚本附加(append)/前置增加(prepend)端口序列。残基设置的φ/ψ值为-135°/135°。例如前置增加”MAKGQ”到链A的N端，命令如下:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python extend_terminus.py –c A –o 1hk9.Ap.pdb –p 1hk9.clean.pdb MAKGQ</div></pre></td></tr></table></figure><p>脚本参数包含如下:<br> a.  <code>-c</code> 标签选择链<br> b.  <code>-p</code>为N端,<code>-a</code>为C端输入文件<br> c. <code>-o</code>为输出文件<br> d. <code>MAKGQ</code>为我输入的序列</p><ol><li><p><code>convert_to_beta.py</code>主要是用来转换骨架二面角到理想状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python convert_to_beta.py –i 1hk9.pdb –s 65 –c –o 1hk9.extend.pdb --</div><div class="line">publication-specific</div></pre></td></tr></table></figure><p><code>--publication-specific</code>标志可以用来应用来自大肠杆菌Hfq结构（残基65-70）的二面角而不是理想的角度。<code>-c</code>和<code>-n</code>分别表示c端和n端。<code>-s</code>表示起始残基序列,<code>-o</code>为输出。</p></li><li><p>通过Rosetta进行“relaxed”</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ROSETTA3</span>/bin/relax.mpi.linuxgccrelease @option</div></pre></td></tr></table></figure><p>option设置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-s 1hk9.extend.pdb </div><div class="line">-relax:constrain_relax_to_start_coords </div><div class="line">-relax:ramp_constraints false </div><div class="line">-ex1 </div><div class="line">-ex2 </div><div class="line">-use_input_sc </div><div class="line">-flip_HNQ </div><div class="line">-no_optH false </div><div class="line">-relax:min_type lbfgs_armijo_nonmonotone </div><div class="line">-nstruct 1</div></pre></td></tr></table></figure></p><p>在这里简单介绍一下设置:<br><code>-s</code>为输入文件<br><code>-relax:constrain_relax_to_start_coords</code>和<code>-relax:ramp_constraints false</code>为特定输入结构所需要的，为设置主干原子约束，并且关闭约束ramp<br><code>-ex1</code>和<code>-ex2</code>使第一和第二侧链二面角的采样增加一个标准偏差<br> <code>-use_input_sc</code>包括放松过程中取样的旋转异构体中的晶体学侧链构象。<br> <code>-flip_HNQ</code>测试侧链组氨酸，天冬酰胺和谷氨酰胺中特定原子的替代配置（其不能在电子密度中区分）。<br> <code>-no_optH false</code>关闭氢原子优化<br> <code>-relax:min_type</code>最小化算法<br> <code>-nstruct 1</code>输出结构数量</p><p> 正式的执行FloppyTail，其使用的为<code>movemap.txt</code>,设置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># input</div><div class="line">-s 1hk9.relax.pdb</div><div class="line"># define flexible region via movemap file</div><div class="line">-movemap movemap.txt</div><div class="line"># shear moves are not productive initially so no shear</div><div class="line"># for the first 1/3 of the simulation</div><div class="line">-FloppyTail::shear_on 0.333</div><div class="line"># root the fold tree at the center of mass, so</div><div class="line"># we can “flop” both termini simultaneously</div><div class="line">-FloppyTail::COM_root</div><div class="line"># do not change AA identities during packing</div><div class="line">-packing::repack_only</div><div class="line"># monte carlo and sampling options</div><div class="line">-FloppyTail::perturb_temp 0.8</div><div class="line">-FloppyTail::perturb_cycles 100000 # ~500 moves per residue</div><div class="line">-FloppyTail::refine_temp 0.8</div><div class="line">-FloppyTail::refine_cycles 1000</div><div class="line">-FloppyTail::refine_repack_cycles 10</div><div class="line"># current best practices for minimization/scoring</div><div class="line">-run::min_type lbfgs_armijo_nonmonotone</div><div class="line">-score::weights talaris2014</div><div class="line"># recommended number of structures to model</div><div class="line">-nstruct 30000</div><div class="line"># output</div><div class="line">-out:path:pdb decoys/</div><div class="line">-out:pdb_gz</div></pre></td></tr></table></figure></p><p> 其movemap定义如下:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> RESIDUE * CHI # repack only, default for all</div><div class="line">JUMP * NO # do not move subunits relative to one another</div><div class="line"># chain A</div><div class="line">RESIDUE 1 5 BBCHI</div><div class="line">RESIDUE 65 102 BBCHI</div><div class="line"># chain B</div><div class="line">RESIDUE 103 107 BBCHI</div><div class="line">RESIDUE 167 204 BBCHI</div><div class="line"># chain C</div><div class="line">RESIDUE 205 209 BBCHI</div><div class="line">RESIDUE 269 306 BBCHI</div><div class="line"># chain D</div><div class="line">RESIDUE 307 311 BBCHI</div><div class="line">RESIDUE 371 408 BBCHI</div><div class="line"># chain E</div><div class="line">RESIDUE 409 413 BBCHI</div><div class="line">RESIDUE 473 510 BBCHI</div><div class="line"># chain F</div><div class="line">RESIDUE 511 515 BBCHI</div><div class="line">RESIDUE 575 612 BBCHI</div></pre></td></tr></table></figure></p><p> 其中CHI表示侧链可以动，BB表示骨架可以动，下面的默认会覆盖上面的.注意测试不要按照上面的设置跑，720核需要跑48小时。</p><h3 id="一篇PNAS的方法"><a href="#一篇PNAS的方法" class="headerlink" title="一篇PNAS的方法"></a>一篇PNAS的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./FloppyTail.mpi.linuxgccrelease</div><div class="line">-database /path/to/main/database</div><div class="line">-s 7AHL_SpyTAG_phi29_SpyCatch_assemble_repacked.pdb</div><div class="line">-nstruct 5000</div><div class="line">-in:file:movemap movemap_file</div><div class="line">-packing:repack_only</div><div class="line">-AnchoredDesign:refine_repack_cycles 30</div><div class="line">-AnchoredDesign:perturb_cycles 15000</div><div class="line">-AnchoredDesign:refine_cycles 3000</div></pre></td></tr></table></figure><p>move_map文件参考:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RESIDUE 2052 2060 BBCHI</div><div class="line">RESIDUE 2638 2650 BBCHI</div></pre></td></tr></table></figure><p>参考资料:</p><ol><li><a href="https://www.rosettacommons.org/docs/latest/application_documentation/structure_prediction/floppy-tail" target="_blank" rel="external">FloppyTail application</a></li><li><a href="https://www.rosettacommons.org/node/9706" target="_blank" rel="external">fragment_picker.mpi.linuxgccrelease can’t find : libsqlite3.so</a></li><li>Kleiger G, Saha A, Lewis S, Kuhlman B, Deshaies RJ. Rapid E2-E3 assembly and disassembly enable processive ubiquitylation of cullin-RING ubiquitin ligase substrates. Cell. 2009 Nov 25;139(5):957-68. PubMed PMID: 19945379.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载请联系，且保留链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这个代码需要蛋白具有长的柔性尾，在晶体结构中是缺失的，生物化学证据表明已知结合伴侣上尾部的特定结合位点.该代码旨在模拟长柔性尾巴的范围并确定假设的结合位点是否合理。&lt;/p&gt;
&lt;p&gt;该工具更有用于测试
      
    
    </summary>
    
      <category term="蛋白建模" scheme="http://kangsgo.com/categories/%E8%9B%8B%E7%99%BD%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="Rosetta" scheme="http://kangsgo.com/tags/Rosetta/"/>
    
  </entry>
  
  <entry>
    <title>Rosetta系列-PyRosetta安装</title>
    <link href="http://kangsgo.com/36.html"/>
    <id>http://kangsgo.com/36.html</id>
    <published>2018-04-10T10:27:12.000Z</published>
    <updated>2018-04-11T02:31:50.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载请联系，且保留链接</strong></p><p>PyRosetta是一个Python为基础的Rosetta交互套件。其打开了用户自定义的利用Rosetta采样方法和能量函数进行自定义建模的方法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="http://www.pyrosetta.org/dow" target="_blank" rel="external">下载页面</a>选择合适的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#解压</span></div><div class="line">tar -vjxf PyRosetta-&lt;version&gt;.tar.bz2.</div><div class="line"></div><div class="line"><span class="comment"># 移动位置</span></div><div class="line">mv PyRosetta&lt;version&gt; PyRosetta4</div><div class="line"></div><div class="line"><span class="comment"># 进入</span></div><div class="line"><span class="built_in">cd</span> PyRosetta4</div><div class="line"></div><div class="line"><span class="comment">#安装</span></div><div class="line"><span class="built_in">cd</span> setup &amp;&amp;  python setup.py install</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载请联系，且保留链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PyRosetta是一个Python为基础的Rosetta交互套件。其打开了用户自定义的利用Rosetta采样方法和能量函数进行自定义建模的方法。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安
      
    
    </summary>
    
      <category term="蛋白建模" scheme="http://kangsgo.com/categories/%E8%9B%8B%E7%99%BD%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="Rosetta" scheme="http://kangsgo.com/tags/Rosetta/"/>
    
  </entry>
  
  <entry>
    <title>PLUMED系列-安装教程</title>
    <link href="http://kangsgo.com/29.html"/>
    <id>http://kangsgo.com/29.html</id>
    <published>2018-04-08T10:26:12.000Z</published>
    <updated>2018-04-08T05:14:59.061Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载请联系，且保留链接</strong></p><p>PLUMED是许多分子动力学模拟包的插件，主要能进行MD的增强采样或者执行非常多的自由能计算方法。 可以使用诸如元动力学，伞形采样和基于 Jarzynski 方程的转向 MD 之类的现有技术来执行自由能计算作为许多次序参数的函数，特别关注生物学问题。模拟的高分文章很多运用了该工具。</p><p>下载地址如下:<br><a href="https://drive.google.com/file/d/1iZNAMXLlZUDmit19uGJDXa6GJlqfd5ip/view" target="_blank" rel="external">plumed-2.4.1</a></p><h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>如果你迫不及待的想练手，可以通过如下方法简单野蛮式安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/<span class="built_in">local</span></div><div class="line">make -j 4</div><div class="line">make doc</div><div class="line">make install</div></pre></td></tr></table></figure></p><p>由于PLUMED需要分析额外的轨迹，同时运行Lennard-Jones 代码，所以需要对模拟的软件进行打补丁，简单的方法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /md/root/dir</div><div class="line">plumed patch -p</div></pre></td></tr></table></figure></p><p>当然还是建议按照下面的一步一步的来:</p><h2 id="推荐安装"><a href="#推荐安装" class="headerlink" title="推荐安装"></a>推荐安装</h2><h3 id="安装BLAS与LAPACK"><a href="#安装BLAS与LAPACK" class="headerlink" title="安装BLAS与LAPACK"></a>安装BLAS与LAPACK</h3><p>安装PLUMED依赖的<code>blas</code>和<code>lapack</code>包。(虽然PLUMED自带这两个包，但是网站上说为了性能建议自己编译，未测试自己编译使用和使用自带的性能差异)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在用户主目录下src下操作</span></div><div class="line">mkdir ~/src</div><div class="line"><span class="built_in">cd</span> ~/src</div></pre></td></tr></table></figure></p><h4 id="安装BLAS"><a href="#安装BLAS" class="headerlink" title="安装BLAS"></a>安装BLAS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http://www.netlib.org/blas/blas.tgz</div><div class="line">tar zxf blas.tgz</div><div class="line"><span class="comment"># 可能版本有差别</span></div><div class="line"><span class="built_in">cd</span> BLAS-3.8.0/</div><div class="line"></div><div class="line"><span class="comment"># 编译</span></div><div class="line">gfortran -O3 -std=legacy -m64 -fno-second-underscore -fPIC -c *.f</div></pre></td></tr></table></figure><p> 后续工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">ar r libfblas.a *.o</div><div class="line">ranlib libfblas.a</div><div class="line">rm -rf *.o      <span class="comment"># 清理文件</span></div><div class="line"><span class="built_in">export</span> BLAS=~/src/BLAS-3.8.0/libfblas.a <span class="comment"># 导出BLAS环境变量</span></div></pre></td></tr></table></figure></p><h4 id="安装LAPACK"><a href="#安装LAPACK" class="headerlink" title="安装LAPACK"></a>安装LAPACK</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://www.netlib.org/lapack/lapack.tgz</div><div class="line">tar zxf lapack.tgz</div><div class="line"><span class="comment"># 可能版本有差别</span></div><div class="line"><span class="built_in">cd</span> lapack-3.8.0/</div></pre></td></tr></table></figure><p>编译:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp INSTALL/make.inc.gfortran make.inc</div></pre></td></tr></table></figure></p><p>编辑make.inc文件，大致修改为如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FORTRAN = gfortran</div><div class="line">OPTS    = -O2 -frecursive -fPIC -m64</div><div class="line">DRVOPTS = $(OPTS)</div><div class="line">NOOPT   = -O0 -frecursive -fPIC -m64</div><div class="line"></div><div class="line">#  Define LOADER and LOADOPTS to refer to the loader and desired</div><div class="line">#  load options for your machine.</div><div class="line">#</div><div class="line">LOADER   = gfortran</div><div class="line">LOADOPTS =</div></pre></td></tr></table></figure></p><p>编译:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make lapacklib</div></pre></td></tr></table></figure></p><p>后续工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make clean      <span class="comment"># 清理文件</span></div><div class="line"><span class="built_in">export</span> LAPACK=~/src/lapack-3.8.0/   <span class="comment"># 导出LAPACK环境变量</span></div></pre></td></tr></table></figure></p><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar xzf plumed-2.4.1.tgz</div><div class="line"><span class="built_in">cd</span> plumed-2.4.1</div></pre></td></tr></table></figure><p>完整的参数可以使用如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --<span class="built_in">help</span></div></pre></td></tr></table></figure></p><ol><li><p>官方建议安装在默认预定义位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure </div><div class="line">sudo make -j 4</div><div class="line">make check</div><div class="line">sudo make install</div></pre></td></tr></table></figure></li><li><p>当然也可以修改路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure  --prefix=$HOME/opt</div><div class="line">make -j 4 #核数</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure></li></ol><p>设置环境变量:安装后有设置环境变量提示，里面说直接运行如下tcl脚本即可，但我尝试了未成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">To create a tcl module that sets all the variables above, use this one as a starting point:</div><div class="line">@patch/plumed/modulefile</div></pre></td></tr></table></figure></p><p>我使用的设置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># plumed</div><div class="line"># PLUMED2_HOME内容需要修改成自己的</div><div class="line">export PLUMED2_HOME=/to/pacth/plumed</div><div class="line">export PATH=$PLUMED2_HOME/bin:$PATH</div><div class="line">export LD_LIBRARY_PATH=$PLUMED2_HOME/lib:$LD_LIBRARY_PATH</div><div class="line">export PKG_CONFIG_PATH=$PLUMED2_HOME/pkgconfig:$PKG_CONFIG_PATH</div><div class="line">export PLUMED_VIMPATH=$PLUMED2_HOME/vim:$PLUMED_VIMPATH</div><div class="line">export INCLUDE=$PLUMED2_HOME/include:$INCLUDE</div><div class="line"># 若开启了时间计算，需要增加</div><div class="line">export PLUMED_USE_LEPTON=yes</div></pre></td></tr></table></figure></p><p>仅供参考</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>在plumed的安装目录执行如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make uninstall</div></pre></td></tr></table></figure></p><h3 id="更新MD包"><a href="#更新MD包" class="headerlink" title="更新MD包"></a>更新MD包</h3><p>现在plumed默认支持如下包(还有一些可以靠插件解决，详情见官网):</p><ul><li>amber14</li><li>gromacs-2016-5</li><li>gromacs-2018-1</li><li>gromacs-4-5-7</li><li>gromacs-5-1-4</li><li>lammps-6Apr13</li><li>namd-2-8</li><li>namd-2-9</li><li>qespresso-5-0-2</li><li>qespresso-6-2</li></ul><p>方法很简单，在MD<strong>安装</strong>的<strong>根目录</strong>，执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plumed patch -p</div></pre></td></tr></table></figure></p><p>!!!!之前安装的话需要重新安装!!!!</p><p>在这里简单介绍gromacs的重新安装,具体可以查看<a href="http://kangsgo.com/31.html">之前的文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cmake .. -DGMX_BUILD_OWN_FFTW=ON -DGMX_GPU=ON -DGMX_MPI=ON -DCMAKE_INSTALL_PREFIX=/home/yaolab/install/gromacs</div><div class="line">make -j 4</div><div class="line">make check</div><div class="line">make install</div></pre></td></tr></table></figure></p><p>最后设置环境变量</p><h3 id="安装中可能遇到的问题"><a href="#安装中可能遇到的问题" class="headerlink" title="安装中可能遇到的问题"></a>安装中可能遇到的问题</h3><ul><li>./configure 时有可能出现如下警告:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WARNING: You might have problems linking FORTRAN programs.</div></pre></td></tr></table></figure></li></ul><p>但是这个警告是没有关系的，除非你想通过FORTRAN来进行<code>plumed patch --static</code>，那么可以使用参考资料7来进行解决.一般情况下是不需要修改的</p><p>简单的总结解决办法就是搜索:<code>libstdc++.so</code>或者<code>libc++.so</code>,在编译的时候设置:<code>LDFLAGS=-L@path</code>其中@path为路径</p><ul><li>注意:若mpi为自己安装在自己的用户目录的话，那么<code>sudo mpic++</code>可能会提示找不到，那样的话需要<code>sudoers</code>中增加你的openmpi路径，例如我的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/kangsgo/install/openmpi/bin/</div></pre></td></tr></table></figure></li></ul><p>具体可以参考参考资料2-5</p><ul><li>我在执行<code>make check</code>时结果如下:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/4/p-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>我认为是正常的，因为部分模块默认是没有编译的,具体可以参考参考资料8</p><p>参考资料:</p><ol><li><a href="https://www.jianshu.com/p/fe6c4f42aa0b" target="_blank" rel="external">编译安装BLAS和LAPACK</a></li><li><a href="https://groups.google.com/forum/#!topic/plumed-users/KLvfVyUtFJI" target="_blank" rel="external">mpic++ command not found</a></li><li><a href="http://ghoulich.xninja.org/2017/05/09/how-to-find-env-variables-when-exec-sudo-commands/" target="_blank" rel="external">如何解决sudo命令找不到环境变量的问题</a></li><li><a href="https://blog.csdn.net/my_bai/article/details/78224605" target="_blank" rel="external">sudo 环境变量继承和详解</a></li><li><a href="http://blog.sina.com.cn/s/blog_4da051a60102uyvg.html" target="_blank" rel="external">sudo执行脚本找不到变量</a></li><li><a href="http://mrzhenggang.com/gromacs-install-with-plumedl/" target="_blank" rel="external">gromacs + plumed 编译安装教程</a></li><li><a href="https://groups.google.com/forum/#!topic/plumed-users/y8BniXuSdHw" target="_blank" rel="external">Trouble compiling PLUMED 2.4.0 on Linux (Ubuntu 14.04.5)</a></li><li><a href="https://plumed.github.io/doc-v2.4/user-doc/html/mymodules.html" target="_blank" rel="external">List of modules</a></li><li><a href="https://groups.google.com/forum/#!msg/plumed-users/S45nXdZ-wNg/8axN0MQPAQAJ" target="_blank" rel="external">“plumed –has-matheval” with lepton</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载请联系，且保留链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PLUMED是许多分子动力学模拟包的插件，主要能进行MD的增强采样或者执行非常多的自由能计算方法。 可以使用诸如元动力学，伞形采样和基于 Jarzynski 方程的转向 MD 之类的现有技术来执行自由能
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Gromacs" scheme="http://kangsgo.com/tags/Gromacs/"/>
    
      <category term="PLUMED" scheme="http://kangsgo.com/tags/PLUMED/"/>
    
  </entry>
  
  <entry>
    <title>自动化之Pexpect</title>
    <link href="http://kangsgo.com/28.html"/>
    <id>http://kangsgo.com/28.html</id>
    <published>2018-03-21T05:09:30.000Z</published>
    <updated>2018-03-22T11:02:52.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近发现做了很多模拟，但是一些常规分析每次都需要进行查阅，套路化计算，我在想为何不能自动化每次模拟完自动执行一下呢？之前写了一个shell脚本的，现在看起来非常不高级，而且时间久了就会忘记，磨刀不误砍柴工，所以最近粗略的学习了Python自动化运维常用的两个模块，<code>Pexpect</code>和<code>psutil</code>，在这里简单介绍一下。</p></blockquote><h2 id="Pexpect简介"><a href="#Pexpect简介" class="headerlink" title="Pexpect简介"></a>Pexpect简介</h2><p>Pexpect是一个终端自动交互python模块，十分易于上手</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装可以通过pip或者conda，适用版本为Python2.7或者Python3.3以上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pexpect</div></pre></td></tr></table></figure></p><h3 id="简单使用说明"><a href="#简单使用说明" class="headerlink" title="简单使用说明"></a>简单使用说明</h3><p>其实使用方法在简书的<a href="https://www.jianshu.com/p/cfd163200d12" target="_blank" rel="external">Pexpect 模块使用说明</a>总结的非常好，这里仅做快速简要介绍</p><h4 id="spawn-执行程序"><a href="#spawn-执行程序" class="headerlink" title="spawn() - 执行程序"></a>spawn() - 执行程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行linux命令，返回的为结果</span></div><div class="line">pexpect.spawn(command, args=[], timeout=<span class="number">30</span>,  logfile=<span class="keyword">None</span>, cwd=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数里面我列了几个觉得很重要的内容，一个是<code>timeout</code>表示等待时间,<code>logfile</code>表示写入的日志文件,<code>cwd</code>表示根目录</p><h4 id="expect-关键字匹配"><a href="#expect-关键字匹配" class="headerlink" title="expect() - 关键字匹配"></a>expect() - 关键字匹配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 正则匹配输出</span></div><div class="line">expect(pattern, timeout=<span class="number">-1</span>, searchwindowsize=<span class="number">-1</span>, async_=<span class="keyword">False</span>, **kw)</div></pre></td></tr></table></figure><p>匹配后会返回值，若匹配的是一个字符串，匹配到了会返回0,若为一个列表，则匹配到了的话，会定位到列表的第几个关键字，从0开始计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect_loop(self, searcher, timeout=-1, searchwindowsize=-1)</div></pre></td></tr></table></figure><p>用于从标准输入中获取内容，loop这个词代表它会进入一个循环，必须要从标准输入中获取到关键字才会往下继续执行。</p><h4 id="send-发送关键字"><a href="#send-发送关键字" class="headerlink" title="send() -发送关键字"></a>send() -发送关键字</h4><p>其实相当于Shell中<code>echo -e</code>，我感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 发送</span></div><div class="line">send()</div><div class="line"><span class="comment"># 发送加空格</span></div><div class="line">sendlines()</div><div class="line"><span class="comment"># 发送但没有返回值</span></div><div class="line">write()</div><div class="line"><span class="comment"># 发送包含字符串的列表</span></div><div class="line"><span class="comment"># 类似于 write() 命令，只不过接受的是一个字符串列表，</span></div><div class="line"><span class="comment"># writelines() 会向子程序一条一条的发送列表中的元素，</span></div><div class="line"><span class="comment">#但是不会自动在每个元素的最后加上回车换行符。</span></div><div class="line">writelines()</div><div class="line"><span class="comment"># 发送特殊字符，例如Ctrl-G</span></div><div class="line">sendcontrol(<span class="string">'g'</span>)</div></pre></td></tr></table></figure><h4 id="read-返回关键字"><a href="#read-返回关键字" class="headerlink" title="read() - 返回关键字"></a>read() - 返回关键字</h4><p>感觉应用不多<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 返回剩下的所有内容</span></div><div class="line">read() </div><div class="line"><span class="comment"># 返回一行输出</span></div><div class="line">readline()</div><div class="line"><span class="comment"># 返回列表模式的所有输出</span></div><div class="line">readlines()</div></pre></td></tr></table></figure></p><h4 id="控制子程序"><a href="#控制子程序" class="headerlink" title="控制子程序"></a>控制子程序</h4><p>一些对于执行程序的操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 杀死子程序</span></div><div class="line">kill()</div><div class="line"><span class="comment"># 查看是否存活</span></div><div class="line">isalive()</div><div class="line"><span class="comment"># 等待直到子程序退出</span></div><div class="line">wait()</div><div class="line"><span class="comment"># 关闭子程序</span></div><div class="line">close()</div><div class="line"><span class="comment"># 子程序进程</span></div><div class="line">pid</div></pre></td></tr></table></figure></p><h4 id="运行功能"><a href="#运行功能" class="headerlink" title="运行功能"></a>运行功能</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 运行linux命令，返回的为结果</span></div><div class="line">pexpect.run(command, args=[], timeout=<span class="number">30</span>,  logfile=<span class="keyword">None</span>, cwd=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>可能大家对<code>run()</code>和<code>spwan()</code>之间的区别很好奇，<code>run()</code>相比<code>spwan()</code>为等待命令完全完成，然后才会返回结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近发现做了很多模拟，但是一些常规分析每次都需要进行查阅，套路化计算，我在想为何不能自动化每次模拟完自动执行一下呢？之前写了一个shell脚本的，现在看起来非常不高级，而且时间久了就会忘记，磨刀不误砍柴工，所以最近粗略的学习了Python自动化运维
      
    
    </summary>
    
      <category term="Linux" scheme="http://kangsgo.com/categories/Linux/"/>
    
    
      <category term="自动化" scheme="http://kangsgo.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>马尔科夫状态模型模拟笔记</title>
    <link href="http://kangsgo.com/27.html"/>
    <id>http://kangsgo.com/27.html</id>
    <published>2018-03-16T05:09:30.000Z</published>
    <updated>2018-03-26T01:37:40.902Z</updated>
    
    <content type="html"><![CDATA[<p><strong>只是粗略翻译，未校正</strong></p><blockquote><p>此篇文章以RNA MD为舟，主要参考《<em>RNA Structural Dynamics As Captured by Molecular Simulations: A Comprehensive Overview</em>》一文3.2.3: Markov State Models一节。</p></blockquote><p>近年来，马尔科夫状态模型（Markov State Model，MSM）方法在增强采样中得到了广泛的运用，成为热门的增强采样方法之一。马尔科夫模型的方法优势在于它能够从很多短的模拟中获取长时间的动力学特征，可以不需要事先定义反应坐标，从而避免了对整个动力学性质的简化或者是偏差。特别是最近几年大规模的平行计算资源的发展，更加促进了这一方法的应用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/m-1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><p><strong>Fig 1</strong>. 马尔科夫状态模型, 广泛模拟分析,观察的状态被成簇聚类. 然后构建动力学矩阵，提供观察集群对之间转换的概率</p><p>在最近数十年，MSMs成为探索解释缓慢的生物分子复合物的运动并且其背后的理论日渐完善。MSM的工作流程简述如下:</p><p>1) MD数据聚集成一组有限的微观状态。每个微观状态均由许多结构组成，这些结构足够相似以至于在动力学项目中无法被区分。一个滞后时间,τ,被选为程序的时间离散化，并且在微观状态之间跃迁以对应滞后时间τ之间的步幅联系。</p><p>2) 来自MD的信息（在滞后时间窗中观察的转变）被用来构建一个跃迁几率矩阵,T，其元素,T<sub>ij</sub>,表示了系统的几率始于微状态j，在时间τ之后将会跃迁到微状态i（请注意，T矩阵通常以其转置形式使用，然后将索引i和j的含义互换。）</p><p>3) 系统在前面提到的微状态之间构建马尔科夫状态链，通过跃迁几率矩阵进行控制，因此时间t+τ时微观状态的概率分布仅取决于时间t时微观状态的分布，而不取决于系统的历史。换句话说，动力学模型之间是互不相关的进程，每个时间步骤τ，分子将会从一个微观状态“跳跃”到另外一个微观状态。</p><p>4) 分析矩阵T的特征值谱以提取关于系统的热力学，动力学和动力学的信息。</p><p>离散的MSM结果旨在近似通过离散的程序估算模拟系统连续的动态。使用MSM，在一个离散的时间步长τ中可以进化单独的随机轨迹（微观状态的时间轨迹，例如:一个时间离散化的对应MD轨迹）或者微观状态的概率分布。MSM可以近似的极端被精确；换句话说，其可以提供和MD模拟相同的时间发展快照。比较其他的增强采样方法，其可以获得更加长时间尺度的结果（和热交换或者CV-基础的方法作为比较，后面会有时间进行记录）。MSM可以提供的信息有系统的动态参数和感兴趣的参数之间的跃迁比率，然而当系统的动态具有倾向性时，关于这些属性的信息通常会丢失。MSM的跃迁矩阵的特征值(eigenvalues)与特征向量(eigenvectors)的解释如下:第一个跃迁矩阵的特征向量是单位特征值并对应平稳分布向量，即该微状态的平衡概率;其它特征向量描述的为平衡的松弛过程，以及其对应的特征值, λ <sub>i</sub>,相关的时间尺度,t<sub>i</sub>,通过公式t<sub>i</sub>=-τ/ln(λ<sub>i</sub>)进行降序排列。</p><p>MSM可以被广泛的用来帮助从一个长的MD轨迹中提取可阅读的信息,它反复和自发地对正在研究的罕见事件进行采样。如果模拟采样程序足够好，MSM可以被用来进行粗粒化模型的“创作”，为原始模拟数据提供非常需要的见解。或者，MSMs可以通过将所有轨迹跨越的集合进行离散化用来合并分隔的MD轨迹，并且计算在任何轨迹中的跃迁。这能够成为一个严格的结合信息，来自一个单质量模型的多个轨迹。</p><p>主要有两个手段来构建可信的MSM: i).将相空间的极其精细的离散化转化为微观状态 ii) 或者，以所谓的“中心(coring)”方法来计数对应于亚稳态的较大盆地之间的跃迁。 现在的研究一般使用第一种方法来解决。</p><p>构建MSM的第一步是将相空间离散化为微观状态。其可以通过使用不同的成簇方法和不同的标准进行完成。这一领域的一个重要进展是发展时滞独立成分分析( time-lagged independent component analysis,TICA).在这个方法中，输入变量的线性组合被构造以便找到具有最大自相关时间的自由度，并且因此预期在动力学分析中更重要。这使得后续的聚类可以在较低维度上完成，在主要TICA成分的空间中完成，通过模拟轨迹投影到最大的TICA成分上。TICA的方法和主成分分析(principal component analysis, PCA)方法较为相似(PCA方法也是MD轨迹分析的一个常用方法).PCA识别输入自由度与最高方差的线性组合，而TICA发现具有最高自相关时间的那些，即对应于模拟中发生的最慢过程。TICA可以从基于所有溶质原子的笛卡尔坐标的描述开始执行，或者使用在一些内部坐标上定义的描述，例如相关原子之间的二面角或配对距离.和其它降维方法相比，一个总需要当心的为一些重要的信息可能会被丢失，曲解快速时间尺度程序的描述。因为显著的结果被获取，TICA被推荐作为一个常规工具对于MD轨迹的坐标跃迁和降维.</p><p>将相空间离散化为有限个微态是MSM系统误差的主要来源.误差可以通过两个方式进行降低:增加滞时,τ，另一种方法为通过更加精细的离散化算法.在实践中，当处理非常精细长度的模拟，许多因素影响计算的质量。滞后时间本质上取决于系统的马尔可夫性和期望的时间分辨率.太短的滞时将会导致模型没有马尔可夫性。一般说来，与滞后时间相比，每个个体微观结构内的结构之间的相互转换必须是快速的.在蛋白和核酸体系中典型的τ值范围一般为0.1到10ns,通常通过观察隐含时间尺度的收敛来选择。具体描述如下:微观状态的数量应该足够大，以避免由于相位空间的粗糙化造成的分辨率损失，并且足够小对于有足够的数量以便于他们之间的跃迁（例如:拥有足够的统计学精度）并且矩阵大小是可控的。“中心”方法的运用是有差别的，其使用更加小的设置微态，其不需要覆盖系统完整的构象空间。</p><p>用现代方法模拟中等大小的生物分子，一个典型的使用MSMs方法至少需要10<sup>2</sup>到10<sup>4</sup>个微态。这种微观状态的数量使模型的可视化和直观分析变得不切实际。存在几种方法来克服这个问题，即利用MSM提供的动力学信息来构建系统的更粗略的表示，将MSM微观状态集合成少数亚稳态宏观状态.一个普遍使用的方法为Perron集群聚类分析(Perron-cluster cluster analysis,PCCA,更多信息可以通过<a href="http://blog.csdn.net/sky88088/article/details/51569863" target="_blank" rel="external">这里</a>还有<a href="http://docs.markovmodel.org/lecture_pcca.html" target="_blank" rel="external">这里</a>进行了解)一种利用转换矩阵的特征向量的符号结构来定义MSM微观状态的最佳亚稳分区的方法.称为PCCA +和PCCA ++的更高级版本的方法为每个微观状态指定了成为给定亚稳态宏观成员的概率。</p><p>另一种减少模型的方法成为隐式马尔科夫模型(hidden Markov model, HMM).在这种方法中，系统被表示为隐藏的亚稳态宏观事件之间的马尔可夫链.这些宏观不是直接可观察的，而是通过观察微观态来测量的，微观态在每一步都是从一个分布概率中提取的，这个分布概率依赖于隐藏的宏观态来进行的.因此，假定可以使用附加（隐藏）变量来标记状态，并且其时间序列由观测变量的时间序列推断。HMM定义的态没有整齐的边界，并且一个给定的构象有可能同时参与多个宏观事件.</p><p>MSM方法一个关键的优势是能够监测，其不必假设全局平衡，而是假设MD在每个微观状态为局部平衡。实际上，对于模拟通过选择小的起始点，可以获得组装的相关短的轨迹，每个采样跃迁和不同的复合物步骤和缓慢设置改变相关。通过在MSM模型中结合这些轨迹，原则上，甚至可以重构甚至比任何单个轨迹的跨度更长的时间尺度上发生的过程。最大隐含时间尺度可以为用于构建MSM的所有MD轨迹的总持续时间的<strong>相同数量级</strong>.显然，初始点的选择必须十分慎重，必须确保没有重要的相变区域被忽略。</p><p>用于构建MSM的MD模拟有许多方法选择起始点.如果有，关于系统的先验知识可以用来初始化沿着有趣的构象变化的不同位置的模拟(例如，实验结构拥有多个构象可用)，另一个方法是，新的模拟可以用来初始化成为一个“探索”模拟来获得新的感兴趣的构象。如果这个步骤在每次新的模拟中被递归地重复，它将产生MD级联的轨迹，对可用相空间的越来越大的区域进行采样.通过改变确定新轨迹的候选起始点的标准，可以沿着感兴趣的构象变化的路径驱动系统。这种方法通常被称为“自适应采样”，实际上它可以被视为增强采样技术的一个子类.另外一个强大的方法是初始结构从其它增强采样的方法中获得。</p><p>与所有旨在降低MD模拟计算成本的方法一样，MSM可能会以与其基本近似值和假设不一致的方式提供错误结果。因此，在从MSM得出任何结论之前，测试马尔可夫近似的有效性至关重要.这通常是通过观察隐含时间尺度t<sub>i</sub>的收敛来实现的，伴随着τ的值增大。隐含的时间尺度应该与马尔可夫系统中的τ无关，所以它们的收敛可以用来选择恰当的滞后时间（如果存在的话），这对应于真实动态的良好近似。指出以对数形式显示时间尺度的常见做法可能会由于对数函数的负凸性而给出收敛的错误印象。</p><p>重要的是要注意隐含时间尺度的收敛是马尔可夫性的一个必要但不充分的条件.当达到收敛时，最慢的隐含时间尺度应该对应于所研究系统中最慢的跃迁模式。它与以前的系统知识的比较可以提供一些关于全自由能景观是否被充分采样的提示。一个过短的隐含时间可能表示部分重要的自由能景观，在模拟数据集中完整的被缺失，MSM仅表征折叠景观的局部区域。当模拟太短或未初始化以充分覆盖相空间的相关部分时，可能会发生这种情况.例如研究折叠景观图，一系列的模拟初始点可能从一些解折叠中获得，获得的构象可能是强制解折叠或者高温模拟.对于通过漏斗机制快速折叠的分子，这可能效果很好。 然而，当折叠景观崎岖不平时，本质上遵从动态划分，景观的主要部分可能无法通过从“seeding”解折叠轨迹开始的模拟。</p><p>值得注意的是，研究必须始终对所研究的过程进行合理的整体评估，而不是仅仅依靠计算过程提供的数字。因为很多采样的中间过程都无法考虑周详.这限制了其的应用。MSM预测中另一个重要的不确定性来源是有限采样造成的统计误差。这个可以被验证通过马尔科夫链蒙特卡洛模拟(MCMC)的采样跃迁矩阵.将统计误差考虑在内是至关重要的，因为采样不良很容易导致与时间尺度本身相同数量级的相关隐含时间尺度上的不确定性.</p><p>例子:<br>r(A)3 的MSM分析<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/m-2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure></p><p><strong>Fig 2</strong>. 腺嘌呤三核苷酸四个状态的隐式马尔科夫链模拟流程图，核苷酸根据序列位置进行着色(红,1;蓝,2;黄,3).百分比表示每个状态的平衡数;箭头粗细与跃迁态成比例，单位为μs<sup>-1</sup>.</p><p>MSM方法在近几年发展十分快速，过去许多受到欢迎的程序已经被更加好的方法所代替。这种方法成功的应用到许多蛋白体系的研究之中，现如今也进入到了RNA的世界。我们预计新的应用程序和工具将很快出现，并且将更严格地讨论方法适用性的限制。阴影表示投影在由两个主要TICA组件定义的平面上的模拟数据的分布。具体可以参考推荐阅读3.</p><p>推荐阅读:</p><ol><li><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2933958/" target="_blank" rel="external">Everything you wanted to know about Markov State Models but were afraid to ask</a></li><li><a href="http://pubs.acs.org/doi/abs/10.1021/ct5002279" target="_blank" rel="external">Mechanism of the All-α to All-β Conformational Transition of RfaH-CTD: Molecular Dynamics Simulation and Markov State Model</a></li><li><a href="https://pubs.acs.org/doi/abs/10.1021/acs.jctc.6b00982" target="_blank" rel="external">Predicting the Kinetics of RNA Oligonucleotides Using Markov State Models</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;只是粗略翻译，未校正&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇文章以RNA MD为舟，主要参考《&lt;em&gt;RNA Structural Dynamics As Captured by Molecular Simulations: A Co
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="增强采样MD" scheme="http://kangsgo.com/tags/%E5%A2%9E%E5%BC%BA%E9%87%87%E6%A0%B7MD/"/>
    
  </entry>
  
  <entry>
    <title>Chimera补全蛋白缺失结构</title>
    <link href="http://kangsgo.com/26.html"/>
    <id>http://kangsgo.com/26.html</id>
    <published>2018-03-16T05:09:30.000Z</published>
    <updated>2018-03-16T06:27:56.574Z</updated>
    
    <content type="html"><![CDATA[<p>可能很多人喜欢用pymol，其实我认为Chimera是一个更加强大的可视化软件，只是不容易上手，可能不符合国人使用习惯用的人相对较少，这里简单介绍一下最近用到的Chimera补全蛋白缺失结构。</p><p>其实Chimera补全蛋白缺失结构主要是是利用的<code>modeller</code>，可以补全尾部结构或者中间的缺失结构，所以个人觉得对于之前介绍的<code>GalaxyFill</code>更加强大。</p><p>我们以<code>PDB:1qln</code>为例，1qln为T7 RNA 聚合酶，其中包括了一段核酸序列。我们可以先下载下来了解其信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://files.rcsb.org/download/1QLN.pdb</div></pre></td></tr></table></figure></p><p>可以看到MISSING RESIDUES信息，主要是前端和<code>56-71</code>的loop环的缺失。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/c1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure></p><p>我们将对其中loop进行补齐，若缺失的loop环是自己设计的残基，那么还需要自己修改<code>SEQRES</code>信息，如下图:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/c2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure><br>其中<code>SEQRES</code>为完整序列信息（包含缺失序列），可以自己创建或者修改添加从而达到自己的补全内容的目的。除非特殊要求一般PDB数据库中不需要修改或者自己添加。</p><p>我们打开UCSF Chimera，点击<strong>Favorites -&gt; Command Line</strong>,在下面<strong>Command</strong>中进行下载蛋白，删除核酸等操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#打开PDB 1qln</div><div class="line">open 1qln</div><div class="line">#删除 核酸和溶剂等</div><div class="line">delete ~protein</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/c3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure><p>再点击<strong>Tools -&gt;  Structure Editing -&gt;  Model/Refines Loops</strong><br>会弹出两个框框，其中这个框框主要是完整的序列信息，其中缺失蛋白位置会用红色框框圈出。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/c4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure><br>另外一个为设置modeller的框框:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/c5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure><br>具体的设置内容如下:<br><strong>Model/remodel 区域</strong><br>-active region: 序列框内的活性区域<br>-Chimera selection region: Chimera中选择的区域<br>-non-terminal missing structure: 非端点的缺失结构，会将坐标文件和SEQRES相互比较<br>-all missing structure: 所有缺失片段<br><strong>Allow this many residues adjacent to missing regions to move (default 1) </strong><br>允许移动的残基（来适配缺失残基），建议就是默认值<br><strong>Number of models to generate</strong><br>生成的模型数，个人觉得1个就好，后期再优化，默认为5个<br><strong>Loop modeling protocol</strong><br>-standard（默认）<br>-DOPE: 精度更高，花的时间更多，有可能没有结果或者比预期结果少<br>-DOPE-HR：和DOPE类似，精度相对没有那么高<br><strong>Run modeller using</strong><br>-web service（默认）:需要Modeller license key，学术用户可以输入<em>MODELIRANJE</em><br>-local installation：需要路径，我的是usr/local/mode9.19</p><p>点击<code>OK</code>会后台会运行，我运行了大约15分钟，运行完后模型会直接进入界面，然后保存即可。<br>若停止或者查看可以在<strong>Task Panel</strong>查看，即右下角<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/taskicon.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>图标</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可能很多人喜欢用pymol，其实我认为Chimera是一个更加强大的可视化软件，只是不容易上手，可能不符合国人使用习惯用的人相对较少，这里简单介绍一下最近用到的Chimera补全蛋白缺失结构。&lt;/p&gt;
&lt;p&gt;其实Chimera补全蛋白缺失结构主要是是利用的&lt;code&gt;mod
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Chimera" scheme="http://kangsgo.com/tags/Chimera/"/>
    
  </entry>
  
  <entry>
    <title>利用GalaxyFill补全蛋白</title>
    <link href="http://kangsgo.com/25.html"/>
    <id>http://kangsgo.com/25.html</id>
    <published>2018-03-15T05:09:30.000Z</published>
    <updated>2018-03-15T13:26:20.791Z</updated>
    
    <content type="html"><![CDATA[<p>GalaxyFill是一个项目用来进行对蛋白的缺失结构进行补全。其功能我觉得非常强大，比如用来进行蛋白的延长，甚至进行融合蛋白的制作。<br>使用Galaxy需要为<code>Linux 64-bit</code>位系统<br><strong>请注意无法补全中间的缺失结构</strong></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>下载<code>GalaxyFill</code>项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/seoklab/GalaxyFill/archive/master.zip</div></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">unzip master.zip</div><div class="line"><span class="comment">#修改名字</span></div><div class="line">mv GalaxyFill_master/ GalaxyFill</div></pre></td></tr></table></figure></li><li><p>设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gedit ~/.bashrc</div><div class="line"><span class="comment">##增加如下行，需要根据自己进行修改</span></div><div class="line"><span class="comment">## GalaxyFill</span></div><div class="line"><span class="comment">## export GALAXY_HOME=/home/kangsgo/install/GalaxyFill</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用方法如下:<br>使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$GALAXY_HOME</span>/bin/GalaxyFill [-h] [-p INPUT PDB File] [-s INPUT FASTA File]</div></pre></td></tr></table></figure></p><p>输入参数和设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-p or --pdb : Input protein structure file <span class="keyword">in</span> PDB format (mendatory)</div><div class="line">-s or --seq : Input protein sequence file <span class="keyword">in</span> FASTA format (mendatory)</div><div class="line">-o or --out : Output protein structure file name (optional, default=<span class="variable">$&#123;Input PDB prefix&#125;</span>_fill.pdb)</div><div class="line">-t or --title : Running title <span class="keyword">for</span> GalaxyFill (optional, default=<span class="variable">$&#123;Input PDB prefix&#125;</span>)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GalaxyFill是一个项目用来进行对蛋白的缺失结构进行补全。其功能我觉得非常强大，比如用来进行蛋白的延长，甚至进行融合蛋白的制作。&lt;br&gt;使用Galaxy需要为&lt;code&gt;Linux 64-bit&lt;/code&gt;位系统&lt;br&gt;&lt;strong&gt;请注意无法补全中间的缺失结构&lt;
      
    
    </summary>
    
      <category term="分子模拟" scheme="http://kangsgo.com/categories/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="Galaxy" scheme="http://kangsgo.com/tags/Galaxy/"/>
    
  </entry>
  
  <entry>
    <title>linux SSH简介</title>
    <link href="http://kangsgo.com/24.html"/>
    <id>http://kangsgo.com/24.html</id>
    <published>2018-03-15T04:08:36.000Z</published>
    <updated>2018-03-15T12:24:54.430Z</updated>
    
    <content type="html"><![CDATA[<p>相信小伙伴们人手可能有几个VPS，有一些国外的资源下载速度比较慢，一个方法就是拖到百度网盘然后再下载，另外一个比较好的办法就是拖到自己的vps中再下载，对于国外主机来说有时候下载内容的速度基本上是秒下，拖到国内的速度也比百度网盘非会员便宜。这里就简单介绍也是给自己做一个笔记如何进行到本地。</p><h2 id="什么是SSH？"><a href="#什么是SSH？" class="headerlink" title="什么是SSH？"></a>什么是SSH？</h2><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p><p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p><p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>登陆上远程主机，常用的格式如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh [-l login_name] [-p port] [user@]hostname</div></pre></td></tr></table></figure></p><p>详细信息可以使用<code>ssh -h</code>进行查看</p><p>不指定用户，默认使用root账户登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　ssh 192.168.0.11</div></pre></td></tr></table></figure></p><p>指定用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　ssh -l root 192.168.0.11</div><div class="line"></div><div class="line">　　ssh root@192.168.0.11</div></pre></td></tr></table></figure></p><p>如果修改过ssh登录端口的可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　ssh -p 12333 192.168.0.11</div><div class="line"></div><div class="line">　　ssh -l root -p 12333 192.168.0.11</div><div class="line"></div><div class="line">　　ssh -p 12333 root@192.168.0.11</div></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>基本语句如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp file username@hostIP fileaddress</div></pre></td></tr></table></figure></p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp test.sql zhangying@192.168.1.5:/var/www/zhangying</div></pre></td></tr></table></figure></p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>基本语句如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp username@hostIP: fileaddress   filedirectory</div></pre></td></tr></table></figure></p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp zhangying@192.168.1.5:/var/www/zhangying/test.sql /home/zhangy/database_bak/</div></pre></td></tr></table></figure></p><p>参考资料:</p><ol><li><a href="http://blog.csdn.net/huludan/article/details/51580701" target="_blank" rel="external">linux下面用ssh上传，下载文件</a></li><li><a href="https://www.cnblogs.com/joshua317/articles/4740881.html" target="_blank" rel="external">linux ssh登录命令</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信小伙伴们人手可能有几个VPS，有一些国外的资源下载速度比较慢，一个方法就是拖到百度网盘然后再下载，另外一个比较好的办法就是拖到自己的vps中再下载，对于国外主机来说有时候下载内容的速度基本上是秒下，拖到国内的速度也比百度网盘非会员便宜。这里就简单介绍也是给自己做一个笔记
      
    
    </summary>
    
      <category term="Linux" scheme="http://kangsgo.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Pymol核酸绘图</title>
    <link href="http://kangsgo.com/23.html"/>
    <id>http://kangsgo.com/23.html</id>
    <published>2018-03-13T05:09:30.000Z</published>
    <updated>2018-03-13T06:39:52.920Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道chimera的核酸绘图功能非常强大，一般大家理解的pymol核酸绘图功能就显得薄弱了，但是今天在看pymol的cartoon的时候无意间看到了其核酸绘图，发现实际上其功能还是不错的。</p><h2 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h2><p>默认的一般有一个磷酸骨架和一个跨过核苷酸平面的枝棒，默认设置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set cartoon_nucleic_acid_mode, 0 # 骨架随后的磷酸盐，实际上pymol默认设置为4</div><div class="line">set cartoon_ladder_mode, 1 # 从骨架到核苷酸的枝条</div><div class="line">set cartoon_ring_mode, 0 # 没有核酸环</div><div class="line">set cartoon_ring_finder, 1 # 核糖和基本环 (因为ring mode 0，所以这里设置什么都不会展示)</div></pre></td></tr></table></figure></p><p>我们以PDB<code>265d</code>为例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch <span class="number">265</span>d</div><div class="line">remove resname HOH</div><div class="line">remove resname MG</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><h2 id="Cartoon-环模式（ring-mode）"><a href="#Cartoon-环模式（ring-mode）" class="headerlink" title="Cartoon 环模式（ring mode）"></a>Cartoon 环模式（ring mode）</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ring_mode, value</p><p><strong>值影响</strong></p><p>0  枝条从骨架原子到嘌呤的N1或嘧啶的N3<br>1  简单的核糖平面和覆盖环键之间区域的基环<br>2  简单的核糖平面和覆盖环键内侧之间区域的基环（和模式1相比略小）<br>3  用棍棒包围核糖和基环的平面<br>4  在核糖中心和每个基环上的大直径环球体<br>5  大约为4的1/10的球体</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure></p><p>模式3：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure></p><p>模式4：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure></p><h2 id="Cartoon-ring-finder"><a href="#Cartoon-ring-finder" class="headerlink" title="Cartoon ring finder"></a>Cartoon ring finder</h2><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ring_finder, value</p><p><strong>值影响</strong></p><p>0 没有环或枝条加入<br>1 核糖和基础环<br>2 只有基础环<br>3 和模式1类似，轻微的透视<br>4 和模式1类似，核糖核苷酸和碱基，以及蛋白质的芳香侧链显示<br>5 只有枝条，无环</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/7.png" alt="图片7" title="">                </div>                <div class="image-caption">图片7</div>            </figure></p><h2 id="Cartoon梯子模式"><a href="#Cartoon梯子模式" class="headerlink" title="Cartoon梯子模式"></a>Cartoon梯子模式</h2><h3 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_ladder_mode, value</p><p><strong>值影响</strong><br>0 没有枝条展示<br>1 枝条展示</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/8.png" alt="图片8" title="">                </div>                <div class="image-caption">图片8</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><h2 id="Cartoon核酸模式"><a href="#Cartoon核酸模式" class="headerlink" title="Cartoon核酸模式"></a>Cartoon核酸模式</h2><h3 id="设置-3"><a href="#设置-3" class="headerlink" title="设置"></a>设置</h3><p>set cartoon_nucleic_acid_mode, value</p><p><strong>值影响</strong><br>0    光滑的骨架通过磷原子，骨架的两端均终止于磷末端<br>1    光滑的骨架通过核糖C3’原子，骨架的两端最后C3’终止<br>2    光滑的骨架通过磷原子，主链在5’末端终止于磷，在3’末端终止于O3’<br>3    和0模式相似？<br>4    和模式2相似？</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>模式0：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式1：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/9.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><p>模式2：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/3/10.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道chimera的核酸绘图功能非常强大，一般大家理解的pymol核酸绘图功能就显得薄弱了，但是今天在看pymol的cartoon的时候无意间看到了其核酸绘图，发现实际上其功能还是不错的。&lt;/p&gt;
&lt;h2 id=&quot;默认设置&quot;&gt;&lt;a href=&quot;#默认设置&quot; class
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>Pymol渲染（Ray）笔记</title>
    <link href="http://kangsgo.com/22.html"/>
    <id>http://kangsgo.com/22.html</id>
    <published>2018-02-26T05:09:30.000Z</published>
    <updated>2018-02-26T05:33:41.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ray"><a href="#Ray" class="headerlink" title="Ray"></a>Ray</h1><p><strong>ray</strong>将会创建一个现在的框架图像的渲染（ray-traced）图像。我们平常使用pymol的时候可能就是直接ray一下出图，其实ray有许多功能可以挖掘，这里简单介绍一小部分。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ray [width,height [,renderer [,angle [,<span class="built_in">shift</span> ]]]</div></pre></td></tr></table></figure><p><strong>angle</strong>和<strong>shift</strong>将会生成立体的配对<br><strong>width</strong>和<strong>height</strong>为设置ray的长宽，可以超出现在的框架</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>默认图像</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-1.png" alt="图片1" title="">                </div>                <div class="image-caption">图片1</div>            </figure><p>简单渲染<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#全部使用默认设置</span></div><div class="line">ray</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-2.png" alt="图片2" title="">                </div>                <div class="image-caption">图片2</div>            </figure><h2 id="PyMol-API"><a href="#PyMol-API" class="headerlink" title="PyMol API"></a>PyMol API</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd.ray(int width,int height,int renderer=<span class="number">-1</span>,float shift=<span class="number">0</span>)</div></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h3><p>设置<strong>Ray_trace_mode</strong>设置可以修改最终成图的时候的PyMOL的内部渲染蛋白的模式.<br>下面可以查看不同模式的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 普通颜色</div><div class="line">set ray_trace_mode, 0</div><div class="line"></div><div class="line"># 普通颜色+黑色线</div><div class="line">set ray_trace_mode, 1</div><div class="line"></div><div class="line"># 仅包含黑色线</div><div class="line">set ray_trace_mode, 2</div><div class="line"></div><div class="line"># 倍色+黑色线</div><div class="line">set ray_trace_mode, 3</div><div class="line"></div><div class="line"># 建议设置</div><div class="line">set antialias, 2</div><div class="line"></div><div class="line"># 更改线的颜色</div><div class="line">set ray_trace_color, magenta</div></pre></td></tr></table></figure><p>效果如下</p><p>ray_trace_mode, 1<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-3.png" alt="图片3" title="">                </div>                <div class="image-caption">图片3</div>            </figure></p><p>ray_trace_mode, 2<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-4.png" alt="图片4" title="">                </div>                <div class="image-caption">图片4</div>            </figure></p><p>ray_trace_mode, 3<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-5.png" alt="图片5" title="">                </div>                <div class="image-caption">图片5</div>            </figure></p><p>ray_trace_color, magenta<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-6.png" alt="图片6" title="">                </div>                <div class="image-caption">图片6</div>            </figure></p><h3 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h3><p>在0.98版本以后，渲染速度得到了提升，选择的开关如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set orthoscopic, off</div><div class="line"></div><div class="line">set orthoscopic, on</div></pre></td></tr></table></figure></p><p>放大近景如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set field_of_view, X</div></pre></td></tr></table></figure></p><p>当50&lt;X&lt;70，默认为20.50-70 拥有非常强的透视效果。透视的轴为Y轴，而不是X轴</p><p>orthoscopic, off<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-7.png" alt="图片7" title="">                </div>                <div class="image-caption">图片7</div>            </figure></p><p>orthoscopic, on<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-8.png" alt="图片8" title="">                </div>                <div class="image-caption">图片8</div>            </figure></p><p>set field_of_view, 70<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-9.png" alt="图片9" title="">                </div>                <div class="image-caption">图片9</div>            </figure></p><p>不知道为何我做出来没有效果，可以看官方的图例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2018/2/3fbi-10.png" alt="图片10" title="">                </div>                <div class="image-caption">图片10</div>            </figure><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>renderer = -1 为默认渲染<br>renderer = 0 为PyMOL内部渲染器<br>renderer = 1 使用PovRay渲染器， <strong>Unix-only </strong></p><p>例子如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ray trace with an external renderer.</span></div><div class="line">ray renderer=<span class="number">0</span></div></pre></td></tr></table></figure></p><p>比较了一下-1和0模式的效果差别不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ray&quot;&gt;&lt;a href=&quot;#Ray&quot; class=&quot;headerlink&quot; title=&quot;Ray&quot;&gt;&lt;/a&gt;Ray&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ray&lt;/strong&gt;将会创建一个现在的框架图像的渲染（ray-traced）图像。我们平常使用pymol的时候可
      
    
    </summary>
    
      <category term="绘图与可视化" scheme="http://kangsgo.com/categories/%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Pymol" scheme="http://kangsgo.com/tags/Pymol/"/>
    
  </entry>
  
  <entry>
    <title>利用OpenBabel生成多个构像</title>
    <link href="http://kangsgo.com/21.html"/>
    <id>http://kangsgo.com/21.html</id>
    <published>2018-01-19T08:10:20.000Z</published>
    <updated>2018-01-20T12:38:10.201Z</updated>
    
    <content type="html"><![CDATA[<p>此文感谢建民兄的指导，才让我学习到这么有用的工具</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>有许多软件例如<code>Dock 6.8</code>，对于小分子的柔性对接支持并不那么好，这就导致了因为初始构像的不正确而导致了对接结果的不正确和不可靠，为了解决这个问题一个方法就是进行构像的生成，再进行多对接，整理得分排序。当然还有一个应用就是用于3D药效团的使用。网上有许多在线网站可以进行这方面的工作，但是最好用的我感觉还是openbabel神器！</p><h2 id="利用openbabel生成多构像"><a href="#利用openbabel生成多构像" class="headerlink" title="利用openbabel生成多构像"></a>利用openbabel生成多构像</h2><p>Open Babel提供了两种构像生成的算法代码:</p><ol><li>Confab: 一个成体系的构像生成器，有序的生成所有的低能量构像</li><li>遗传算法: 是一个随机构像产生器，能够根据RMSD或者能量的不同达到优化的目的</li></ol><h3 id="1-遗传算法"><a href="#1-遗传算法" class="headerlink" title="1. 遗传算法"></a>1. 遗传算法</h3><p>了解算法的命令信息可以使用:<code>obabel -L conformer</code>查看。虽然查看是说的构像搜寻，但是可以使用<code>--writeconformers</code>对生成的构像进行保存。可以查看如下的生成30个构像的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel startingConformer.mol -O ga_conformers.sdf --conformer --nconf 30  --score rmsd --writeconformers</div></pre></td></tr></table></figure></p><p>其中<code>--score rmsd</code>可以不写，因为默认就是使用这种方式</p><p>当然生成的构像在1个文件里，我们有时候需要split，当然首先想到的还是<code>obabel</code>,其进行拆分相当于高射炮打蚊子–相当好用呀（&lt;-原谅我在这里乱用歇后语），示例如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel ga_conformers.sdf -O new.mol -m</div></pre></td></tr></table></figure></p><p>我自己的输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">32 molecules converted</div><div class="line">32 files output. The first is molecule/new1.mol2</div></pre></td></tr></table></figure></p><h3 id="2-Confab"><a href="#2-Confab" class="headerlink" title="2. Confab"></a>2. Confab</h3><p>Confab 生成分子的低能量构像分子集合。设置命令为<code>--confab</code>,同样可以使用<code>obabel -L confab</code>进行查看了解。<br>使用简单的设置操作如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel &lt;inputfile&gt; -O &lt;outputfile&gt; --confab [confab options]</div></pre></td></tr></table></figure></p><p>其还有一个额外的应用就是<strong>confabreport format</strong>，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obabel &lt;inputfile&gt; [-O &lt;outputfile&gt;] -o confabreport -xf &lt;reference_file&gt; [-xr &lt;rmsd&gt;]</div></pre></td></tr></table></figure></p><p>主要是为了和初始构像进行比较。</p><p>下面是其中一个例子，首先生成100K个构像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; obabel bostrom.sdf -O confs.sdf --confab --conf 100000</div><div class="line"></div><div class="line">**Starting Confab 1.1.0</div><div class="line">**To support, cite Journal of Cheminformatics, 2011, 3, 8.</div><div class="line">..Input format = sdf</div><div class="line">..Output format = sdf</div><div class="line">..RMSD cutoff = 0.5</div><div class="line">..Energy cutoff = 50</div><div class="line">..Conformer cutoff = 1000000</div><div class="line">..Write input conformation? False</div><div class="line">..Verbose? False</div><div class="line"></div><div class="line">**Molecule 1</div><div class="line">..title = 1a28_STR_1_A_1__C__</div><div class="line">..number of rotatable bonds = 1</div><div class="line">..tot conformations = 12</div><div class="line">..tot confs tested = 12</div><div class="line">..below energy threshold = 10</div><div class="line">..generated 3 conformers</div><div class="line"></div><div class="line">... etc, etc</div><div class="line"></div><div class="line">0 molecules converted</div></pre></td></tr></table></figure></p><p>统计多少个构像和初始构像相比RMSD小于1.0A<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; obabel confs.sdf -oconfabreport -xf bostrom.sdf -xr 1.0</div><div class="line"></div><div class="line">**Generating Confab Report</div><div class="line">..Reference file = bostrom.sdf</div><div class="line">..Conformer file = confs.sdf</div><div class="line"></div><div class="line">..Molecule 1</div><div class="line">..title = 1a28_STR_1_A_1__C__</div><div class="line">..number of confs = 3</div><div class="line">..minimum rmsd = 0.0644801</div><div class="line">..confs less than cutoffs: 0.2 0.5 1 1.5 2 3 4 100</div><div class="line">..1 1 3 3 3 3 3 3</div><div class="line">..cutoff (1) passed =  Yes</div><div class="line"></div><div class="line">... etc, etc</div><div class="line"></div><div class="line">**Summary</div><div class="line">..number of molecules = 36</div><div class="line">..less than cutoff(1) = 35</div><div class="line">52271 molecules converted</div></pre></td></tr></table></figure></p><p>我做的一个的简单应用（批量读取文件对接），不提供部分代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> ucsfdock.docksh <span class="keyword">import</span> PreDock</div><div class="line"><span class="keyword">from</span> ucsfdock.dockfile <span class="keyword">import</span> Dock</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment">#计时器工具</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line">time_start=time.time()</div><div class="line"></div><div class="line">DOCKHOME=<span class="string">'/home/kangsgo/install/dock6/bin/'</span></div><div class="line"><span class="comment">#run=PreDock(DOCKHOME=DOCKHOME)</span></div><div class="line"><span class="comment">#run.onerun()</span></div><div class="line">dock=Dock(DOCKHOME=DOCKHOME)</div><div class="line"><span class="comment">#遍历molecule目录下所有的文件</span></div><div class="line"><span class="keyword">for</span> (dirpath,dirnames,filenames) <span class="keyword">in</span> os.walk(<span class="string">'molecule'</span>):</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> filenames:</div><div class="line">        print(<span class="string">'开始执行'</span>+i+<span class="string">'文件'</span>)</div><div class="line">        dock.dock(mode=<span class="number">2</span>,ligand_atom_file=<span class="string">'molecule/'</span>+i,ligand_outfile_prefix=<span class="string">'out1/'</span>+i[:<span class="number">-5</span>])</div><div class="line"><span class="comment">#dock.dock(mode=2,ligand_atom_file='2.mol2')</span></div><div class="line">print(<span class="string">"done!"</span>)</div><div class="line">time_end=time.time()</div><div class="line">print(<span class="string">"耗时为"</span>+str(time_end-time_start)+<span class="string">" 秒"</span>)</div></pre></td></tr></table></figure></p><p>参考资料:</p><ol><li><a href="http://open-babel.readthedocs.io/en/latest/3DStructureGen/multipleconformers.html" target="_blank" rel="external">Generate multiple conformers</a></li><li><a href="http://open-babel.readthedocs.io/en/latest/Command-line_tools/babel.html" target="_blank" rel="external">obabel and babel</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此文感谢建民兄的指导，才让我学习到这么有用的工具&lt;/p&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;有许多软件例如&lt;code&gt;Dock 6.8&lt;/code&gt;，对于小分子的柔性对
      
    
    </summary>
    
      <category term="预处理" scheme="http://kangsgo.com/categories/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
    
      <category term="OpenBabel" scheme="http://kangsgo.com/tags/OpenBabel/"/>
    
  </entry>
  
</feed>
