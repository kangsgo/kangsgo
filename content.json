{"meta":{"title":"小康学习","subtitle":"计算化学与分子模拟爱好者","description":"Gromacs,Dock,Martini,Chimera,Pymol","author":"kangsgo","url":"http://kangsgo.com"},"pages":[{"title":"tags","date":"2017-10-18T13:05:34.000Z","updated":"2018-05-31T01:06:48.044Z","comments":false,"path":"tags/index.html","permalink":"http://kangsgo.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-18T13:06:42.000Z","updated":"2018-05-31T01:07:11.867Z","comments":false,"path":"categories/index.html","permalink":"http://kangsgo.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"网站域名修改为cn后缀","slug":"域名修改为cn后缀","date":"9999-12-05T09:09:30.000Z","updated":"2018-06-01T08:01:40.541Z","comments":true,"path":"48.html","link":"","permalink":"http://kangsgo.com/48.html","excerpt":"","text":"因为网站kangsgo.cn进行了备案，以后请访问这个域名，谢谢啦^_^","categories":[{"name":"未分类","slug":"未分类","permalink":"http://kangsgo.com/categories/未分类/"}],"tags":[]},{"title":"分子模拟网站推荐","slug":"分子模拟网站推荐","date":"9999-11-27T18:37:22.000Z","updated":"9999-11-12T12:37:22.000Z","comments":true,"path":"2.html","link":"","permalink":"http://kangsgo.com/2.html","excerpt":"","text":"参考资料：待编辑 1.内容性推荐综合性网站推荐：小木虫论坛：一个综合性的论坛，项目非常杂，但是里面有非常多的资料分享。感觉对于交流和求知比较欠缺 。 bioms分子模拟论坛：是一个专业性质的论坛，主要集中讨论计算机辅助药物设计这一快，氛围非常好，但是最近活跃度有所下降。 哲科文：李继存老师的个人博客，主要是gromacs的一些中文教程，老师人也非常好 勤力既懒猪：一些模拟方面的教程 计算化学公社：有论坛和门户网站，具体没有发掘~主要是看到了VMD的教程 思想家公社的门口：博客 科学空间: 并不是一个严格的分子模拟网站，更多的是算法相关的资源分享，还是非常推荐查看的 吴钩白的博客: 我最崇拜的学长之一，知识渊博，喜欢亲切的叫他一声老师 Howie：永远相信美好的事情终将发生 AspirinCode 和 Hexo版本: 建民兄的博客，其对药物设计有非常独特的见解 Liu Yujie 杰哥的博客，对gromacs有非常深的见解！ 陈照强的博客 强哥的博客，CADD大牛，对Python见解深刻 QQ群：BioMS分子模拟-药物设计 68093966 【十分活跃】 药物研发科学计算 205448601 GROMACS中文组 132266540 【专一性强，很热心】 「药设之道」医药R&amp;D 426442973 分子模拟技术交流 397981984 【田老师组织的群，很活跃】 计算生命科学 496548248 微信公众号：生物研究生 分子模拟牛人小9创立的一个分享分子模拟方面内容的微信公众号 分子模拟之道 李老师创办的生物模拟资讯公众号，内容不多但是篇篇精华 王初课题组 好文章的推荐公众号 生信杂谈 分子模拟与生物信息杂交体 克里科学苑 致力于组织生命科学及医学领域科研及应用培训的专业机构 药设之道 致力于向大众和专业工作者传播药物设计新方法的公众号 2.软件推荐与教程1.序列比对 ClustaX ： 没有做过多深入了解 2.蛋白建模 2.1同源建模 Modeller：同源建模经典网站 Easymodeller：Modeller的可视化界面，深入学习的话不建议学 Swiss-model：在线建模网站，质量不错，可操控性高 GalaxyFill: 补充收尾缺失结构，可以用来制作融合蛋白 2.2从头建模 I-TASSER：Zhang实验室制作的一个从头建模在线服务器 Rostta：综合性软件，学术免费 2.3模型评价 SAVES：包含XdVal | MTZdump | Ramachandran Plot | pdbU | pdbSNAFU | PROCHECK | Verify3D | ERRAT 多种评价，其中常用Ramachandran Plot和ERRAT2 2.4 结构准备 OpenBabel：一个格式转换工具，具有本地编译包和多种语言的API Reduce： 一个加氢删氢的命令行工具，仅支持PDB格式 3.分子对接 DOCK: UCSF DOCK,现在是第6版，同样具有柔性对接和刚性对接，对接的结果评价中等，学术免费，需要搭配Chimera使用。平台：linux AutoDock：最为经典的对接软件，有一款HIV药物据说就是它的功劳，使用广泛，但是速度和准确度很低，据飞天说能量打分尚可。平台：linux/windows AutoDock Vina： 与AutoDock为同一实验室不同课题组产物，速度和准确度都有较大的提高，算是免费里面做的最好之一了。平台：linux/windows Igemdock：台湾设计的一款对接软件，选择活性区域位点比较麻烦，但是准确度高（据华中师大-精灵测试）。平台：linux/windows LibDock： 对接速度快，Discover Studio集成，不是一般人买得起。平台：linux/windows CDOCK：相对于LibDock更为精确。平台：linux/windows LigandFit： 柔性对接，同上，这三款都是DS集成的对接。平台：linux/windows DrugScoreX： DrugScoreX是一个较新的，对于蛋白配体打分具有比DrugScore更高精度的软件，其打分功能是基于统计势能？(statistical potentials) LigScore： 与DrugScore的算法类似,提供本地(IMP 工具包)以及在线服务。 PoseViewWeb : 在线的对接2D相互关系图形显示工具 4.分子模拟/分子动力学 MD gromacs: 一个开源的分子动力学模拟软件 Amber: 一个以生物为主导的分子动力学模拟软件，GPU加速模块收费 OpenMM： 一个开源的分子动力学模拟软件，发展很好，但是社区和一类模拟软件还是有差距 OpenMD: 小型模拟软件 Martini: 最为流行的粗粒化力场 LigParGen: 配体OPLS/CM1A力场在线生成 4.1 体积检测： Epock Epock是一个可以动态计算结合腔大小的一个软件，由于有VMD的可视化软件，所以非常的容易上手，简单~ fpocket2 具有在线服务器的体积检测软件，在线服务:点我进去 4.2 综合轨迹分析工具 MDTraj 可以进行轨迹转化，氢键分析等较为底层的工具包，但是非常好用 MDAnalysis 完全用Python编写的分析工具包 PLUMED 一个非常有名的分子模拟分析工具，暂时没有看 5.药效团构建 6.毒理测试 7.可视化软件 AstexViewer3.0 是一个基于java的轻量级软件，虽然功能简单，但是五脏俱全，特别是可以进行电子密度图查看，相对于pymol和vmd比较容易上手，其一些软件的设置方式与pymol和vmd类似，适合新学者或者编写脚本批量分析。 Pymol 一个跨平台的可视化开源软件，后因被薛定谔公司收购，有一部分发展为闭源更新 VMD 一个以命令行为主的开源可视化软件，个人感觉发展势头优于pymol，且可以和gromacs较好的连用，NAMD，amber的集成性也较好 Chimera UCSF chimera 功能强大，可以与dock连用 ChimeraX 下一代可视化软件，作图美丽但是功能暂时比较少 PMV Autodock/Autodock搭配的可视化软件，使用的人较少，一般都是用autodock搭配着使用的 8.开发库 Biopython：一个Python工具包，中文文档可以点此查看 scikit-bio: 一个提供多种生物科学功能，数据结构和算法的Python包 9.综合性软件 最后更新:2017/12/09","categories":[],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://kangsgo.com/tags/推荐/"}]},{"title":"系列笔记整理","slug":"02Gromacs笔记","date":"9999-10-03T18:32:44.000Z","updated":"2018-04-25T11:42:47.858Z","comments":true,"path":"87.html","link":"","permalink":"http://kangsgo.com/87.html","excerpt":"","text":"1.Gromacs笔记整理1.1.安装篇Gromacs2018 详细安装 (兼容gromacs5.X版本) Gromacs CUDA版一键安装脚本 1.2.核心教程1.2.1 James (Wes) Barnett教程Gromacs教程 GROMACS教程1-水 GROMACS教程2-水中的单个甲烷 1.2.2 简单教程GROMACS之水中部分載脂蛋白 1.2.3 蛋白配体教程LigParGen:配体OPLS/CM1A力场在线生成 gromacs下蛋白-配体复合物模拟[GAFF] gromacs中构建非标准氨基酸残基力场 gromacs下蛋白配体复合物分析 1.2.4 g_mmpbsa教程g_mmpbsa之简单教程/结合自由能计算 g_mmpbsa之参数注释 GMXPBSAtool安装与使用经验教程 1.2.5 其他不完善教程Gromacs 5.1.2做拉伸动力学的几点笔记 1.3.小技巧合集Gromacs共轭梯度法mdp设置 2.Rosetta笔记整理2.1.安装篇2.2.完整教程Rosetta蛋白蛋白对接 Rosetta从头结构预测 3.Pymol笔记整理3.1 安装Pymol安装与问题解决 3.2 基本手册Pymol选择速查手册 3.3 笔记Pymol插件：Autodock/Vina [转]pymol小技巧-选择配体周围氨基酸残基 使用Pymol的Modevectors脚本绘画豪猪图 Pymol小脚本之Rotkit 利用Pymol将周边图像虚化 Pymol核酸绘图 Pymol渲染（Ray）笔记","categories":[],"tags":[]},{"title":"Rosetta系列-重新设计高表面净电荷蛋白","slug":"Rosetta系列-超电荷蛋白","date":"2018-06-26T01:27:12.000Z","updated":"2018-06-26T01:23:37.354Z","comments":true,"path":"37.html","link":"","permalink":"http://kangsgo.com/37.html","excerpt":"","text":"最近比较忙，拿出一篇以前翻译的教程凑数 关键词：一般设计 If you want to run supercharge now, the application is called ‘supercharge’ in src/apps/public/supercharge.cc. 这里有四个例子: (where ROSETTA3=path-to-Rosetta/main/source) 1$&gt; $ROSETTA3/bin/supercharge.default.macosgccrelease @rosetta_inputs/options1 // Rosetta-mode, positive-charge, fixed surface cutoff and input ref energies1$&gt; $ROSETTA3/bin/supercharge.default.macosgccrelease @rosetta_inputs/options2 // Rosetta-mode, negative-charge, fixed surface cutoff and target net charge1$&gt; $ROSETTA3/bin/supercharge.default.macosgccrelease @rosetta_inputs/options3 // AvNAPSA-mode, negative-charge, target net charge1$&gt; $ROSETTA3/bin/supercharge.default.macosgccrelease @rosetta_inputs/options4 // AvNAPSA-mode, positive-charge, fixed surface cutoff Rosetta-mode and AvNAPSA-mode are explained below… 为什么给蛋白表面增加电荷?重新设计蛋白表面让其有高电荷，称之为Supercharging,可以提升未折叠的可逆性通过阻止部分未折叠状态的聚合.在生物技术和医疗中聚合聚集是常见的障碍。此外，高正电荷蛋白和肽段能够穿入病毒载体，高负电荷蛋白在肾过滤中更加缓慢，相较于中性蛋白或者正电荷蛋白。 应该确定引入带电侧链的最佳位置，因为许多突变和相同的电荷积累可能使得天然的状态变得不稳定。先前的证实方法突变每个侧链原子具有最少的平均临近原子的柔软的极性残基（氨基酸残基DERKNQ）（ AvNAPSA: Lawrence MS, Phillips KJ, Liu DR, 2007, Supercharging proteins can impart unusual resilience, JACS）我们的方法使用Rosetta-based能量计算来选择表面的突变。在该在线服务中包含了这两种方法。 两种方法这里有两种自动的方法, Rosetta supercharge (Rsc) 和 AvNAPSA supercharge (Asc) AvNAPSA supercharge理论 (Asc): 突变最暴露的极性残基以保证最小的结构变化和最小的不稳定。仅仅DE-RK-NQ残基被突变。 Rosetta supercharge理论 (Rsc): 突变残基的位置为保留或添加有利的表面相互作用。疏水或者弱极性表面也可以被突变。 AvNAPSA 缺点: 突变表面极性氨基酸残基可能会删除氢键。螺旋加帽，边缘链的相互作用和loop环的稳定性。并且自动突变N到D和Q到E，但是N到Q有时候会扮演氢键供体或者受体。 Rosetta 缺点: 突变较少的暴露位置可以导致更好的计算能量，但是错误的位置可能导致不稳定。 AvNAPSA 热衷于电荷交换,所以Rosetta完成相同的电荷改变需要进行更多的突变。 AvNAPSA通过调整表面cutoff来适应电荷变化。Rosetta方法通过调节带正电荷或带负电荷的残基的参考能量来改变净电荷。 supercharge server 可以使用四个不同的模型:-AvNAPSA with a target net charge-AvNAPSA with a surface cutoff-Rosetta with a surface cutoff and target net charge-Rosetta with a surface cutoff and input reference energies for charged residue types AvNAPSA 代表什么: 每个侧链原子的平均邻近原子数。这是一个值，这个值用以表达侧链埋藏/accessibility的程度。它类似于Rosetta通常用来定义表面的临近氨基酸残基距离。但是它是在原子水平而不是残基水平。AvNAPSA模型计算AvNAPSA值对于所有的残基。’surface_atom_cutoff‘代表cutoff AvNASPA值通过定义表面残基。AvNAPSA值一般为50-150.AvNAPSA值》150对于核心残基是典型的。surface_atom_cutoff 设置100为适度增压，150将会导致更重的增压。 每种模型的流程AvNAPSA-mode, 电荷目标 定义表面. 排序 NQ 和 RK/DE 残基通过 AvNAPSA 由低到高排序 残基排序: Positive: 突变 DENQ–&gt;K, Negative: 突变 RKQ–&gt;E and N–&gt;D 如果计算电荷等于目标电荷, 输出 pdb文件 AvNAPSA-mode, 表面cuttof 定义表面通过 AvNAPSA 值 (&lt;100 default) 对于每个在表面的 NQ 和 DE/RK 残基: Positive: 突变 DENQ–&gt;K, Negative: 突变 RKQ–&gt;E and N–&gt;D 输出 pdb 文件 Rosetta-mode, 表面 cutoff 和目标电荷 定义表面. 临近的距离计算 (CB dist.), &lt;16 neighbors default 或者定义表面通过 AvNAPSA 值 (&lt;100 default) 设置设计任务 阅读用户 resfile 文件（如果提供） dont_mutate gly, pro, cys （不突变） dont_mutate h-bonded sidechains dont_mutate correct charge residues 设置对于RK/DE的参考能量，开始于输入值 pack rotamers mover 检测电荷, 增加或者降低参考能量 (返回步骤 3.) Once a pack rotamers run results in the correct net charge, 输出 pdb 文件 Rosetta-mode, 表面cutoff 和输入参考能量对于电荷残基类型 定义表面. 临近的距离计算 (CB dist.), &lt;16 neighbors default 或者定义表面通过 AvNAPSA 值 (&lt;100 default) 设置设计任务 阅读用户 resfile 文件（如果提供） dont_mutate gly, pro, cys （不突变） dont_mutate h-bonded sidechains dont_mutate correct charge residues 设置对于RK/DE的参考能量，开始于输入值 pack rotamers mover 输出 pdb 文件 设置AvNAPSA Mode1234AvNAPSA_positive BOOL def(false); //运行 positive-charge AvNAPSAAvNAPSA_negative BOOL def(false); //运行 negative-charge AvNAPSAtarget_net_charge SIGNED_INT def(0); //残基位置会被一个一个突变知道达到设定的电荷值surface_atom_cutoff UNSIGNED_INT def(100); // 如果你没有电荷目标，AvNAPSA会突变所有的位于表面的DE-RK-NQ残基到这个表面cutoff Rosetta Mode1234567891011121314151617181920surface_residue_cutoff UNSIGNED_INT def(16); //在10埃内具有&lt;16个相邻残基的残基被认为是表面的一部分include_arg BOOL def(false); //使用 arginine superchargeinclude_lys BOOL def(false); //使用 lysine superchargeinclude_asp BOOL def(false); //使用 aspartate superchargeinclude_glu BOOL def(false); //使用 glutamate supercharge//带电残基类型的参考能量将控制Rosetta设计的净电荷。 Rosetta可以在允许的带电荷残基类型和天然残基之间进行选择。 更多的负参考能量将导致更多的电荷突变。refweight_arg FLOAT def(-0.98);refweight_lys FLOAT def(-0.65);refweight_asp FLOAT def(-0.67);refweight_glu FLOAT def(-0.81);dont_mutate_glyprocys BOOL def(true); //dont_mutate：不突变。glycine, proline, 和 cysteine 在蛋白中经常扮演特别的结构dont_mutate_correct_charge BOOL def(true); //例., 不突变 arginine 到 lysinedont_mutate_hbonded_sidechains BOOL def(true); //不突变会形成氢键的氨基酸残基pre_packminpack BOOL def(false); //Packrotamers is always done as the first step. This option will go one step further and run packrotamers, sidechain+backbone minimization, packrotamers on the input structure before performing the supercharge design step.nstruct UNSIGNED_INT def(1); //蛋白表面的蒙特卡洛序列 设计一般会聚集的但是仍然是随机的，如果需要可以进行多个设计运行。target_net_charge UNSIGNED_INT def(0); //如果需要，可以实现目标净电荷，这通过递增/递减充电的残余参考能量以自动方式进行，直到从蒙特卡罗设计步骤得到所需的净电荷。. AvNAPSA and Rosetta Mode12345678910111213surface_atom_cutoff UNSIGNED_INT def(100); // this is how AvNAPSA defines surface, can be used in either approachcompare_energies BOOL def(false); //打印全部的残基到残基的能量分析到log文件中only_compare_mutated_residues BOOL def(false); //在能量分析中只分辨突变残基resfile FILE; //可以定义哪些特别的残基不突变。默认设置必须为ALLAA。一个残基一个残基设置需要为NATAA，结果如下：ALLAAstart 20 A NATAA 24 A NATAA 26 A NATAANote: 输入的 resfile 是可以设置的. However, every supercharge run generates an output resfile that governs the design run. The default of this output resfile is NATAA, which prevents core residues from mutating (see below). The input resfile is read first, the output resfile (see below) is read second, and this is why ALLAA must be the default for the input resfile. If the default were NATRO, for example, no design would occur! 输出作为输出文件，一个log文件，管理设计运行的residue文件和输出的PDB文件被提供。首先，log文件包含着所有的Rosetta的命令行，标识位于表面的残基文件，在最终序列中的带电残基列表，净电荷，突变的清单，文本对于PyMOL选择可以非常容易的在PyMOL中查看，和可设置的，重新包装的天然与超荷电结构的充分能量比较。第二个，Rosetta残基文件指示哪个残基可以被突变以及什么残基类型。第三个输出文件是supercharged的原子坐标。并且输出PDB的命名旨在便于对于给定设计运行的输入的自记录。 对于Rosetta设计，该名称包括所使用的最终参考能量和最终净电荷，对于AvNAPSA设计，该名称包括净电荷和突变残基的最大AvNAPSA值。 下面是一个AvNAPSA-positive supercharging的输出文件，lysine总是被选择： 12345678NATAAstart 6 A PIKAA K 19 A PIKAA K 21 A PIKAA K 32 A PIKAA K 34 A PIKAA K 39 A PIKAA K 下面是一个Rosetta-positive supercharging的输出文件，其允许天然和RK之间的选择，并且保留h键: 1234567891011121314151617NATAAstart 6 A PIKAA ERK 9 A PIKAA TRK 11 A PIKAA VRK 21 A PIKAA DRK 25 A PIKAA HRK 26 A NATAA #same charge 30 A NATAA #same charge 32 A NATRO #has sc hbond energy=-1.15844 38 A PIKAA TRK 39 A NATRO #has sc hbond energy=-1.33149 43 A PIKAA TRK 50 A NATRO #has sc hbond energy=-0.536622 52 A NATAA #same charge 76 A PIKAA DRK 77 A PIKAA HRK","categories":[{"name":"蛋白建模","slug":"蛋白建模","permalink":"http://kangsgo.com/categories/蛋白建模/"}],"tags":[{"name":"Rosetta","slug":"Rosetta","permalink":"http://kangsgo.com/tags/Rosetta/"}]},{"title":"gromacs使用额外水模型","slug":"gromacs使用额外水模型","date":"2018-05-07T11:27:12.000Z","updated":"2018-05-07T11:40:00.656Z","comments":true,"path":"46.html","link":"","permalink":"http://kangsgo.com/46.html","excerpt":"","text":"在我们MD中我们有时候很少进行水模型的选择，很多时候我们对于不要求精确的体系使用spc水模型，对于相对要求精确的模型一般使用tip3p模型，对于离子或者小分子的研究有时候使用tip4p的模型，这些在gromacs中都是含有的，但是水模型一直在发展，不同的体系可能对于水模型有较大的变化，具体可以查看水模型的综述页面。例如核酸中用的较多的除了tip4p-eW水模型以外还有OPC水模型，但是该水模型并未在gromacs中自带，所以需要自己构建，以下简单介绍方法: 关于OPC水模型简化的经典水模型是实际原子模拟中不可缺少的组成部分。然而，尽管经过几十年的深入研究，这些模型还远未完善。我们开发了一种新的方法来构建广泛使用的点电荷水模型，这与主流水模型参数化技术完全不同。与传统方法相比，除了对称性之外，我们不对模型施加任何几何约束。相反，我们优化点电荷的分布以最好地描述水分子的“静电”。我们使用这种新方法开发了4点OPC和3点OPC3刚性水模型，与常用的刚性模型相比，该模型显示出更为精确地重现大部分的性质。 以OPC水模型为例首先进行下载GROMACS的OPC，topol文件，若没有带拓扑文件，可以使用例如ACPYPE进行转化。OPC水模型的topol文件完整如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ atomtypes ]OW OW 0.0000 0.0000 A 3.16655e-01 8.903586e-01HW HW 0.0000 0.0000 A 0.00000e+00 0.00000e+00MW MW 0.0000 0.0000 A 0.00000e+00 0.00000e+00[ moleculetype ]; molname nrexclSOL 2[ atoms ]; id at type res nr res name at name cg nr charge mass 1 OW 1 SOL OW 1 0 16.00000 2 HW 1 SOL HW1 1 0.67914 1.00800 3 HW 1 SOL HW2 1 0.67914 1.00800 4 MW 1 SOL MW 1 -1.35828 0.00000#ifndef FLEXIBLE[ settles ]; i funct doh dhh1 1 0.08724 0.13712#else[ bonds ]; i j funct length force.c.1 2 1 0.08724 502416.0 0.08724 502416.01 3 1 0.08724 502416.0 0.08724 502416.0[ angles ]; i j k funct angle force.c.2 1 3 1 103.6 628.02 103.6 628.02#endif[ virtual_sites3 ]; Vsite from funct a b4 1 2 3 1 0.147722363 0.147722363[ exclusions ]1 2 3 42 1 3 43 1 2 44 1 2 3; The position of the virtual site is computed as follows:;; O; ; V; ; H H;; Ewald OPC:; const = distance (OV) / [ cos (angle(VOH)) * distance (OH) ]; 0.01594 nm / [ cos (51.8 deg) * 0.0872433 nm ]; then a = b = 0.5 * const = 0.147722363;; Vsite pos x4 = x1 + a*(x2-x1) + b*(x3-x1) 我们可以在topol或者ffnobonded.itp中恰当的位置写入123;opcHW_opc 1 1.008 0.0000 A 0.00000e+00 0.00000e+00OW_opc 8 16.00 0.0000 A 3.16655e-01 8.903586e-01 为了防止污染我把原拓扑中的原子类型增加了后缀，以免报错。然后将原top中的[ atomtypes ]部分删除，重命名为opc.itp. 由于我们使用的为4点电荷，我是使用的gromacs中tip4p那一套，反正要进行预平衡的，当然也可以自己预平衡一个水，制作一个gro文件。简单介绍一下我用tip4p选择水模型以后，仅需将topol文件中的水拓扑文件替换为如下: 12; Include water topology#include &quot;./amber_na.ff/opc.itp&quot; 值得注意的是opc水模型在md过程中需要进行长程色散校正或者使用Lennard Jones PME,即以下mdp设置二选一（默认的gromacs教程中有1设置） 121. DispCorr = EnerPres (Tested)2. vdwtype = PME 参考资料:https://bioinformatics.cs.vt.edu/~izadi/","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Pymol之保存","slug":"Pymol之保存","date":"2018-05-05T13:09:30.000Z","updated":"2018-05-05T13:11:05.267Z","comments":true,"path":"45.html","link":"","permalink":"http://kangsgo.com/45.html","excerpt":"","text":"保存文件简单的保存笔记，仅个人之用，所以可能有点潦草 PyMOL可以使用save命令：保存 .pdb, .pqr, .mol, .sdf, .pkl, .pkla, .mmd, .out, .dat, .mmod, .pmo, .pov, .png, .pse, .psw, .aln, .fasta, .obj, .mtl, .wrl, .idtf, .dae, or .mol2格式 同样可以保存PyMOL缓存文件.pse 另外还可以保存CLUSTALW类似比对文件.aln 使用一般格式为1save file [,(selection) [,state [,format]] ] 例子12345678# 只保存alpha 碳原子save onlyCAs.pdb, n. CA# 保存轨迹文件save myTraj.pdb, myMDTrajectory, state=0# 保存为PyMOL 缓存文件save thisSession.pse PYMOL API1cmd.save(filename[, selection[, state[, format]]]) 保存高质量图片有时候我们需要科研制图，保存高质量如300dpi的图片，新的（2.0）PyMOL版本可以直接在ray的时候进行选择修改，相当方便，如果是用的老版本或者喜欢用命令的朋友，可以使用如下方法: 渲染的时候进行dpi的的更改1ray 长,宽 保存的时候进行dpi的更改1png fileName, dpi=300 当然也可以进行长宽的修改: 1png filename[, width[, height[, dpi[, ray[, quiet]]]]] 其中ray模式表示是否在保存之前进行渲染 如果需要设置透明背景，可以如下操作:1set ray_opaque_background, 0 例子123456png ~/Desktop/test.png, width=10cm, dpi=300, ray=1# 渲染ray 576,576 # 8inch * 72dpiray 800,800 # 8inch * 100dpi; or a 4inch * 200 DPI photo; or 1x800.ray 2400,2400 # 8inch * 300dpi; 6\"x400dpi, etc... PyMOL API1cmd.png(string filename, int width=0, int height=0, float dpi=-1, int ray=0, int quiet=0) 参考资料:Save [Png](https://pymolwiki.org/index.php/Png)","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"Pymol加载对称单元","slug":"Pymol加载对称单元","date":"2018-05-05T09:09:30.000Z","updated":"2018-05-07T10:49:27.939Z","comments":true,"path":"44.html","link":"","permalink":"http://kangsgo.com/44.html","excerpt":"","text":"有时候有一些蛋白是对称单元组成的，如铁蛋白，但是晶体结构pdb坐标只有一部分，另外一部分写在信息里，我们如果想看全部或者需要全部的pdb坐标，可以使用如下方法实现: Assembly该功能需要PyMOL 1.8以上设置对称单元，如下: 1234567set assembly, \"\"fetch 3bw1, asu, async=0set assembly, 1fetch 3bw1, assembly1, async=0set grid_mode BiologicalUnit/Quat该方法可以重构pdb的另外一边 python代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123'''(c) 2010-2011 Thomas Holder, MPI for Developmental BiologyModule for reading REMARK records from PDB files and in particulargenerate quaterny structure from REMARK 350.'''import sys, osfrom pymol import cmd, storedlocal_mirror_divided = '/mnt/bio/db/pdb.divided'def pdbremarks(filename): ''' Read REMARK lines from PDB file. Return dictionary with remarkNum as key and list of lines as value. ''' remarks = dict() if not isinstance(filename, basestring): f = filename elif filename[-3:] == '.gz': import gzip f = gzip.open(filename) else: f = open(filename) for line in f: recname = line[0:6] if recname == 'REMARK': num = int(line[7:10]) lstring = line[11:] remarks.setdefault(num, []).append(lstring) return remarksdef quat350(rem350): ''' Get transformation matrices for biomolecule 1 from REMARK 350. ''' biomt = dict() chains = tuple() seenbiomolecule = False for line in rem350: if line.startswith('BIOMOLECULE:'): if seenbiomolecule: break seenbiomolecule = True elif line.startswith('APPLY THE FOLLOWING TO CHAINS:'): chains = tuple(chain.strip() for chain in line[30:].split(',')) elif line.startswith(' AND CHAINS:'): chains += tuple(chain.strip() for chain in line[30:].split(',')) elif line.startswith(' BIOMT'): row = int(line[7]) num = int(line[8:12]) vec = line[12:].split() vec = map(float, vec) biomt.setdefault(chains, dict()).setdefault(num, []).extend(vec) return biomtdef quat(name=None, filename=None, prefix=None, quiet=0): '''DESCRIPTION Read REMARK 350 from `filename` and create biological unit (quaternary structure)USAGE quat [name [, filename [, prefix]]]ARGUMENTS name = string: name of object and basename of PDB file, if filename is not given &#123;default: first loaded object&#125; filename = string: file path &#123;default: &lt;name&gt;.pdb&#125; prefix = string: prefix for new objects &#123;default: &lt;name&gt;&#125;EXAMPLE fetch 1rmv, type=pdb quat 1rmv ''' quiet = int(quiet) if name is None: name = cmd.get_object_list()[0] if prefix is None: prefix = name if filename is None: candidates = [ '%s.pdb' % (name), '%s/%s.pdb' % (cmd.get('fetch_path'), name), '%s/%s/pdb%s.ent.gz' % (local_mirror_divided, name[1:3], name), ] for filename in candidates: if os.path.exists(filename): break else: print 'please provide filename' return if not quiet: print 'loading from %s' % (filename) remarks = pdbremarks(filename) if 350 not in remarks: print 'There is no REMARK 350 in', filename return quat = quat350(remarks[350]) for chains in quat: matrices = quat[chains] for num in matrices: mat = matrices[num][0:12] mat.extend([0,0,0,1]) copy = '%s_%d' % (prefix, num) if not quiet: print 'creating %s' % (copy) cmd.create(copy, '/%s//%s' % (name, '+'.join(chains))) cmd.alter(copy, 'segi=\"%d\"' % (num)) cmd.transform_object(copy, mat) cmd.disable(name) cmd.group('%s_quat' % (prefix), '%s_*' % (prefix))cmd.extend('quat', quat)# vi:expandtab:smarttab 使用方法非常简单:123fetch 3bw1, type=pdbquat 3bw1as cartoon 以下是前后的区别:前: 后: 参考资料:BiologicalUnit","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"Gromacs教程2-水中的单个甲烷","slug":"Gromacs教程2-水中的单个甲烷","date":"2018-04-25T10:32:12.000Z","updated":"2018-04-25T11:26:08.737Z","comments":true,"path":"43.html","link":"","permalink":"http://kangsgo.com/43.html","excerpt":"","text":"原文：James (Wes) Barnett翻译：谷歌/康文渊-湖南大学 在本教程中，我将向您展示如何在一个盒子的TIP4PEW水中创建一个包含一个OPLS力场甲烷的系统。 ##设置和以前一样，我们需要一个结构文件，一个拓扑文件和参数文件。我们将使用GROMACS工具gmx pdb2gmx从pdb文件生成拓扑。 用pdb2gmx设置残基对于这个分子，我们将使用OPLS力场。 力场位于顶层力场目录（可能是/usr/share/gromacs/top或类似的东西）。 如果您不确定您的GROMACS安装位置在哪里，可以使用如下命令： 1$ echo $ GMXPREFIX 如果您sourcing 了GROMACS配置文件，则会为您提供安装位置。在该目录中找到share/gromacs/top并进入它（例如，如果GMXPREFIX是/usr，则转到/usr/share/gromacs/top）。或者你可以简单地转到$GMXDATA/top。 我们来看看force field目录的内容： 12$ cd oplsaa.ff$ ls 你会看到几个文件，但我们现在只对其中的一些文件感兴趣。注意forcefield.itp。这是模拟中使用的主要文件。在里面你会看到一个[defaults]部分以及包含两个其他文件 - 一个用于键联系，另一个用于非键联系。我们也对atomtypes.atp感兴趣，它给出了难以理解的opls _ ####术语的描述以及aminoacids.rtp，它们给出了用于gmx pdb2gmx命令能够识别的氨基酸残基列表。 用你的文本编辑器打开atomtypes.atp,比如用vim打开它： 1$ vim atomtypes.atp 转到opls_138的行。请注意，注释是否为alkane CH4。但是，请注意第二列中的mass - 这只是CH4组的碳，所以我们也需要氢。这是一个“全原子”模型 - 每个原子都被表示出来。相应的氢是opls_140。您可能还需要查看OPLS force field 论文的支持信息。论文中的参数应该与我们刚刚看到的参数相匹配。现在记下这两种原子类型并关闭文件。 让我们来看看这两种原子类型的ffnonbonded.itp： 12$ grep opls_138 ffnonbonded.itp$ grep opls_140 ffnonbonded.itp 在这里，我们看到原子类型的名称，键类型，质量，电荷，ptype，sigma和epsilon。记下每个类型的电荷 - 我们将需要它来构建我们新的氨基酸残基。作为一个方面说明，ffbonded.itp将使用键类型，键类型和二面角类型。 在继续之前，您可能希望将您的顶级力场目录复制到别的地方，例如您的主目录，因为我们将修改它并添加一些文件。将其复制到您的主目录中： 1$ cp -r $GMXDATA/top $HOME/GMXLIB 你可能需要root权限执行它。现在将$ GMXLIB环境变量更改为： 1$ export GMXLIB = $ HOME/GMXLIB 将上述内容添加到.bash_profile中以使其成为永久性的,然后进行执行： 1$ cd $ GMXLIB 您现在处于刚刚拷贝的副本中，所有模拟将使用该目录而不是GROMACS默认目录中提供的目录。 现在进入oplsaa.ff并打开aminoacids.rtp。您会注意到文件中已有多个残基。我们将为我们的甲烷添加一个名为methane.rtp的新文件，其中包含我们称之为CH4的残基。关闭aminoacids.rtp。我们需要告诉gmx pdb2gmx我们的残差文件中原子的原子和键。我们也可以告诉它角度，但是我们会将它们排除在外，因为gmx pdb2gmx会为我们解决这个问题。现在需要在oplsaa.ff目录中创建以下内容并另存为methane.rtp： 1234567891011121314151617[ bondedtypes ]; bonds angles dihedrals impropers all_dihedrals nrexcl HH14 RemoveDih 1 1 3 1 1 3 1 0; Methane[ CH4 ] [ atoms ] C opls_138 -0.240 1 H1 opls_140 0.060 1 H2 opls_140 0.060 1 H3 opls_140 0.060 1 H4 opls_140 0.060 1 [ bonds ] C H1 C H2 C H3 C H4 关于上述文件的一些注意事项：[bondedtypes]来自aminoacids.rtp并且是必需的。 在[atoms]下的名字可以随便命名，但是需要匹配稍后构建pdb文件中的名字。 注意在第一列中我们给出了原子名称，然后我们给出了原子类型，电荷，然后是电荷组。 在[bonds]下，我们只是告诉它每个原子如何连接到其他原子。 在这种情况下，C与每个氢都有连接。我们可以选择添加[angles]，但是如前所述，GROMACS会为我们搞定。 现在关闭文件。 有关这方面的更多信息，请参阅第5.6节。 创建pdb文件并且运行gmx pdb2gmx现在我们准备创建pdb文件。 有几个程序可以创建分子结构文件。例如 Avogadro。 另一种方法是使用AmberTools软件包中的“xleap”。 将这个文件保存为methane.pdb。 你的文件应该看起来像这样。 将其保存在您的主目录中的某个位置，但不在$ GMXLIB中的任何位置。 在methane.pdb中将LIG更改为CH4。还要将第一个H更改为H1，将第二个更改为H2等等。PDB文件是固定格式，因此请将每列的开头保留在相同的位置。CONNECT和MASTER记录也不需要，因此可以删除它们。同时继续并将UNNAMED更改为METHANE。你修改过的文件应该是这样的： 12345678COMPND METHANEAUTHOR GENERATED BY OPEN BABEL 2.3.2HETATM 1 C CH4 1 -0.370 0.900 0.000 1.00 0.00 C HETATM 2 H1 CH4 1 0.700 0.900 0.000 1.00 0.00 H HETATM 3 H2 CH4 1 -0.727 0.122 0.643 1.00 0.00 H HETATM 4 H3 CH4 1 -0.727 0.731 -0.995 1.00 0.00 H HETATM 5 H4 CH4 1 -0.727 1.845 0.351 1.00 0.00 H END 保存文件为methane.pdb. 现在我们可以使用gmx pdb2gmx创建GROMACS .conf和.top文件： 1$ gmx pdb2gmx -f methane.pdb 系统会提示您选择力场。选择OPLS。如果您在两个不同的力场目录之间有一个选项，请选择您所复制目录中的OPLS。对于水模型选择TIP4PEW。如果您发现GROMACS找不到残基CH4的错误，您可能会使用错误的力场。 将创建三个文件：conf.gro，posre.itp和topol.top。conf.gro是我们的文件，只包含一个甲烷，topol.top是系统的拓扑文件，posre.itp是我们溶质（甲烷）的可选位置限制文件。我们不会使用那个。在topol.top文件中注意到有一个[angles]部分。您还需要在topol.top中重命名化合物。看看并探索每个文件。 GROMACS手册的第5章将帮助您更多地了解拓扑文件。 注意：topol.top和methane.pdb将在其他教程中再次使用。 对于那些使用gmx pdb2gmx生成大型蛋白质拓扑的人来说，事情会变得更加复杂。这仅仅是一个简单的例子，我们可能真的可以在其他地方找到这种拓扑。 溶剂体系我们的结构文件和拓扑文件到目前为止只有我们的甲烷。我们需要通过使用gmx solvate来添加水： 1$ gmx solvate -cp conf.gro -o conf.gro -cs tip4p -p topol.top -box 2.3 2.3 2.3 参数文件我们将使用前一教程中的相同文件。 模拟我们将使用与上次相同的流程。这假定您的mdp文件位于名为mdp的目录中： 12345678910$ gmx grompp -f mdp/min.mdp -o min -pp min -po min$ gmx mdrun -deffnm min$ gmx grompp -f mdp/min2.mdp -o min2 -pp min2 -po min2 -c min -t min$ gmx mdrun -deffnm min2$ gmx grompp -f mdp/eql.mdp -o eql -pp eql -po eql -c min2 -t min2$ gmx mdrun -deffnm eql$ gmx grompp -f mdp/eql2.mdp -o eql2 -pp eql2 -po eql2 -c eql -t eql$ gmx mdrun -deffnm eql2$ gmx grompp -f mdp/prd.mdp -o prd -pp prd -po prd -c eql2 -t eql2$ gmx mdrun -deffnm prd 您可以把它当作脚本来使用，在头部添加如下内容: 123#!/bin/bashset -e 然后执行 1$ chmod +x run 运行脚本:1$ ./run 其中set -e表示如果有错误立马停止 分析我们来计算一下称为径向分布函数的东西。首先，我们需要创建一个索引文件： 1$ gmx make_ndx -f conf.gro 123&gt; a C&gt; a OW&gt; q 然后运行 gmx rdf 1$ gmx rdf -f prd.xtc -n index.ndx 在提示时选择C作为参考组。 然后选择OW。 然后输入CTRL-D结束。 数据的第1列和第3列中的结果图将通过在gnuplot中执行以下操作来绘制： 1&gt; plot &apos;rdf.xvg&apos; u 1:3 w l 它应该看起来像这样： 总结在本教程中，我们学习了如何创建一个用于gmx pdb2gmx的残基模板文件（.rtp）。 我们为OPLS甲烷创建了一个结构，并为其生成了一个拓扑。我们用gmx solvated对它周围进行了加水。在此之后，我们进行了仿真，就像上次一样。最后，我们使用gmx rdf发现了C-OW径向分布函数。 问题如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个问题，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅GROMACS文档。 您还可以将关于GROMACS的一般问题通过查阅邮件列表来解决。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Gromacs教程1-水","slug":"Gromacs教程1-水","date":"2018-04-23T10:32:12.000Z","updated":"2018-04-23T07:48:47.783Z","comments":true,"path":"41.html","link":"","permalink":"http://kangsgo.com/41.html","excerpt":"","text":"原文：James (Wes) Barnett翻译：谷歌/康文渊-湖南大学 在本入门教程中，我将向您展示如何创建一个盒子的水，并在恒定的温度和压力下对其进行简单模拟。 最后我们会找出水的密度。 设置每个GROMACS模拟需要三个基本文件：结构（.gro / .pdb），拓扑（.top）和参数（.mdp）。 结构文件包含系统中每个原子位点的笛卡尔坐标。 该拓扑文件包含有关每个原子位点与其他原子位点进行联系的信息，无论该位点是处于非键联系还是键联系。 这个信息由力场提供。 非键相互作用包括范德华相互作用和库仑相互作用。 键相互作用包括键长，角度和二面角。 参数文件包括运行模拟的时间，时间步长，温度和压力耦合等信息。下面我们将获取/创建这些文件。 在这一点上，我会建议创建一个目录来存储本教程的文件。 拓扑文件我们将从拓扑文件开始。 通常，拓扑文件使用#include语句来包含要使用的力场。 这个力场包括[atomtypes]，[bondtypes]，[angletypes]和[dihedraltypes]指令。 然后在拓扑文件中通常我们指定包含[atoms]，[bond]和[dihedrals]的不同[moleculetype]指令，这些指令指向力场。 现在不要担心这个太多。 对我们来说水模型包括上述说的所有这些。有关更多信息，请参阅参考手册的第5章。 用以下文本创建一个名为topol.top的文件：1234567#include &quot;oplsaa.ff/forcefield.itp&quot;#include &quot;oplsaa.ff/tip4pew.itp&quot;[ System ]TIP4PEW[ Molecules ] 正如你所看到的，我们已经包含了OPLS-AA的力场。 另外我们还包括了TIP4PEW水模型。 之后你会看到一个[System]指令，其中只包括系统的名称，可以是任何你想要的。 最后，我们列出每种分子类型以及[Molecules]下的分子类型。 现在我们没有（不过马上我们将要得到这些）。 结构文件TIP4PEW的结构已由GROMACS在拓扑目录中提供。 这个标准位置通常是/usr/share/gromacs/top，但是我已经将它安装在不同的目录中。 如果您正确采购GMXRC，那么它将位于$GMXDATA/top。 在该目录中，您会看到几个.gro文件，其中之一是tip4p.gro。您还会看到上面我们的拓扑文件中包含的文件夹oplsaa.ff。没有特别的TIP4PEW结构文件。TIP4P和TIP4PEW的四点水结构基本相同。 他们仅是力场参数不同。 要使用该结构文件创建一盒水，请执行以下操作：1$ gmx solvate -cs tip4p -o conf.gro -box 2.3 2.3 2.3 -p topol.top 如果你打开topol.top文件，你会看到最后添加了一行SOL和number。SOL是在oplsaa.ff/tip4pew.itp中定义的moleculetype的名称。 当我们运行gmx solvate时，GROMACS在每个方向2.3 nm的盒子中添加了足够的水分子。 参数文件现在我们需要一组参数文件，以便GROMACS知道如何处理我们的起始结构。 模拟几乎总是有三个主要部分：最小化，平衡和生产。 最小化和平衡可以分解为多个步骤。 这些都需要它自己的参数文件。 在这种情况下，我们将进行两次最小化，两次平衡和一次生产运行。 我们将要使用的文件可以从这里下载。 我们所有五个文件都有一些共同点。 在每个描述中，我只给出一个非常小的注释。有关每个选项的更多信息，请参阅GROMACS页面。 参数 值 解释 cutoff-scheme Verlet 用于创建邻近列表。 这是现在的默认设置，但我们在这里提供它以避免任何注释。 coulombtype PME 使用 Particle-Mesh Ewald for long-range (k-space) 点荷联系. rcoulomb 1.0 Cut-off for real/k-space for PME (nm). vdwtype Cut-off van der Walls forces cut-off at rvdw rvdw 1.0 Cut-off for VDW (nm). DispCorr EnerPress VDW对能量和压力的长程校正。 应该设置截断距离，同时要记住力场是如何参数化的。换句话说，看看描述力场如何创造的期刊文章是一个好主意。我们在这里选择了1.0纳米作为截止点，这对于OPLS来说已经足够普遍了，但是您可以确定系统选择其他方法。 此外，在每个部分中，我们还将输出能量文件，日志文件和压缩轨迹文件。输出的速率（在模拟步骤中）分别使用nstenergy，nstlog和nstxout-compressed进行设置。我们将在生产运行中输出更多信息。 对于每个部分，除了第二次最小化之外，我们还将通过设置constraint-algorithm = lincs和constraints = h-bonds，使用LINCS算法约束所有涉及氢的键。这使我们能够使用比其他更大的时间步骤。 对于第一次最小化，我们使用最陡峭下降算法，通过设置integrator = steep来最小化系统能量，最大步长为1000步（nsteps = 1000）。如果在此之前能量收敛，则最小化将停止。另外我们进行define = -DFLEXIBLE。这让GROMACS知道使用灵活的水，因为默认情况下所有的水模型都是使用SETTLE算法为刚性模型。在我们拥有的水模型的拓扑文件中，有一个if语句查找要定义的FLEXIBLE变量。第一次最小化的目的是使分子处于良好的起始位置，这样我们就可以无任何错误地打开SETTLE。 在第二个最小化中，我们只需删除define = -DFLEXIBLE并将最大步数增加到50,000。 最后三部分-两个平衡和生产-都使用integrator = md。此外，通过设置dt=0.002来使用2fs时间步长。 对于第一个平衡步骤，有几点需要注意。我们正在添加如下所示的几个参数： –参数– –值– –解释– gen-vel yes 根据Maxwell-Boltzmann分布为每个原子位点生成速度。只为您的第一个平衡步骤生成速度。这使我们接近我们将耦合系统的温度。 gen-temp 298.15 K中的温度用于gen-vel。 除非你正在做一些奇怪的/有趣的事情，否则这应该与ref-t相同。 tcoupl Nose-Hoover 用于温度耦合的算法。 Nose-Hoover 为经典温度耦合算法。 tc-grps System 要结合哪些组。 你可以将不同的原子组分开，但我们只需要耦合整个系统。 tau-t 2.0 耦合的时间常数。 详情请参阅手册。 ref-t 298.15 以K为单位的温度。 nhchainlength 1 Leap-frog integrator 只支持1，但默认情况下这是10。这是设置，所以GROMACS不会发出警告。 第一次平衡的关键是在加压耦合之前让我们达到正确的温度（298.15 K）。 同时添加温度和压力耦合可能会导致系统不稳定并发生崩溃。 我们不想在一开始就震惊我们的系统。 另外，我们设置了nsteps = 50000，所以以2fs的时间步长，这意味着它将运行100ps。 这对我们在这里所做的工作是足够的，但是在更大/更复杂的系统中，您可能需要更长时间的平衡。 第二个平衡增加了压力耦合。 请注意，我们并没有再次产生速度，因为那样会取消我们刚刚做的一些工作。 我们还为约束设置了continuation = yes，因为我们从第一次平衡开始继续进行模拟。 这部分将运行1ns。 同样，对于其他系统，这可能需要更长一些。 –参数– –值– –解释– pcoupl Parrinello-Rahman 用于压力耦合的算法。 Parrinello-Rahman在与Nose-Hoover一起使用时正确地产生了等压等温线。 tau-p 2.0 耦合的时间常数。 详情请参阅手册。 ref-p 1.0 压力耦合常数 compressibility 4.46e-5 系统压缩系数 对于生产运行，除了输出更多数据并运行10 ns外，所有内容与上次平衡完全相同。 模拟我们现在有了我们需要的所有文件来运行模拟的每个部分。 每个部分通常运行gmx grompp，以将我们现在具有的三个文件（.gro，.top和.mdp）预处理为.tpr文件（有时也称为拓扑文件）。 最小化首先，通过执行以下操作来执行我们的两个最小化步骤：12345$ gmx grompp -f mdp/min.mdp -o min -pp min -po min$ gmx mdrun -deffnm min$ gmx grompp -f mdp/min2.mdp -o min2 -pp min2 -po min2 -c min -t min$ gmx mdrun -deffnm min2 在每个部分，我们都使用-f标志在.mdp文件中读取。默认情况下，如果未指定-c和-p标志，GROMACS将使用conf.gro和topol.top作为结构和拓扑文件。此外，我们正在输出处理后的拓扑文件-pp和mdp文件-po。这些是可选的，但可能值得一看，尤其是处理过的mdp文件，因为它已被评论。 在接下来的每一步中，我们使用-c和-t标志读入前一步的最后一个结构文件或检查点文件。默认情况下，GROMACS每15分钟和最后一步输出检查点文件。如果检查点文件不存在，GROMACS将使用由-c定义的结构文件，因此指定两者都是一种很好的做法。在每个gmx mdrun中，我们都告诉GROMACS为每个输入和输出文件使用默认名称，因为会输出多个文件。 注意我们使用-maxwarn 1来进行第二次最小化。只有使用这个标志，如果你知道你在做什么！在这种情况下，我们会收到关于我们可以安全绕过的L-BFGS效率的警告。 为了了解发生了什么，让我们使用GROMACS命令gmx energy来提取这两个部分的势能。执行以下操作并输入与Potential对应的数字，然后再次输入：1$ gmx energy -f min.edr -o min-energy.xvg 相似的行为进行第二次能量最小化的阅读1$ gmx energy -f min2.edr -o min2-energy.xvg 结果.xvg的标题。 文件将包含供Grace绘图程序使用的信息。 我使用gnuplot，所以这些行中的一些会导致错误。 我用.xvg中的＃替换每个@字符。然后我可以使用gnuplot。首先启动gnuplot进行绘图：1$ gnuplot 在gnuplot终端输入如下命令:1&gt; plot 'min-energy.xvg' w l 第二次如下:1&gt; plot 'min2-energy.xvg' w l 第一次的结果类似如下: 第二次结果没有改变，所以未在此绘出 Equilibration 1 (NVT)现在我们有了一个好的起始结构，让我们通过添加温度耦合来完成第一个平衡步骤：12$ gmx grompp -f mdp/eql.mdp -o eql -pp eql -po eql -c min2 -t min2$ gmx mdrun -deffnm eql 我们来看看整个模拟过程中温度如何变化：1$ gmx energy -f eql.edr -o eql-temp.xvg 在提示符下选择与温度相对应的数字，然后再次输入。 像上面那样在gnuplot中绘制它。 你应该看到像这样的东西： 请注意，温度最初会波动很大，但最终会稳定下来。 Equilibration 2 (NPT)如前所述，对于我们上次的平衡，我们添加了一个压力耦合：12$ gmx grompp -f mdp/eql2.mdp -o eql2 -pp eql2 -po eql2 -c eql -t eql$ gmx mdrun -deffnm eql2 您可以使用上述gmx energy检查温度和压力。绘图类似如下： 请注意，压力波动很大，这是正常的。 在这种情况下，完全平衡后的平均值应接近1 bar。 正式模拟正式模拟部分如下:12$ gmx grompp -f mdp/prd.mdp -o prd -pp prd -po prd -c eql2 -t eql2$ gmx mdrun -deffnm prd 分析在prd.edr上使用上面的gmx energy，得到平均温度，压力和密度。 他们是你期望的吗？ 这是我的输出：12345Energy Average Err.Est. RMSD Tot-Drift-------------------------------------------------------------------------------Temperature 298.145 0.019 8.65629 0.0338992 (K)Pressure 3.25876 0.97 688.616 -2.75083 (bar)Density 995.381 0.15 12.92 0.0705576 (kg/m^3) 如果你看图4中的TIP4PEW论文，你可以看到我们已经达到了正确的密度。 另外请注意，Wolfram Alpha表示标准条件下的水密度为997 kg /立方米。 你也可以使用像vmd这样的程序来模拟你的模拟。 用vmd打开正式模拟的轨迹：1$ vmd prd.gro prd.xtc 快照如下: 进行周期性处理1$ gmx trjconv -f prd.xtc -s prd.tpr -pbc mol -o prd-mol.xtc 后结果如下: 总结在本教程中，我们使用gmx solvate物产生一盒TIP4PEW水。 我们在五个不同的部分对它进行了模拟：最小化1，最小化2，平衡1，平衡2和生产。 每个部分都使用自己的.mdp文件进行了解释。 在每个部分，我们使用gmx energy来提取有关模拟的有用信息。 生产运行后，我们能够找到TIP4PEW水的密度。 问题如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个问题，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅GROMACS文档。 您还可以将关于GROMACS的一般问题通过查阅邮件列表来解决。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Gromacs教程","slug":"Gromacs教程介绍","date":"2018-04-23T10:27:12.000Z","updated":"2018-04-23T07:40:02.606Z","comments":true,"path":"42.html","link":"","permalink":"http://kangsgo.com/42.html","excerpt":"","text":"这些是针对初学者的一些GROMACS教程。没有必要按顺序完成教程，但前两个教程在进入其他教程之前是必不可少的，因为后续教程全部使用了来自教程2的甲烷的结构文件(methane.pdb)和拓扑文件(topol.top)。这些教程是为GROMACS 5.1及更高版本设计的。如果您使用的是旧版本，则某些命令或参数可能已更改。 特别要注意的是，自5.0和更早版本以来，伞状采样的代码已经发生了变化。 要求我假设你有一些关于命令行的相关知识。具体而言，您应该知道如何创建目录，更改目录，编辑文本文件以及将文件下载到系统中。 当您看到$或&gt;时，这是命令行中的提示，并指示您应该输入它后面的文本。 如果命令行对您来说是新手，请考虑通过CodeAcademy教程进行学习。 我还假设你已经在可用的机器上安装了GROMACS。 源代码和安装说明可以在GROMACS文档页面找到。 在整个教程中，我们将使用OPLS(力场)甲烷和TIP4PEW水。 内容 水 - 建立基础模拟。找出TIP4PEW水的密度。 一个甲烷在水中 - 如何为分子创建拓扑文件并将其溶剂化。获取径向分布函数。 几个甲烷在水中 - 如何将多种溶质放入系统中。获得甲烷-甲烷之间的平均力势(PMF)。 甲烷溶剂化自由能 - 如何在偶联分子时进行自由能模拟。使用MBAR获取结果。 伞状采样 - 使用pull代码从伞状采样中获得甲烷-甲烷的平均力势。 测试颗粒插入 - 使用测试颗粒插入获得甲烷的过量化学势。 问题如果您对翻译有什么问题，可以通过kangsgo at. vip.qq.com发邮件与我联系。如果教程中存在错误或错误，或者如果有什么不清楚的地方，请打开一个问题，我很乐意解决它。 如果您有关于GROMACS的一般问题，请参阅GROMACS文档。 您还可以将关于GROMACS的一般问题通过查阅邮件列表来解决。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Rosetta系列-PyRosetta安装","slug":"Rosetta系列-PyRosetta安装","date":"2018-04-10T10:27:12.000Z","updated":"2018-04-11T02:31:50.976Z","comments":true,"path":"36.html","link":"","permalink":"http://kangsgo.com/36.html","excerpt":"","text":"转载请联系，且保留链接 PyRosetta是一个Python为基础的Rosetta交互套件。其打开了用户自定义的利用Rosetta采样方法和能量函数进行自定义建模的方法。 安装在下载页面选择合适的版本 1234567891011#解压tar -vjxf PyRosetta-&lt;version&gt;.tar.bz2.# 移动位置mv PyRosetta&lt;version&gt; PyRosetta4# 进入cd PyRosetta4#安装cd setup &amp;&amp; python setup.py install","categories":[{"name":"蛋白建模","slug":"蛋白建模","permalink":"http://kangsgo.com/categories/蛋白建模/"}],"tags":[{"name":"Rosetta","slug":"Rosetta","permalink":"http://kangsgo.com/tags/Rosetta/"}]},{"title":"Rosetta系列-FloppyTail构建蛋白柔性尾","slug":"Rosetta系列-FloppyTail构建蛋白柔性尾","date":"2018-04-10T10:27:12.000Z","updated":"2018-04-11T05:11:24.931Z","comments":true,"path":"35.html","link":"","permalink":"http://kangsgo.com/35.html","excerpt":"","text":"转载请联系，且保留链接 使用这个代码需要蛋白具有长的柔性尾，在晶体结构中是缺失的，生物化学证据表明已知结合伴侣上尾部的特定结合位点.该代码旨在模拟长柔性尾巴的范围并确定假设的结合位点是否合理。 该工具更有用于测试关于可能的构象的假设，并探索可用的构象空间，而不是找到“唯一真正的结合模式”。 如果你的尾巴真的很灵活，它可能没有一个“真正的结合模式”。 代码和演示代码位于rosetta/main/source/src/apps/public/scenarios/FloppyTail/ 演示位于rosetta/main/tests/integration/tests/FloppyTail/ FloppyTail哲学-怎么解决问题FloppyTail旨在“约束对接”。 当你有一个或多个相对刚性的结构时，可以使用它，并用linker链接。 对于一些情况，如最初的柔性尾巴，问题是“这条尾巴可以对接进入刚性尾巴？”对于某些情况，例如两个结构域之间的linker区域，可能是“这两个区域对接，鉴于一些构象是不可能的，因为linker不能伸展那么远？“ 一般来说，FloppyTail为 FLEXIBLE linkers发挥作用。 这有两个问题。 首先，Rosetta能量函数被参数化为折叠良好的晶体蛋白质。 它只适用于灵活的linkers，因为它的物理观点不允许非结构化的可溶性蛋白质。 其次，灵活的linkers在时间上是灵活的，但是静态结构没有时间域，因此通过查看得分高的模型并不能非常有用的表达linker区域的状态。 因此，使用FloppyTail并解释其结果需要仔细考虑结果的价值。 如果你的目标是“我有两种相互连接的蛋白质，我想知道它会是什么样子” - 这是一个昂贵的问题，成功率很低。 如果你没有实验数据，你可以使用FloppyTail生成假说。看看你的结果集合，看看更好的模型中经常发生什么样的相互作用，然后考虑如何通过实验测试这些相互作用是否真实（如通过交叉链接或者突变） 也许你有一个可能存在的构象的概念，你想在试验之前进行计算检查。 在这种情况下，尝试使用约束您感兴趣的构象，以查看系统是否可以适应它。 如果你淘汰那些仍然没有你想要的互动模式，或者只能通过非常别扭的几何来实现它，那么FloppyTail就会产生一个负面结果。 如果你拥有实验结果-非常棒！约束想要走的路子。运行约束，你将获得更高质量的模型假设。或者，可以使用约束来过滤不受限制的结果，或者只是使用它们来判断模型总体是否现实。这使您可以生成系统可能执行的与您的约束条件一致的“信封”，可根据需要将其用于进一步的实验循环。 算法该算法非常简单：在质心模式下，小/剪切/碎片移动将尾部折叠成某种形式的折叠构型，而小/剪切随重新包装而移动以改善其位置。 这在概念上类似于abinitio折叠的工作方式，虽然它不是为此目的而精炼的 该代码与质心阶段中的约束兼容（通过命令行传入）。 早期的建模使用约束和一些小小的黑科技来帮助指导模型到假设的尾结合位置。 最终，这对于原始系统来说不是必需的，但代码保留了使用约束等的能力。 更新：代码与两个阶段的约束兼容。 限制该代码无法进行“半-从头建模”的工作，即知道一半的结构，求另一半。改代码仅测试用于构建真实情况下是松软，无序的尾巴。该代码的目的并不是折叠进精炼结构。 如果想要实现上述不能实现的目的，可以考虑使用Topology Broker‘s 的RigidChunk环境。 输入文件可以在tests/integration/tests/FloppyTail/查看例子 首先需要处理PDB文件，删除杂原子，多重定义原子和水等等 该代码不会为您扩展添加。 您需要为灵活的尾部添加起始坐标（虽然无意义).把它直接指向空间（就像它在演示中一样）。 或者，使用PyRosetta脚本 / pyrosetta / public/floppy_tail_utility/,可以更新输入结构（存在无序残基）这样可以扩展或者增加尾部（那样你就无需添加尾部起始坐标）。 fragment file 和constraint file 查看怎么输入和约束 小贴士也可以进行两个区域之间的内部柔性区域的建模 如果需要构建大的尾部，需要进行长时间的轨迹模拟，2.3Hz的电脑大约完成30000/天 轨迹 约束条件是一种极好的方式，可以使建模偏向于测试假设的构想是否可行。 如果不是重复文献不要运行-publication标签 在建模终端柔性区域（尾部）时，在细化阶段，可以使用short_tail_xxx选项将协议引导为针对部分精化模式对尾部的较短部分建模。 原因在于，即使重新包装（质心往往对于这种对接来说有点太小），在质心模式下的结构中尾部可能与结合伴侣过于接近。 通过在改进的第一部分重塑尾巴的尖端，您可以放松碰撞而不将尾巴摆回太空。 如果您有单链（一种蛋白质），如果灵活区域比C端更接近N端，可以使用C_root选项来加快计算速度。 如果构建N端尾，必须使用C_root设置 使用force_linear_fold_tree，当你需要进行折叠C到N之间的链 设置FloppyTail设置 参数 类型 简介 -flexible_start_resnum -integer PDB中的柔性尾起始编号，如果使用，那么同时要求-flexible_chain的设置 flexible_stop_resnum -integer 不使用此选项意味着flexible_start_resnum之后的整个链。如果使用，那么同时要求-flexible_chain的设置 -flexible_chain - string 该字符串的第一个字符被解释为灵活区域的PDB链; 任何其他字符都将被忽略。 -shear_on - real 在质心模式下，当尾部仍大部分延伸时，剪切移动在初期完全无效。 该值给出剪切移动允许时的质心周期分数。例如，传递0.333意味着对于质心模式的前三分之一，剪切移动将被禁止。 -short_tail::short_tail_fraction -real Fraction of the tail used in the short tail fraction of refinement mode. 0.1 would mean the last tenth of the tail is flexible. Not compatible with non-terminal flexible regions. -short_tail::short_tail_off -real Fraction of refinement cycles dedicated to refining only the short part of the tail. 0.33 means the first third of refinement cycles will be with the shorter flexible region. -pair_off - boolean 如果为真，关闭静电Epair，一般不用 -publication - boolean 一般不用 -FloppyTail::cen_weights - string 使用自定义质心得分函数，对于质心建模时期，一般不用 Kinematics设置 参数 类型 简介 -C_root - boolean 如果为真，重构C端折叠树，如果构建N端尾时使用 -force_linear_fold_tree - boolean 强制线性折叠树。 如上所述使用C_root并重新排序输入PDB中的链，以确保正确的运动。 蒙特卡罗采样设置 参数 类型 简介 -FloppyTail::perturb_temp -real Monte Carlo temperature for perturb phase (0.8 used for production) -FloppyTail::perturb_cycles -unsigned integer number of perturb phase cycles (5000 used for production) -FloppyTail::perturb_show -boolean - if true, outputs centroid poses after perturbation -FloppyTail::debug -debug - if true, outputs poses for each monte carlo cycle -FloppyTail::refine_temp -real Monte Carlo temperature for refine phase (0.8 used for production) -FloppyTail::refine_cycles -unsigned integer number of refine phase cycles (3000 used for production) -FloppyTail::refine_repack_cycles -unsigned interger Perform a repack/minimize every N cycles of refine mode (30 used for production) 一般设置 参数 类型 简介 -packing::resfile -string Resfile文件 -packing::repack_only -boolean 告诉代码不要执行设计。 设计是默认执行的，因为PackerTasks的行为就是这样。 -in::file::frag3 -string 片段文件 -run::min_type -string Minimizer type. dfpmin_armijo_nonmonotone used for production. -nstruct -integer 生成的结构数量 -constraints::cst_file -string 约束文件（质心） -constraints::cst_weight -real 约束权重（质心） -constraints::cst_fa_file -string 约束文件（全原子） -constraints::cst_cst_fa_weight -real 顾名思义 多柔性linkers模式略，主要使用movemap 后处理你可能是使用这个模型进行未知结构区域的建模。你不应该花大量的时间在单独的结构中。 一般而言，您应该选择模型预测的一些指标（如果您阅读论文，您会发现它是后来发现可化学交联的两个残基之间的距离）。 然后，您可以挖掘模型群体，以查看这个指标在模型的最高分数中的样子。 extra_analysis功能将有助于此。 我建议直方图。 可能遇到的问题123/Rosetta/main/source/bin/FloppyTail..mpi.linuxgccrelease: error while loading shared libraries: libsqlite3.so: cannot open shared object file: No such file or directory 如报这样的错误，ubuntu用户可以使用如下解决:1sudo apt-get install libsqlite3-dev 例子原例子位于rosetta/main/tests/integration/tests/FloppyTail/ 可以打开查看pdb文件 直接运行即可结果如下: 数据库修正以后 其设置如下:1234567891011121314151617181920212223242526272829303132333435363738394041-restore_talaris_behavior #输入 PDB-s complex_readytail_final_nozn.pdb.gz-use_input_sc-packing:repack_only#最小化类型-run:min_type dfpmin_armijo_nonmonotone#尾部起始点-FloppyTail:flexible_start_resnum 180#尾部终止点，因为终止到最后，所以不需要#-FloppyTail:flexible_stop_resnum #加尾链-FloppyTail:flexible_chain C#used for preventing loss of compactness at centroid/fa switch; see documentation-FloppyTail:short_tail:short_tail_off 0-FloppyTail:short_tail:short_tail_fraction 1.0#见文档-FloppyTail:shear_on .33333333333333333333#将其关闭以用于其他用途; 激活为设置出版物相关指标-FloppyTail:publication true#repacking频率; 10 一般用于测试#-FloppyTail:refine_repack_cycles 100-FloppyTail:refine_repack_cycles 10#最终产出数量#-FloppyTail:perturb_cycles 5000#-FloppyTail:refine_cycles 3000#-nstruct 5000#runs in 26 seconds on my machine-FloppyTail:perturb_cycles 100-FloppyTail:refine_cycles 20-nstruct 1 具体内容可以参考文献3.的支撑材料 E.Coli Hfq 例子 首先获得E.Coli的晶体结构 1wget http://www.rcsb.org/pdb/files/1HK9.pdb 删除非ATOM的行 1grep ATOM 1hk9.pdb &gt; 1hk9.clean.pdb 在这里需要安装PyRosetta，安装步骤和简单介绍可以查看这里 在PyRosetta里的apps/floppy_tail_utility路径里的所有脚本拷贝到实验路径下，extend_terminus.py脚本附加(append)/前置增加(prepend)端口序列。残基设置的φ/ψ值为-135°/135°。例如前置增加”MAKGQ”到链A的N端，命令如下: 1python extend_terminus.py –c A –o 1hk9.Ap.pdb –p 1hk9.clean.pdb MAKGQ 脚本参数包含如下: a. -c 标签选择链 b. -p为N端,-a为C端输入文件 c. -o为输出文件 d. MAKGQ为我输入的序列 convert_to_beta.py主要是用来转换骨架二面角到理想状态 12python convert_to_beta.py –i 1hk9.pdb –s 65 –c –o 1hk9.extend.pdb --publication-specific --publication-specific标志可以用来应用来自大肠杆菌Hfq结构（残基65-70）的二面角而不是理想的角度。-c和-n分别表示c端和n端。-s表示起始残基序列,-o为输出。 通过Rosetta进行“relaxed” 1$ROSETTA3/bin/relax.mpi.linuxgccrelease @option option设置如下12345678910-s 1hk9.extend.pdb -relax:constrain_relax_to_start_coords -relax:ramp_constraints false -ex1 -ex2 -use_input_sc -flip_HNQ -no_optH false -relax:min_type lbfgs_armijo_nonmonotone -nstruct 1 在这里简单介绍一下设置:-s为输入文件-relax:constrain_relax_to_start_coords和-relax:ramp_constraints false为特定输入结构所需要的，为设置主干原子约束，并且关闭约束ramp-ex1和-ex2使第一和第二侧链二面角的采样增加一个标准偏差 -use_input_sc包括放松过程中取样的旋转异构体中的晶体学侧链构象。 -flip_HNQ测试侧链组氨酸，天冬酰胺和谷氨酰胺中特定原子的替代配置（其不能在电子密度中区分）。 -no_optH false关闭氢原子优化 -relax:min_type最小化算法 -nstruct 1输出结构数量 正式的执行FloppyTail，其使用的为movemap.txt,设置如下:1234567891011121314151617181920212223242526# input-s 1hk9.relax.pdb# define flexible region via movemap file-movemap movemap.txt# shear moves are not productive initially so no shear# for the first 1/3 of the simulation-FloppyTail::shear_on 0.333# root the fold tree at the center of mass, so# we can “flop” both termini simultaneously-FloppyTail::COM_root# do not change AA identities during packing-packing::repack_only# monte carlo and sampling options-FloppyTail::perturb_temp 0.8-FloppyTail::perturb_cycles 100000 # ~500 moves per residue-FloppyTail::refine_temp 0.8-FloppyTail::refine_cycles 1000-FloppyTail::refine_repack_cycles 10# current best practices for minimization/scoring-run::min_type lbfgs_armijo_nonmonotone-score::weights talaris2014# recommended number of structures to model-nstruct 30000# output-out:path:pdb decoys/-out:pdb_gz 其movemap定义如下: 1234567891011121314151617181920 RESIDUE * CHI # repack only, default for allJUMP * NO # do not move subunits relative to one another# chain ARESIDUE 1 5 BBCHIRESIDUE 65 102 BBCHI# chain BRESIDUE 103 107 BBCHIRESIDUE 167 204 BBCHI# chain CRESIDUE 205 209 BBCHIRESIDUE 269 306 BBCHI# chain DRESIDUE 307 311 BBCHIRESIDUE 371 408 BBCHI# chain ERESIDUE 409 413 BBCHIRESIDUE 473 510 BBCHI# chain FRESIDUE 511 515 BBCHIRESIDUE 575 612 BBCHI 其中CHI表示侧链可以动，BB表示骨架可以动，下面的默认会覆盖上面的.注意测试不要按照上面的设置跑，720核需要跑48小时。 一篇PNAS的方法123456789./FloppyTail.mpi.linuxgccrelease-database /path/to/main/database-s 7AHL_SpyTAG_phi29_SpyCatch_assemble_repacked.pdb-nstruct 5000-in:file:movemap movemap_file-packing:repack_only-AnchoredDesign:refine_repack_cycles 30-AnchoredDesign:perturb_cycles 15000-AnchoredDesign:refine_cycles 3000 move_map文件参考: 12RESIDUE 2052 2060 BBCHIRESIDUE 2638 2650 BBCHI 参考资料: FloppyTail application fragment_picker.mpi.linuxgccrelease can’t find : libsqlite3.so Kleiger G, Saha A, Lewis S, Kuhlman B, Deshaies RJ. Rapid E2-E3 assembly and disassembly enable processive ubiquitylation of cullin-RING ubiquitin ligase substrates. Cell. 2009 Nov 25;139(5):957-68. PubMed PMID: 19945379.","categories":[{"name":"蛋白建模","slug":"蛋白建模","permalink":"http://kangsgo.com/categories/蛋白建模/"}],"tags":[{"name":"Rosetta","slug":"Rosetta","permalink":"http://kangsgo.com/tags/Rosetta/"}]},{"title":"PLUMED系列-安装教程","slug":"Plumed系列-安装教程","date":"2018-04-08T10:26:12.000Z","updated":"2018-04-08T05:14:59.061Z","comments":true,"path":"29.html","link":"","permalink":"http://kangsgo.com/29.html","excerpt":"","text":"转载请联系，且保留链接 PLUMED是许多分子动力学模拟包的插件，主要能进行MD的增强采样或者执行非常多的自由能计算方法。 可以使用诸如元动力学，伞形采样和基于 Jarzynski 方程的转向 MD 之类的现有技术来执行自由能计算作为许多次序参数的函数，特别关注生物学问题。模拟的高分文章很多运用了该工具。 下载地址如下:plumed-2.4.1 快速安装如果你迫不及待的想练手，可以通过如下方法简单野蛮式安装:1234./configure --prefix=/usr/localmake -j 4make docmake install 由于PLUMED需要分析额外的轨迹，同时运行Lennard-Jones 代码，所以需要对模拟的软件进行打补丁，简单的方法如下:12cd /md/root/dirplumed patch -p 当然还是建议按照下面的一步一步的来: 推荐安装安装BLAS与LAPACK安装PLUMED依赖的blas和lapack包。(虽然PLUMED自带这两个包，但是网站上说为了性能建议自己编译，未测试自己编译使用和使用自带的性能差异)123# 在用户主目录下src下操作mkdir ~/srccd ~/src 安装BLAS1234567wget http://www.netlib.org/blas/blas.tgztar zxf blas.tgz# 可能版本有差别cd BLAS-3.8.0/# 编译gfortran -O3 -std=legacy -m64 -fno-second-underscore -fPIC -c *.f 后续工作：12345 ar r libfblas.a *.oranlib libfblas.arm -rf *.o # 清理文件export BLAS=~/src/BLAS-3.8.0/libfblas.a # 导出BLAS环境变量 安装LAPACK1234wget http://www.netlib.org/lapack/lapack.tgztar zxf lapack.tgz# 可能版本有差别cd lapack-3.8.0/ 编译:1cp INSTALL/make.inc.gfortran make.inc 编辑make.inc文件，大致修改为如下:12345678910FORTRAN = gfortranOPTS = -O2 -frecursive -fPIC -m64DRVOPTS = $(OPTS)NOOPT = -O0 -frecursive -fPIC -m64# Define LOADER and LOADOPTS to refer to the loader and desired# load options for your machine.#LOADER = gfortranLOADOPTS = 编译:1make lapacklib 后续工作12make clean # 清理文件export LAPACK=~/src/lapack-3.8.0/ # 导出LAPACK环境变量 正式安装12tar xzf plumed-2.4.1.tgzcd plumed-2.4.1 完整的参数可以使用如下命令:1./configure --help 官方建议安装在默认预定义位置 1234./configure sudo make -j 4make checksudo make install 当然也可以修改路径: 1234./configure --prefix=$HOME/optmake -j 4 #核数make checkmake install 设置环境变量:安装后有设置环境变量提示，里面说直接运行如下tcl脚本即可，但我尝试了未成功12To create a tcl module that sets all the variables above, use this one as a starting point:@patch/plumed/modulefile 我使用的设置如下:12345678910# plumed# PLUMED2_HOME内容需要修改成自己的export PLUMED2_HOME=/to/pacth/plumedexport PATH=$PLUMED2_HOME/bin:$PATHexport LD_LIBRARY_PATH=$PLUMED2_HOME/lib:$LD_LIBRARY_PATHexport PKG_CONFIG_PATH=$PLUMED2_HOME/pkgconfig:$PKG_CONFIG_PATHexport PLUMED_VIMPATH=$PLUMED2_HOME/vim:$PLUMED_VIMPATHexport INCLUDE=$PLUMED2_HOME/include:$INCLUDE# 若开启了时间计算，需要增加export PLUMED_USE_LEPTON=yes 仅供参考 卸载在plumed的安装目录执行如下:1sudo make uninstall 更新MD包现在plumed默认支持如下包(还有一些可以靠插件解决，详情见官网): amber14 gromacs-2016-5 gromacs-2018-1 gromacs-4-5-7 gromacs-5-1-4 lammps-6Apr13 namd-2-8 namd-2-9 qespresso-5-0-2 qespresso-6-2 方法很简单，在MD安装的根目录，执行:1plumed patch -p !!!!之前安装的话需要重新安装!!!! 在这里简单介绍gromacs的重新安装,具体可以查看之前的文章1234cmake .. -DGMX_BUILD_OWN_FFTW=ON -DGMX_GPU=ON -DGMX_MPI=ON -DCMAKE_INSTALL_PREFIX=/home/yaolab/install/gromacsmake -j 4make checkmake install 最后设置环境变量 安装中可能遇到的问题 ./configure 时有可能出现如下警告:1WARNING: You might have problems linking FORTRAN programs. 但是这个警告是没有关系的，除非你想通过FORTRAN来进行plumed patch --static，那么可以使用参考资料7来进行解决.一般情况下是不需要修改的 简单的总结解决办法就是搜索:libstdc++.so或者libc++.so,在编译的时候设置:LDFLAGS=-L@path其中@path为路径 注意:若mpi为自己安装在自己的用户目录的话，那么sudo mpic++可能会提示找不到，那样的话需要sudoers中增加你的openmpi路径，例如我的:1/home/kangsgo/install/openmpi/bin/ 具体可以参考参考资料2-5 我在执行make check时结果如下: 我认为是正常的，因为部分模块默认是没有编译的,具体可以参考参考资料8 参考资料: 编译安装BLAS和LAPACK mpic++ command not found 如何解决sudo命令找不到环境变量的问题 sudo 环境变量继承和详解 sudo执行脚本找不到变量 gromacs + plumed 编译安装教程 Trouble compiling PLUMED 2.4.0 on Linux (Ubuntu 14.04.5) List of modules “plumed –has-matheval” with lepton","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"},{"name":"PLUMED","slug":"PLUMED","permalink":"http://kangsgo.com/tags/PLUMED/"}]},{"title":"自动化之Pexpect","slug":"自动化之Pexpect","date":"2018-03-21T05:09:30.000Z","updated":"2018-03-22T11:02:52.603Z","comments":true,"path":"28.html","link":"","permalink":"http://kangsgo.com/28.html","excerpt":"","text":"最近发现做了很多模拟，但是一些常规分析每次都需要进行查阅，套路化计算，我在想为何不能自动化每次模拟完自动执行一下呢？之前写了一个shell脚本的，现在看起来非常不高级，而且时间久了就会忘记，磨刀不误砍柴工，所以最近粗略的学习了Python自动化运维常用的两个模块，Pexpect和psutil，在这里简单介绍一下。 Pexpect简介Pexpect是一个终端自动交互python模块，十分易于上手 安装安装可以通过pip或者conda，适用版本为Python2.7或者Python3.3以上1pip install pexpect 简单使用说明其实使用方法在简书的Pexpect 模块使用说明总结的非常好，这里仅做快速简要介绍 spawn() - 执行程序12# 执行linux命令，返回的为结果pexpect.spawn(command, args=[], timeout=30, logfile=None, cwd=None) 参数里面我列了几个觉得很重要的内容，一个是timeout表示等待时间,logfile表示写入的日志文件,cwd表示根目录 expect() - 关键字匹配12# 正则匹配输出expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw) 匹配后会返回值，若匹配的是一个字符串，匹配到了会返回0,若为一个列表，则匹配到了的话，会定位到列表的第几个关键字，从0开始计算 1expect_loop(self, searcher, timeout=-1, searchwindowsize=-1) 用于从标准输入中获取内容，loop这个词代表它会进入一个循环，必须要从标准输入中获取到关键字才会往下继续执行。 send() -发送关键字其实相当于Shell中echo -e，我感觉 12345678910111213# 发送send()# 发送加空格sendlines()# 发送但没有返回值write()# 发送包含字符串的列表# 类似于 write() 命令，只不过接受的是一个字符串列表，# writelines() 会向子程序一条一条的发送列表中的元素，#但是不会自动在每个元素的最后加上回车换行符。writelines()# 发送特殊字符，例如Ctrl-Gsendcontrol('g') read() - 返回关键字感觉应用不多123456# 返回剩下的所有内容read() # 返回一行输出readline()# 返回列表模式的所有输出readlines() 控制子程序一些对于执行程序的操作12345678910# 杀死子程序kill()# 查看是否存活isalive()# 等待直到子程序退出wait()# 关闭子程序close()# 子程序进程pid 运行功能12# 运行linux命令，返回的为结果pexpect.run(command, args=[], timeout=30, logfile=None, cwd=None) 可能大家对run()和spwan()之间的区别很好奇，run()相比spwan()为等待命令完全完成，然后才会返回结果","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://kangsgo.com/tags/自动化/"}]},{"title":"Chimera补全蛋白缺失结构","slug":"Chimera补全蛋白缺失结构","date":"2018-03-16T05:09:30.000Z","updated":"2018-03-16T06:27:56.574Z","comments":true,"path":"26.html","link":"","permalink":"http://kangsgo.com/26.html","excerpt":"","text":"可能很多人喜欢用pymol，其实我认为Chimera是一个更加强大的可视化软件，只是不容易上手，可能不符合国人使用习惯用的人相对较少，这里简单介绍一下最近用到的Chimera补全蛋白缺失结构。 其实Chimera补全蛋白缺失结构主要是是利用的modeller，可以补全尾部结构或者中间的缺失结构，所以个人觉得对于之前介绍的GalaxyFill更加强大。 我们以PDB:1qln为例，1qln为T7 RNA 聚合酶，其中包括了一段核酸序列。我们可以先下载下来了解其信息:1wget https://files.rcsb.org/download/1QLN.pdb 可以看到MISSING RESIDUES信息，主要是前端和56-71的loop环的缺失。 图片1 我们将对其中loop进行补齐，若缺失的loop环是自己设计的残基，那么还需要自己修改SEQRES信息，如下图: 图片2 其中SEQRES为完整序列信息（包含缺失序列），可以自己创建或者修改添加从而达到自己的补全内容的目的。除非特殊要求一般PDB数据库中不需要修改或者自己添加。 我们打开UCSF Chimera，点击Favorites -&gt; Command Line,在下面Command中进行下载蛋白，删除核酸等操作:1234#打开PDB 1qlnopen 1qln#删除 核酸和溶剂等delete ~protein 图片3 再点击Tools -&gt; Structure Editing -&gt; Model/Refines Loops会弹出两个框框，其中这个框框主要是完整的序列信息，其中缺失蛋白位置会用红色框框圈出。 图片4 另外一个为设置modeller的框框: 图片5 具体的设置内容如下:Model/remodel 区域-active region: 序列框内的活性区域-Chimera selection region: Chimera中选择的区域-non-terminal missing structure: 非端点的缺失结构，会将坐标文件和SEQRES相互比较-all missing structure: 所有缺失片段Allow this many residues adjacent to missing regions to move (default 1) 允许移动的残基（来适配缺失残基），建议就是默认值Number of models to generate生成的模型数，个人觉得1个就好，后期再优化，默认为5个Loop modeling protocol-standard（默认）-DOPE: 精度更高，花的时间更多，有可能没有结果或者比预期结果少-DOPE-HR：和DOPE类似，精度相对没有那么高Run modeller using-web service（默认）:需要Modeller license key，学术用户可以输入MODELIRANJE-local installation：需要路径，我的是usr/local/mode9.19 点击OK会后台会运行，我运行了大约15分钟，运行完后模型会直接进入界面，然后保存即可。若停止或者查看可以在Task Panel查看，即右下角 图标","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Chimera","slug":"Chimera","permalink":"http://kangsgo.com/tags/Chimera/"}]},{"title":"马尔科夫状态模型模拟笔记","slug":"马尔科夫状态模型模拟笔记","date":"2018-03-16T05:09:30.000Z","updated":"2018-03-26T01:37:40.902Z","comments":true,"path":"27.html","link":"","permalink":"http://kangsgo.com/27.html","excerpt":"","text":"只是粗略翻译，未校正 此篇文章以RNA MD为舟，主要参考《RNA Structural Dynamics As Captured by Molecular Simulations: A Comprehensive Overview》一文3.2.3: Markov State Models一节。 近年来，马尔科夫状态模型（Markov State Model，MSM）方法在增强采样中得到了广泛的运用，成为热门的增强采样方法之一。马尔科夫模型的方法优势在于它能够从很多短的模拟中获取长时间的动力学特征，可以不需要事先定义反应坐标，从而避免了对整个动力学性质的简化或者是偏差。特别是最近几年大规模的平行计算资源的发展，更加促进了这一方法的应用。 图片1 Fig 1. 马尔科夫状态模型, 广泛模拟分析,观察的状态被成簇聚类. 然后构建动力学矩阵，提供观察集群对之间转换的概率 在最近数十年，MSMs成为探索解释缓慢的生物分子复合物的运动并且其背后的理论日渐完善。MSM的工作流程简述如下: 1) MD数据聚集成一组有限的微观状态。每个微观状态均由许多结构组成，这些结构足够相似以至于在动力学项目中无法被区分。一个滞后时间,τ,被选为程序的时间离散化，并且在微观状态之间跃迁以对应滞后时间τ之间的步幅联系。 2) 来自MD的信息（在滞后时间窗中观察的转变）被用来构建一个跃迁几率矩阵,T，其元素,Tij,表示了系统的几率始于微状态j，在时间τ之后将会跃迁到微状态i（请注意，T矩阵通常以其转置形式使用，然后将索引i和j的含义互换。） 3) 系统在前面提到的微状态之间构建马尔科夫状态链，通过跃迁几率矩阵进行控制，因此时间t+τ时微观状态的概率分布仅取决于时间t时微观状态的分布，而不取决于系统的历史。换句话说，动力学模型之间是互不相关的进程，每个时间步骤τ，分子将会从一个微观状态“跳跃”到另外一个微观状态。 4) 分析矩阵T的特征值谱以提取关于系统的热力学，动力学和动力学的信息。 离散的MSM结果旨在近似通过离散的程序估算模拟系统连续的动态。使用MSM，在一个离散的时间步长τ中可以进化单独的随机轨迹（微观状态的时间轨迹，例如:一个时间离散化的对应MD轨迹）或者微观状态的概率分布。MSM可以近似的极端被精确；换句话说，其可以提供和MD模拟相同的时间发展快照。比较其他的增强采样方法，其可以获得更加长时间尺度的结果（和热交换或者CV-基础的方法作为比较，后面会有时间进行记录）。MSM可以提供的信息有系统的动态参数和感兴趣的参数之间的跃迁比率，然而当系统的动态具有倾向性时，关于这些属性的信息通常会丢失。MSM的跃迁矩阵的特征值(eigenvalues)与特征向量(eigenvectors)的解释如下:第一个跃迁矩阵的特征向量是单位特征值并对应平稳分布向量，即该微状态的平衡概率;其它特征向量描述的为平衡的松弛过程，以及其对应的特征值, λ i,相关的时间尺度,ti,通过公式ti=-τ/ln(λi)进行降序排列。 MSM可以被广泛的用来帮助从一个长的MD轨迹中提取可阅读的信息,它反复和自发地对正在研究的罕见事件进行采样。如果模拟采样程序足够好，MSM可以被用来进行粗粒化模型的“创作”，为原始模拟数据提供非常需要的见解。或者，MSMs可以通过将所有轨迹跨越的集合进行离散化用来合并分隔的MD轨迹，并且计算在任何轨迹中的跃迁。这能够成为一个严格的结合信息，来自一个单质量模型的多个轨迹。 主要有两个手段来构建可信的MSM: i).将相空间的极其精细的离散化转化为微观状态 ii) 或者，以所谓的“中心(coring)”方法来计数对应于亚稳态的较大盆地之间的跃迁。 现在的研究一般使用第一种方法来解决。 构建MSM的第一步是将相空间离散化为微观状态。其可以通过使用不同的成簇方法和不同的标准进行完成。这一领域的一个重要进展是发展时滞独立成分分析( time-lagged independent component analysis,TICA).在这个方法中，输入变量的线性组合被构造以便找到具有最大自相关时间的自由度，并且因此预期在动力学分析中更重要。这使得后续的聚类可以在较低维度上完成，在主要TICA成分的空间中完成，通过模拟轨迹投影到最大的TICA成分上。TICA的方法和主成分分析(principal component analysis, PCA)方法较为相似(PCA方法也是MD轨迹分析的一个常用方法).PCA识别输入自由度与最高方差的线性组合，而TICA发现具有最高自相关时间的那些，即对应于模拟中发生的最慢过程。TICA可以从基于所有溶质原子的笛卡尔坐标的描述开始执行，或者使用在一些内部坐标上定义的描述，例如相关原子之间的二面角或配对距离.和其它降维方法相比，一个总需要当心的为一些重要的信息可能会被丢失，曲解快速时间尺度程序的描述。因为显著的结果被获取，TICA被推荐作为一个常规工具对于MD轨迹的坐标跃迁和降维. 将相空间离散化为有限个微态是MSM系统误差的主要来源.误差可以通过两个方式进行降低:增加滞时,τ，另一种方法为通过更加精细的离散化算法.在实践中，当处理非常精细长度的模拟，许多因素影响计算的质量。滞后时间本质上取决于系统的马尔可夫性和期望的时间分辨率.太短的滞时将会导致模型没有马尔可夫性。一般说来，与滞后时间相比，每个个体微观结构内的结构之间的相互转换必须是快速的.在蛋白和核酸体系中典型的τ值范围一般为0.1到10ns,通常通过观察隐含时间尺度的收敛来选择。具体描述如下:微观状态的数量应该足够大，以避免由于相位空间的粗糙化造成的分辨率损失，并且足够小对于有足够的数量以便于他们之间的跃迁（例如:拥有足够的统计学精度）并且矩阵大小是可控的。“中心”方法的运用是有差别的，其使用更加小的设置微态，其不需要覆盖系统完整的构象空间。 用现代方法模拟中等大小的生物分子，一个典型的使用MSMs方法至少需要102到104个微态。这种微观状态的数量使模型的可视化和直观分析变得不切实际。存在几种方法来克服这个问题，即利用MSM提供的动力学信息来构建系统的更粗略的表示，将MSM微观状态集合成少数亚稳态宏观状态.一个普遍使用的方法为Perron集群聚类分析(Perron-cluster cluster analysis,PCCA,更多信息可以通过这里还有这里进行了解)一种利用转换矩阵的特征向量的符号结构来定义MSM微观状态的最佳亚稳分区的方法.称为PCCA +和PCCA ++的更高级版本的方法为每个微观状态指定了成为给定亚稳态宏观成员的概率。 另一种减少模型的方法成为隐式马尔科夫模型(hidden Markov model, HMM).在这种方法中，系统被表示为隐藏的亚稳态宏观事件之间的马尔可夫链.这些宏观不是直接可观察的，而是通过观察微观态来测量的，微观态在每一步都是从一个分布概率中提取的，这个分布概率依赖于隐藏的宏观态来进行的.因此，假定可以使用附加（隐藏）变量来标记状态，并且其时间序列由观测变量的时间序列推断。HMM定义的态没有整齐的边界，并且一个给定的构象有可能同时参与多个宏观事件. MSM方法一个关键的优势是能够监测，其不必假设全局平衡，而是假设MD在每个微观状态为局部平衡。实际上，对于模拟通过选择小的起始点，可以获得组装的相关短的轨迹，每个采样跃迁和不同的复合物步骤和缓慢设置改变相关。通过在MSM模型中结合这些轨迹，原则上，甚至可以重构甚至比任何单个轨迹的跨度更长的时间尺度上发生的过程。最大隐含时间尺度可以为用于构建MSM的所有MD轨迹的总持续时间的相同数量级.显然，初始点的选择必须十分慎重，必须确保没有重要的相变区域被忽略。 用于构建MSM的MD模拟有许多方法选择起始点.如果有，关于系统的先验知识可以用来初始化沿着有趣的构象变化的不同位置的模拟(例如，实验结构拥有多个构象可用)，另一个方法是，新的模拟可以用来初始化成为一个“探索”模拟来获得新的感兴趣的构象。如果这个步骤在每次新的模拟中被递归地重复，它将产生MD级联的轨迹，对可用相空间的越来越大的区域进行采样.通过改变确定新轨迹的候选起始点的标准，可以沿着感兴趣的构象变化的路径驱动系统。这种方法通常被称为“自适应采样”，实际上它可以被视为增强采样技术的一个子类.另外一个强大的方法是初始结构从其它增强采样的方法中获得。 与所有旨在降低MD模拟计算成本的方法一样，MSM可能会以与其基本近似值和假设不一致的方式提供错误结果。因此，在从MSM得出任何结论之前，测试马尔可夫近似的有效性至关重要.这通常是通过观察隐含时间尺度ti的收敛来实现的，伴随着τ的值增大。隐含的时间尺度应该与马尔可夫系统中的τ无关，所以它们的收敛可以用来选择恰当的滞后时间（如果存在的话），这对应于真实动态的良好近似。指出以对数形式显示时间尺度的常见做法可能会由于对数函数的负凸性而给出收敛的错误印象。 重要的是要注意隐含时间尺度的收敛是马尔可夫性的一个必要但不充分的条件.当达到收敛时，最慢的隐含时间尺度应该对应于所研究系统中最慢的跃迁模式。它与以前的系统知识的比较可以提供一些关于全自由能景观是否被充分采样的提示。一个过短的隐含时间可能表示部分重要的自由能景观，在模拟数据集中完整的被缺失，MSM仅表征折叠景观的局部区域。当模拟太短或未初始化以充分覆盖相空间的相关部分时，可能会发生这种情况.例如研究折叠景观图，一系列的模拟初始点可能从一些解折叠中获得，获得的构象可能是强制解折叠或者高温模拟.对于通过漏斗机制快速折叠的分子，这可能效果很好。 然而，当折叠景观崎岖不平时，本质上遵从动态划分，景观的主要部分可能无法通过从“seeding”解折叠轨迹开始的模拟。 值得注意的是，研究必须始终对所研究的过程进行合理的整体评估，而不是仅仅依靠计算过程提供的数字。因为很多采样的中间过程都无法考虑周详.这限制了其的应用。MSM预测中另一个重要的不确定性来源是有限采样造成的统计误差。这个可以被验证通过马尔科夫链蒙特卡洛模拟(MCMC)的采样跃迁矩阵.将统计误差考虑在内是至关重要的，因为采样不良很容易导致与时间尺度本身相同数量级的相关隐含时间尺度上的不确定性. 例子:r(A)3 的MSM分析 图片2 Fig 2. 腺嘌呤三核苷酸四个状态的隐式马尔科夫链模拟流程图，核苷酸根据序列位置进行着色(红,1;蓝,2;黄,3).百分比表示每个状态的平衡数;箭头粗细与跃迁态成比例，单位为μs-1. MSM方法在近几年发展十分快速，过去许多受到欢迎的程序已经被更加好的方法所代替。这种方法成功的应用到许多蛋白体系的研究之中，现如今也进入到了RNA的世界。我们预计新的应用程序和工具将很快出现，并且将更严格地讨论方法适用性的限制。阴影表示投影在由两个主要TICA组件定义的平面上的模拟数据的分布。具体可以参考推荐阅读3. 推荐阅读: Everything you wanted to know about Markov State Models but were afraid to ask Mechanism of the All-α to All-β Conformational Transition of RfaH-CTD: Molecular Dynamics Simulation and Markov State Model Predicting the Kinetics of RNA Oligonucleotides Using Markov State Models","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"增强采样MD","slug":"增强采样MD","permalink":"http://kangsgo.com/tags/增强采样MD/"}]},{"title":"利用GalaxyFill补全蛋白","slug":"利用GalaxyFill补全蛋白","date":"2018-03-15T05:09:30.000Z","updated":"2018-03-15T13:26:20.791Z","comments":true,"path":"25.html","link":"","permalink":"http://kangsgo.com/25.html","excerpt":"","text":"GalaxyFill是一个项目用来进行对蛋白的缺失结构进行补全。其功能我觉得非常强大，比如用来进行蛋白的延长，甚至进行融合蛋白的制作。使用Galaxy需要为Linux 64-bit位系统请注意无法补全中间的缺失结构 安装 下载GalaxyFill项目: 1wget https://github.com/seoklab/GalaxyFill/archive/master.zip 解压 123unzip master.zip#修改名字mv GalaxyFill_master/ GalaxyFill 设置环境变量 12345gedit ~/.bashrc##增加如下行，需要根据自己进行修改## GalaxyFill## export GALAXY_HOME=/home/kangsgo/install/GalaxyFillsource ~/.bashrc 使用使用方法如下:使用：1$GALAXY_HOME/bin/GalaxyFill [-h] [-p INPUT PDB File] [-s INPUT FASTA File] 输入参数和设置:1234-p or --pdb : Input protein structure file in PDB format (mendatory)-s or --seq : Input protein sequence file in FASTA format (mendatory)-o or --out : Output protein structure file name (optional, default=$&#123;Input PDB prefix&#125;_fill.pdb)-t or --title : Running title for GalaxyFill (optional, default=$&#123;Input PDB prefix&#125;)","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Galaxy","slug":"Galaxy","permalink":"http://kangsgo.com/tags/Galaxy/"}]},{"title":"linux SSH简介","slug":"linux ssh简介","date":"2018-03-15T04:08:36.000Z","updated":"2018-03-15T12:24:54.430Z","comments":true,"path":"24.html","link":"","permalink":"http://kangsgo.com/24.html","excerpt":"","text":"相信小伙伴们人手可能有几个VPS，有一些国外的资源下载速度比较慢，一个方法就是拖到百度网盘然后再下载，另外一个比较好的办法就是拖到自己的vps中再下载，对于国外主机来说有时候下载内容的速度基本上是秒下，拖到国内的速度也比百度网盘非会员便宜。这里就简单介绍也是给自己做一个笔记如何进行到本地。 什么是SSH？简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。 需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。 基本用法登陆登陆上远程主机，常用的格式如下1ssh [-l login_name] [-p port] [user@]hostname 详细信息可以使用ssh -h进行查看 不指定用户，默认使用root账户登录1 ssh 192.168.0.11 指定用户：123 ssh -l root 192.168.0.11 ssh root@192.168.0.11 如果修改过ssh登录端口的可以：12345 ssh -p 12333 192.168.0.11 ssh -l root -p 12333 192.168.0.11 ssh -p 12333 root@192.168.0.11 上传文件基本语句如下:1scp file username@hostIP fileaddress 例如:1scp test.sql zhangying@192.168.1.5:/var/www/zhangying 下载文件基本语句如下:1scp username@hostIP: fileaddress filedirectory 例如:1scp zhangying@192.168.1.5:/var/www/zhangying/test.sql /home/zhangy/database_bak/ 参考资料: linux下面用ssh上传，下载文件 linux ssh登录命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"Pymol核酸绘图","slug":"Pymol核酸绘图","date":"2018-03-13T05:09:30.000Z","updated":"2018-03-13T06:39:52.920Z","comments":true,"path":"23.html","link":"","permalink":"http://kangsgo.com/23.html","excerpt":"","text":"大家都知道chimera的核酸绘图功能非常强大，一般大家理解的pymol核酸绘图功能就显得薄弱了，但是今天在看pymol的cartoon的时候无意间看到了其核酸绘图，发现实际上其功能还是不错的。 默认设置默认的一般有一个磷酸骨架和一个跨过核苷酸平面的枝棒，默认设置如下:1234set cartoon_nucleic_acid_mode, 0 # 骨架随后的磷酸盐，实际上pymol默认设置为4set cartoon_ladder_mode, 1 # 从骨架到核苷酸的枝条set cartoon_ring_mode, 0 # 没有核酸环set cartoon_ring_finder, 1 # 核糖和基本环 (因为ring mode 0，所以这里设置什么都不会展示) 我们以PDB265d为例123fetch 265dremove resname HOHremove resname MG 图片1 Cartoon 环模式（ring mode）设置set cartoon_ring_mode, value 值影响 0 枝条从骨架原子到嘌呤的N1或嘧啶的N31 简单的核糖平面和覆盖环键之间区域的基环2 简单的核糖平面和覆盖环键内侧之间区域的基环（和模式1相比略小）3 用棍棒包围核糖和基环的平面4 在核糖中心和每个基环上的大直径环球体5 大约为4的1/10的球体 例子模式1： 图片2 模式3： 图片3 模式4： 图片4 Cartoon ring finder设置set cartoon_ring_finder, value 值影响 0 没有环或枝条加入1 核糖和基础环2 只有基础环3 和模式1类似，轻微的透视4 和模式1类似，核糖核苷酸和碱基，以及蛋白质的芳香侧链显示5 只有枝条，无环 例子模式0： 图片5 模式1： 图片6 模式2： 图片7 Cartoon梯子模式设置set cartoon_ladder_mode, value 值影响0 没有枝条展示1 枝条展示 例子模式0： 图片8 模式1： 图片6 Cartoon核酸模式设置set cartoon_nucleic_acid_mode, value 值影响0 光滑的骨架通过磷原子，骨架的两端均终止于磷末端1 光滑的骨架通过核糖C3’原子，骨架的两端最后C3’终止2 光滑的骨架通过磷原子，主链在5’末端终止于磷，在3’末端终止于O3’3 和0模式相似？4 和模式2相似？ 例子模式0： 图片6 模式1： 图片6 模式2： 图片6","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"Pymol渲染（Ray）笔记","slug":"Pymol渲染笔记","date":"2018-02-26T05:09:30.000Z","updated":"2018-02-26T05:33:41.164Z","comments":true,"path":"22.html","link":"","permalink":"http://kangsgo.com/22.html","excerpt":"","text":"Rayray将会创建一个现在的框架图像的渲染（ray-traced）图像。我们平常使用pymol的时候可能就是直接ray一下出图，其实ray有许多功能可以挖掘，这里简单介绍一小部分。 使用1ray [width,height [,renderer [,angle [,shift ]]] angle和shift将会生成立体的配对width和height为设置ray的长宽，可以超出现在的框架 例子默认图像 图片1 简单渲染12#全部使用默认设置ray 图片2 PyMol API1cmd.ray(int width,int height,int renderer=-1,float shift=0) 设置渲染模式设置Ray_trace_mode设置可以修改最终成图的时候的PyMOL的内部渲染蛋白的模式.下面可以查看不同模式的效果 1234567891011121314151617# 普通颜色set ray_trace_mode, 0# 普通颜色+黑色线set ray_trace_mode, 1# 仅包含黑色线set ray_trace_mode, 2# 倍色+黑色线set ray_trace_mode, 3# 建议设置set antialias, 2# 更改线的颜色set ray_trace_color, magenta 效果如下 ray_trace_mode, 1 图片3 ray_trace_mode, 2 图片4 ray_trace_mode, 3 图片5 ray_trace_color, magenta 图片6 透视在0.98版本以后，渲染速度得到了提升，选择的开关如下:123set orthoscopic, offset orthoscopic, on 放大近景如下:1set field_of_view, X 当50&lt;X&lt;70，默认为20.50-70 拥有非常强的透视效果。透视的轴为Y轴，而不是X轴 orthoscopic, off 图片7 orthoscopic, on 图片8 set field_of_view, 70 图片9 不知道为何我做出来没有效果，可以看官方的图例 图片10 渲染renderer = -1 为默认渲染renderer = 0 为PyMOL内部渲染器renderer = 1 使用PovRay渲染器， Unix-only 例子如下12# ray trace with an external renderer.ray renderer=0 比较了一下-1和0模式的效果差别不大。","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"利用OpenBabel生成多个构像","slug":"利用OpenBabel生成多个构像","date":"2018-01-19T08:10:20.000Z","updated":"2018-01-20T12:38:10.201Z","comments":true,"path":"21.html","link":"","permalink":"http://kangsgo.com/21.html","excerpt":"","text":"此文感谢建民兄的指导，才让我学习到这么有用的工具 起因有许多软件例如Dock 6.8，对于小分子的柔性对接支持并不那么好，这就导致了因为初始构像的不正确而导致了对接结果的不正确和不可靠，为了解决这个问题一个方法就是进行构像的生成，再进行多对接，整理得分排序。当然还有一个应用就是用于3D药效团的使用。网上有许多在线网站可以进行这方面的工作，但是最好用的我感觉还是openbabel神器！ 利用openbabel生成多构像Open Babel提供了两种构像生成的算法代码: Confab: 一个成体系的构像生成器，有序的生成所有的低能量构像 遗传算法: 是一个随机构像产生器，能够根据RMSD或者能量的不同达到优化的目的 1. 遗传算法了解算法的命令信息可以使用:obabel -L conformer查看。虽然查看是说的构像搜寻，但是可以使用--writeconformers对生成的构像进行保存。可以查看如下的生成30个构像的例子:1obabel startingConformer.mol -O ga_conformers.sdf --conformer --nconf 30 --score rmsd --writeconformers 其中--score rmsd可以不写，因为默认就是使用这种方式 当然生成的构像在1个文件里，我们有时候需要split，当然首先想到的还是obabel,其进行拆分相当于高射炮打蚊子–相当好用呀（&lt;-原谅我在这里乱用歇后语），示例如下:1obabel ga_conformers.sdf -O new.mol -m 我自己的输出结果如下:1232 molecules converted32 files output. The first is molecule/new1.mol2 2. ConfabConfab 生成分子的低能量构像分子集合。设置命令为--confab,同样可以使用obabel -L confab进行查看了解。使用简单的设置操作如下:1obabel &lt;inputfile&gt; -O &lt;outputfile&gt; --confab [confab options] 其还有一个额外的应用就是confabreport format，如下:1obabel &lt;inputfile&gt; [-O &lt;outputfile&gt;] -o confabreport -xf &lt;reference_file&gt; [-xr &lt;rmsd&gt;] 主要是为了和初始构像进行比较。 下面是其中一个例子，首先生成100K个构像:1234567891011121314151617181920212223&gt; obabel bostrom.sdf -O confs.sdf --confab --conf 100000**Starting Confab 1.1.0**To support, cite Journal of Cheminformatics, 2011, 3, 8...Input format = sdf..Output format = sdf..RMSD cutoff = 0.5..Energy cutoff = 50..Conformer cutoff = 1000000..Write input conformation? False..Verbose? False**Molecule 1..title = 1a28_STR_1_A_1__C__..number of rotatable bonds = 1..tot conformations = 12..tot confs tested = 12..below energy threshold = 10..generated 3 conformers... etc, etc0 molecules converted 统计多少个构像和初始构像相比RMSD小于1.0A1234567891011121314151617181920&gt; obabel confs.sdf -oconfabreport -xf bostrom.sdf -xr 1.0**Generating Confab Report..Reference file = bostrom.sdf..Conformer file = confs.sdf..Molecule 1..title = 1a28_STR_1_A_1__C__..number of confs = 3..minimum rmsd = 0.0644801..confs less than cutoffs: 0.2 0.5 1 1.5 2 3 4 100..1 1 3 3 3 3 3 3..cutoff (1) passed = Yes... etc, etc**Summary..number of molecules = 36..less than cutoff(1) = 3552271 molecules converted 我做的一个的简单应用（批量读取文件对接），不提供部分代码：1234567891011121314151617181920212223#-*-coding:utf-8-*-from ucsfdock.docksh import PreDockfrom ucsfdock.dockfile import Dockimport os#计时器工具import timetime_start=time.time()DOCKHOME='/home/kangsgo/install/dock6/bin/'#run=PreDock(DOCKHOME=DOCKHOME)#run.onerun()dock=Dock(DOCKHOME=DOCKHOME)#遍历molecule目录下所有的文件for (dirpath,dirnames,filenames) in os.walk('molecule'): for i in filenames: print('开始执行'+i+'文件') dock.dock(mode=2,ligand_atom_file='molecule/'+i,ligand_outfile_prefix='out1/'+i[:-5])#dock.dock(mode=2,ligand_atom_file='2.mol2')print(\"done!\")time_end=time.time()print(\"耗时为\"+str(time_end-time_start)+\" 秒\") 参考资料: Generate multiple conformers obabel and babel","categories":[{"name":"预处理","slug":"预处理","permalink":"http://kangsgo.com/categories/预处理/"}],"tags":[{"name":"OpenBabel","slug":"OpenBabel","permalink":"http://kangsgo.com/tags/OpenBabel/"}]},{"title":"shell脚本文件夹内文件依次执行","slug":"shell脚本文件夹内文件依次执行","date":"2018-01-18T04:05:29.000Z","updated":"2018-01-18T05:00:23.656Z","comments":true,"path":"20.html","link":"","permalink":"http://kangsgo.com/20.html","excerpt":"","text":"这个脚本非常简单，个人觉得也很实用，对于初学linux或者bash的小伙伴们，我觉得在很多地方可以解放我们的小手。写的这个脚本是因为师弟师妹们有很多高斯文件需要计算，高斯的计算文件一般以gjf或者com结尾。所以要师弟师妹们把文件放到一个文件夹下，然后批量执行。为了以后的方便我还写了通过识别后缀是否执行。脚本全文如下:12345678910#!/bin/bashfor i in `ls` ;do echo \"文件的后缀为\"$&#123;i##*.&#125; if [ $&#123;i##*.&#125; = \"gjf\" ]||[ $&#123;i##*.&#125; = \"com\" ];then echo $i\"后缀正确，开始计算\" g09 $i fidone echo \"计算完成\" 首先通过一个for循环结合ls查看文件命令依次读取文件，然后用一个if命令判定后缀是否后缀正确，##*.表示删除最后一个点以及左边的字符。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/tags/Linux/"}]},{"title":"linux GTX1080TI安装显卡驱动小记","slug":"linux GTX1080TI安装显卡驱动小记","date":"2018-01-11T09:50:28.000Z","updated":"2018-01-11T02:30:53.092Z","comments":true,"path":"19.html","link":"","permalink":"http://kangsgo.com/19.html","excerpt":"","text":"我这辈子没有见过什么世面，之前用的最好的显卡就是GTX750Ti了，有幸来到一个还算有钱的课题组，导师给配了一台装有E5-2696 v3 CPU，GTX1080TI显卡的电脑，不甚欢喜，爱不释手。没想到是填坑的开始，前前后后捣鼓了一个星期，把其中的坑慢慢总结，今天先记录一下我安装记录: 由于GTX1080TI在linux下没有开源驱动，所以安装ubuntu后啥也没有，需要安装闭源驱动。点此进入下载地址。由于我的CPU没有集成显卡，无奈只能在旧机器上弄了一个GT630装上，其实也可以把硬盘取下来，安装好后再重新装上。 安装好后进行驱动的安装，简要如下: a) 禁用nouveau终端中运行：lsmod | grep nouveau，如果有输出则代表nouveau正在加载。 Ubuntu的nouveau禁用方法：在/etc/modprobe.d中创建文件blacklist-nouveau.conf，在文件中输入一下内容 12blacklist nouveauoptions nouveau modeset=0 打开终端，运行1sudo update-initramfs –u 设置完毕可以再次运行 lsmod | grep nouveau检查是否禁用成功，如果运行后没有任何输出，则代表禁用成功。 b) 重启电脑，到达登录界面时，alt+ctrl+f1，进入text mode，登录账户 c) 输入sudo service lightdm stop关闭图形化界面 d) 切换到cuda安装文件的路径，运行sudo sh cuda_9.1.18_linux.run (可能不同) 按照提示一步步操作 安装成功后，会显示installed，否则会显示failed。 e) 输入 $ sudo service lightdm start 重新启动图形化界面。 Alt + ctrl +F7，返回到图形化登录界面，输入密码登录。如果能够成功登录，则表示不会遇到循环登录的问题，基本说明CUDA的安装成功了。 f) 重启电脑。检查Device Node Verification。 检查路径/dev下 有无存在名为nvidia*（以nvidia开头）的多个文件(device files)如果没有的话，可以参考官方文档里的指导步骤，进行添加。 若安装了CUDA，则需要设置环境变量，具体可以查看这一篇文章。 参考:Ubuntu 14.04 上安装 CUDA 7.5/8.0 超详细教程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[{"name":"安装","slug":"安装","permalink":"http://kangsgo.com/tags/安装/"}]},{"title":"g_mmpbsa之参数注释","slug":"g_mmpbsa参数注释","date":"2018-01-10T14:23:09.000Z","updated":"2018-01-10T12:35:44.253Z","comments":true,"path":"17.html","link":"","permalink":"http://kangsgo.com/17.html","excerpt":"","text":"MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。g_mmpbsa是一个针对GROMACS程序使用的MM/PBSA方法，最近在群里讨论非常多，最近一个膜蛋白体系使用该方法做出的结果发现一些问题，最近在找问题，所以先把g_mmpbsa的参数进行了研读，在这里分享给大家。 极性溶剂化能(Polar Solvation Energy)输入关键字polar1polar = yes 是否计算极性溶剂化能，如果不需要进行极性计算，值可以变为no cfac1cfac = 2 扩大分子尺寸来获得粗糙的格点尺寸的因子.如果是非常简单的边界条件或者非常高的带电分子，那么值需要增加。APBS程序中默认值为1.7 fadd1fadd = 20 增加分子尺寸的数值(埃级别)来获得精确的格点尺寸。在高电荷分子中该值需要被增加来阻止等界限被截断 gridspace1gridspace = 0.2 微调格点空间的特异值(埃界别).若为精细计算，那么需要0.5A或者更低的值，若需要初略计算，则可以增加数值 gmemceil1gmemceil = 4000 设置的最大内存值(MB) PBsolver1PBsolver = npbe 选择线性还是非线性波尔兹曼公式来解决问题。关键字lpbe和npbe分别表示线性和传统的非线性PB公式。在极性计算中不同的值的影响已被调查过。对于高电荷体系，使用非线性PB公式是必须的。 mg-type1mg-type = mg-auto 接受mg-auto和mg-para两个关键字mg-auto将会自动设置顺序进行多格点PB计算mg-para将会自动设置线程进行多格点PB计算（此需要自己编译APBS版本和mpirun） pcharge1pcharge = 1 溶液中正电荷离子电荷 prad1prad = 0.95 正电荷离子半径 pconc1pconc = 0.150 正电荷离子浓度 ncharge1ncharge = -1 溶液中负电荷离子电荷 nrad1nrad = 1.81 负电荷离子半径 nconc1nconc = 0.150 负电荷离子浓度 pdie1pdie = 4 溶解电解质常数值。此值需要依据计算的溶质对象进行改变。对于高电荷溶质高的电介质值将会产生更加准确的极性溶解能。 sdie1sdie = 80 溶剂介电常数 vdie1vdie = 1 真空下介电常数 srad1srad = 1.4 溶剂分子半径，水类似物状的分子表面一般设置为1.4埃 swin1swin = 0.30 这为基于样条曲线的曲面定义指定了三次样条曲线窗口的值。 在计算中使用基于探针的表面时不使用.所以一般不需要修改 srfm1srfm = smol 这指定了用来构造介电和离子可及性系数的模型.关键字接受mol,smol,spl2和spl4，其会影响极性能计算。该关键字指定用于构建溶剂相关表面和体积的模型 sdens1sdens = 10 指定构建分子表面或溶剂可及表面的每个Å2的网格点数。 当srad = 0.0或srfm = spl2时不考虑 temp1temp = 300 温度 chgm1chgm = spl4 这指定了用于将生物分子点电荷映射到网格的方法，用于多重格点波尔兹曼计算。 接受的关键字是spl0，spl2和spl4spl0 传统的三线插值法(线性样条函数 Traditional trilinear interpolation )，产生的电位对网格间距，长度和位置非常敏感。spl2立体B-线性样条离散化(Cubic B-spline discretization)，相对spl0敏感度低spl4五次B-线性样条离散化(Quintic B-spline discretization)该值的变化没有被测试过 bcfl1bcfl = mdh 特定的边界条件类型来解决波尔兹曼公式。关键字接受zero,sdh,mdh,focus和map。其中focus和map或导致g_mmpbsa终止。zero不是很常用。sdh当在边界条件很远的时候效果较好。mdh速度较慢 非极性溶剂化能(Polar Solvation Energy)输入关键字apolar1apolar = yes 是否进行非极性溶剂化能计算 SASA模型gamma1gamma = 0.02267 未完待续","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"g_mmpbsa之简单教程","slug":"g_mmpbsa简单教程","date":"2018-01-10T14:20:09.000Z","updated":"2018-01-10T12:35:22.626Z","comments":true,"path":"18.html","link":"","permalink":"http://kangsgo.com/18.html","excerpt":"","text":"MM/PBSA方法是一个非常有用的针对大分子特别是蛋白配体测亲和力很有用的方法。相对于自由能微扰(FEP)和热力学积分(TI),虽然准确度相对较低，但其计算量相对较小，比较适用于生物大分子体系。是一种对MD轨迹进行后处理以估计结合自由能的方法, 计算时会将溶剂视为均匀的连续介质, 并基于力场和隐式的连续介质模型, 对平衡轨迹中的许多帧进行平均, 以考虑温度的影响。其实该教程网上很多地方有，我之前也做过很多次，在这里仅做简单介绍，其实只是想引出后面的文章做一个系列。 安装教程首先从这里下载对应版本,GROMACS2016和GROMACS2018版本都可以下载GROMACS-5.1.版本。建议下载包括APBS版本，但改版本APBS无法进行多线程。记得把脚本也都下载下来。 预编译版本1234tar -zxvf g_mmpbsa.tar.gzcd binsudo cp g_mmpbsa /usr/local/bin/.sudo cp energy2bfac /usr/local/bin/. 或导入$HOME中1234tar -zxvf g_mmpbsa.tar.gzcd bincp g_mmpbsa $HOME/bin/.cp energy2bfac $HOME/bin/. 或设置环境变量1export PATH=$&#123;PATH&#125;:/path/to/g_mmpbsa/bin 编译版本略 下载教程包你可以从此下载教程包，并进行解压: 123tar -zxvf tutorial.tar.gzcd tutorialcd 1EBZ 其目录下包括HIV-1蛋白酶及其抑制剂的拓扑参数(tpr),索引文件(ndx)和轨迹(xtc)文件 GMXLIB环境变量如果GROMACS为自定义安装，设置GMXLIB环境变量：1export GMXLIB=/opt/gromacs/share/gromacs/top 计算三个能量组件结合能计算包括三个能量项目（a）真空中的势能，（b）极性溶剂化能和（c）非极性溶剂化能。这些能量可以一步计算或三步计算 三步计算（a）真空中的势能1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -pdie 2 -decomp 选择时第一次选择蛋白，第二次选择配体，计算将会得到energy_MM.xvg和contrib_MM.dat。energy_MM.xvg文件包含范德华力，静电相互作用以及蛋白质和抑制剂之间的非结合势能。 contrib_MM.dat包含每个残基对计算得到的非结合势能的贡献。 （b）计算极性溶剂化能1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../polar.mdp -nomme -pbsa -decomp 选择时第一次选择蛋白，第二次选择配体，计算将会得到polar.xvg和contrib_pol.dat。polar.xvg含有未结合蛋白，未结合抑制剂和蛋白抑制剂复合物的极性溶剂化能。contrib_pol.dat包含每个残基对计算的净极性溶剂化能的贡献。 （c）计算非极性溶剂化能非极性溶剂化能包含三种，分别为SASA，SAV和WCA-like模型，其实据我经验非极性溶剂化能只是很小的一部分能量，一般。这里按照教程来的介绍两个。 SASA模型1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sasa.mdp -nomme -pbsa -decomp -apol sasa.xvg -apcon sasa_contrib.dat SAV模型1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sav.mdp -nomme -pbsa -decomp -apol sav.xvg -apcon sav_contrib.dat 一步计算非常简单方便，也没有从教程中看出说差别1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../pbsa.mdp -pdie 2 -pbsa -decomp` 平均结合能计算使用的脚本在此下载。注意需要python包含numpy和scipy。可以简单如下查看:1python 12import numpyimport scipy 查看是否报错。若报错可以分别如下安装123456789# Ubuntu下，推荐sudo apt-get install python-numpysudo apt-get install python-scipy# pippip install numpypip install scipy# conda，一般自带，推荐 最后命令如下1python MmPbSaStat.py -m energy_MM.xvg -p polar.xvg -a apolar.xvg (or sasa.xvg) 输出文件full_energy.dat和summary_energy.dat。summary_energy.dat文件内容如下:12345678910111213141516171819202122#Complex Number: 1 =============== SUMMARY =============== van der Waal energy = -334.587 +/- 15.514 kJ/mol Electrostattic energy = -159.380 +/- 15.810 kJ/mol Polar solvation energy = 313.698 +/- 10.174 kJ/mol SASA energy = -30.431 +/- 0.996 kJ/mol SAV energy = 0.000 +/- 0.000 kJ/mol WCA energy = 0.000 +/- 0.000 kJ/mol Binding energy = -210.699 +/- 19.745 kJ/mol =============== END =============== full_energy.dat包含Δ_E_MM, Δ_G_polar, Δ_G_nonpolar 和 Δ_G_binding随时间的关系。例如如下图: 图1 能量拆分这个应该大家在很多地方都看过，就是看每个残基对小分子的贡献:1python MmPbSaDecomp.py -bs -nbs 2000 -m contrib_MM.dat -p contrib_pol.dat -a contrib_apol.dat 输出文件final_contrib_energy.dat和energyMapIn.dat.final_contrib_energy.dat包含对所有三个能量项（包括每个残基的结合能）的贡献能量以及标准误差的平均值。 energyMapIn.dat和xmgrace / matplotlib / gnuplot可用来绘制每个残基的贡献能量（需要删除抑制剂）。例如下图所示 图2 在VMD中可视化能量贡献其主要是把其写入到PDB文件中B-factor 那一行，用B-factor 来进行做图。使用energy2bfac文件1energy2bfac -s 1EBZ_pbc_corrected.tpr -i energyMapIn.dat 输出文件complex.pdb, subunit_1.pdb和subunit_2.pdb,subunit_1.pdb和subunit_2.pdb分别表示第一选择组和第二选择组。在VMD中查看(其实pymol等工具也是可以滴):1vmd subunit_1.pdb 在Drawing Method将图像展示改为NewCartoon . 将 Coloring Method 设为 Beta. 为了获得颜色尺度bar, Extension ⇒ Visulaization ⇒ Color Scale Bar. 选择 Autoscale: On. 选择 Label format: Decimal. 结果如下: 参考1:GROMACS教程:使用GROMACS计算MM-PBSA结合自由能参考2:g_mmpbsa","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"计算蛋白长宽高","slug":"计算蛋白长宽高","date":"2018-01-09T12:25:21.000Z","updated":"2018-01-09T14:36:59.232Z","comments":true,"path":"14.html","link":"","permalink":"http://kangsgo.com/14.html","excerpt":"","text":"最近遇到了两次需要初略估计蛋白长宽高的情况，其实这个非常简单，在pdb中查看卡迪尔坐标然后排序即可。这里和大家分享三种方法： 1.shell进行读取这个我之前其实有分享过,代码简单如下:12345678#!/bin/sh#作者：GROMACS中文组群: 广药-阿福#x轴grep ^ATOM $1 | awk ‘&#123;print $7&#125;’| sort -n |sed -n ‘1p;$p’#y轴grep ^ATOM $1 | awk ‘&#123;print $8&#125;’| sort -n |sed -n ‘1p;$p’#z轴grep ^ATOM $1 | awk ‘&#123;print $9&#125;’| sort -n |sed -n ‘1p;$p’ 2.利用python脚本进行读取计算这个是我今天写的，写的很初略，因为我发现第三种方法最直接简练:123456789101112131415#-*-coding:utf-8-*-x=[]y=[]z=[]for i in open('file.pdb','r'): if i.startswith('ATOM'): new=i.split() x.append(float(new[6])) y.append(float(new[7])) z.append(float(new[8])) else: passprint('长:'+str(max(x)-min(x)))print('宽:'+str(max(y)-min(y)))print('高:'+str(max(z)-min(z))) 3.Pymol进行读取计算其实简单的方便的方法可以使用Pymol的get_extent来获得XYZ的最大最小值，如下排列:1[ [ min-X , min-Y , min-Z ],[ max-X, max-Y , max-Z ]] 可以使用命令行如下:1get_extent sele PYMOL API如下:1cmd.get_extent(string selection=\"(all)\", state=0 )","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"Amber教程5:模拟绿色荧光蛋白","slug":"Amber模拟绿色荧光蛋白","date":"2018-01-09T08:10:20.000Z","updated":"2018-01-10T05:55:49.526Z","comments":true,"path":"16.html","link":"","permalink":"http://kangsgo.com/16.html","excerpt":"","text":"教程B5 模拟绿色荧光蛋白原文:Jason Swails,Dave Case, Tai-Sung Lee译: 湖南大学-康文渊 建议移步查看许楠(浙江大学)修订的版本 绿色荧光蛋白的结构，配体分子使用球棍模型展示 介绍这个教程主要是介绍怎样用Amber进行分子动力学模拟一个带有非标准氨基酸残基的体系。需要注意的是非标准的残基是聚合物的一部分，这不同于其他的有机小分子参数力场构建的例子，所以相对更加复杂，主要涉及电荷的计算和准备恰当的文件用于肽链中的非标准残基。 我们假设你已经运行过仅含标准氨基酸残基的基本模拟体系（同时建议熟悉antechamber Sustiva tutorial ）,所以该教程主要关注非标准氨基酸残基的参数构建。不过本教程同时包含完整的GFP（绿色荧光蛋白）分子动力学流程。 教程的大纲如下:1.使用AMBER准备PDB文件2.计算非标准氨基酸残基的电荷和原子类型3.使用LEaP准备残基文库和力场参数4.创建用于模拟的拓扑和坐标文件5.使用生成的文件进行最小化，加热，平衡和正式模拟 让我们开始do it！ 第1部分：准备PDB文件我们开始于1EMA.pdbPDB文件，其包含GFP和CRO生色团。因此我们首先从RCSB网站下载PDB文件（或者点此下载副本）.你可以看到CRO残基位于PDB文件中的896行，标记残基编号为66（残基65和67并入残基66生成生色团，PDB文件头部有描述）。 第一步是在准备使用tleap之前给PDB文件“按摩”。为了使用tleap,Amber包括一个名为pdb4amber的脚本，可以修饰PDB文件。--help标签可以展示所有可用的设置。我们将使用--dry标签来移除晶体水，--reduce标签增加氢原子到它们最理想的位置。 1pdb4amber -i 1EMA.pdb -o gfp.pdb --dry --reduce 需要提醒的是你要了解pdb4amber到底“做”了什么。现在输出的PDB文件应该每个残基都包含了对应的氢键（该体系中没有二硫键，如果体系中包含二硫键，pdb4amber会在正确的位置为你加上二硫键）。运行pdb4amber之后，你需要修改gfp.pdb文件，将MSE残基（硒代甲硫氨酸，selenomethionine）改为标准的MET（我们需要模拟的是野生型变体，而不是为了结晶而刻意突变的版本）。你可以使用sed或者你喜爱的编辑软件将MSE全局替换为MET。此外，你需要转换硒原子变为硫原子（名称为SD）以及将元素符号SE转为S。建议您自己运行命令，当然也可以下载我们的副本gfp.pdb文件进行比较。 第2部分:计算CRO分解电荷和原子类型我们通过1EMA.pdb的头部文件了解到CRO是非标准氨基酸残基（实际上是三个氨基酸残基环化形成）。因此，Amber的标准氨基酸残基库不包含该残基的原子类型和电荷。单这些是分子模拟所需要的。 这一部分教程主要关注于如何制作CRO电荷和测定其原子类型。我们将使用antechamber使用bcc电荷方案生成电荷，如果你运行过介绍中提到过的Sustiva教程方案你应该熟知（操作的方法）。需要注意的是该选择不是唯一的，并且对于所有应用也可能不是最佳方案。另外一些工具，例如R.E.D.Tools提供了更加严谨和可重复的计算电荷，但是对于这个教程，antechamber工具已足够。如果你希望使用R.E.D.，他们拥有一定数量的教程，你可以用来生成电荷和原子类型，之后可以直接查看第4部分教程. CRO模板我们可以使用Protein Data Bank中的非常有用的”components.cif”(在此查看)，对于每个包含在PDB文件中的化合物，其都包含观察到的和假想的结构。使用这个解决了坐标问题，并且确保了原子和残基名称会和您的PDB文件相匹配。如果你在PDB中搜索“CRO”，选择配体ID的搜索结果，你将会进入一个站点，其可以下载CRO component CIF文件，CRO.cif.(可以点此下载copy) antechamber项目将会阅读component CIF（ccif）文件，并且生成电荷和原子类型。你应该查询”Antechamber and GAFF”章节的Amber参考手册的描述和例子。当然你也可以在命令行中输入antechamber -help获取关于设置的详细信息。在这里我们告知他原子类型为Amber类型(-at amber)，因为这是一个修饰的氨基酸残基，分子和Amber原子类型参数是相似的（对于更普遍的有机小分子，通常使用gaff原子类型会更好）我们使用如下的命令来运行antechamber（通常需要几分钟的时间）: 1antechamber -fi ccif -i CRO.cif -bk CRO -fo ac -o cro.ac -c bcc -at amber 在生成的许多其他文件中，你可以看到cro.ac文件，其有点像PDB文件，但是包含键，分解的原子电荷和原子类型参数。需要注意的是antechamber是为gaff原子类型所使用的，所以在制作Amber原子类型的时候会出现一些错误，在这个例子中，我们需要修复起始的N原子，其需要拥有酰胺氮(N)同样的类型。你可以手动简单的改变原子类型NT变为N。(或者当作练习，使用sed,awk,perl等工具修改)，你可以下载cro.ac和您的文件做比较。 现在我们有antechamber分子文件，其包含分解原子电荷和原子类型。下一部分将会讨论怎样创建残基库文件和为LEaP做准备。 提醒:你通常需要使用antechamber来创建mol2文件给LEaP阅读。但是我们随后的流程需要先将结果文件给prepgen进行阅读，所以我们需要使用prepgen能够阅读的ac格式文件。 第3部分:准备给LEaP所使用的残基库和力场参数我们从PDB下载的“CRO”组件是一个完整的分子，包含了所有的氢原子，这是antechamber（或任何量子力学程序）计算电荷所需要的。 但是我们需要在开头和结尾处去除原子，以便制备一个“氨基酸”样残基，该氨基酸残基可以在其N-端和C-端与其他氨基酸连接。 这部分可以使用prepgen项目和”mc”(主链)文件进行准备，该文件定义哪些原子需要被移除，哪些原子是主链的一部分(例如:骨架原子)。通常需要自己创建该文件。下面的内容是该教程的例子:12345678910111213HEAD_NAME N1TAIL_NAME C3 MAIN_CHAIN CA1MAIN_CHAIN C1MAIN_CHAIN N3MAIN_CHAIN CA3OMIT_NAME H2OMIT_NAME HN11OMIT_NAME OXTOMIT_NAME HXTPRE_HEAD_TYPE CPOST_TAIL_TYPE NCHARGE 0.0 HEAD_NAME和TAIL_NAME行的原子将会联系前后氨基酸残基。MAIN_CHAIN行列出连接头和尾原子之间链中的原子,OMIT_NAME行列出了CRO残基中应该从最终结构中去除的原子，因为它们不存在于完整蛋白质中。PRE_HEAD_TYPE和POST_TAIL_TYPE行让prepgen知道周围蛋白质中哪些原子类型将用于共价连接。(需要记住的是prepgen在用于蛋白和多肽以外还可以用于聚合物的制作)CHARGE行设定氨基酸残基的总电荷，prepgen将确保“删除的”原子电荷在剩余的原子之间重新分配，以便总电荷是正确的。(在这个例子中为0) 之后，你可以对prepgen使用-help标签来查看该项目所有可用的设置。随后运行prepgen将会除去N端和C端不需要的原子，假设你的主链文件命名为cro.mc:1prepgen -i cro.ac -o cro.prepin -m cro.mc -rn CRO 运行该命令之后你将会拥有cro.prepin文件，包含定义的CRO残基（可以从此下载相互比较） 此刻，我们拥有包含我们修饰的氨基酸残基的原子电荷的残基库。接下来我们需要检查其共价参数(bonds,angles和diherals)，查看他们是否可用。parmchk2项目将会描绘出哪些参数是需要的，并且在标准文件中寻找。如果没有找到，将会进行训练过的猜测，并且放入新参数到文件中，我们命名为”frcmod.cro”。 我们使用如下命令运行parmchk2(同样的可以使用-help标签查看可用的设置):12parmchk2 -i cro.prepin -f prepi -o frcmod.cro -a Y \\ -p $AMBERHOME/dat/leap/parm/parm10.dat 这里我们指定parm10.dat文件，因为它是我们打算使用的ff14SB力场的主要参数数据库，（这个信息可以在您打算使用的力场的leaprc文件中找到）。 如果我们删除这个标签，那么parmchk2将匹配gaff数据库中的参数，这并不是我们想要的。我们还要求打印所有的参数（即使是在parm10.dat中完美匹配的参数），原因很快就会明了。 完成这一步之后，查看frcmod.cro（你可以比较我们的frcmod.cro副本）。 您应该马上看到了含有标记为ATTN的参数的行的问题需要修改。 这表示parmchk2在parm10.dat数据库中找不到适当的相似参数。 还有许多其他的参数被选择为具有高惩罚（这表明parmchk2的结果是不合适的）。 一个简单的解决办法是通过设置parm10.dat,使用parmchk2搜寻gaff.dat来“填充”不存在或者高惩罚的参数。所以我们需要删除frcmod.cro中标为ATTN:need revision的参数，并且告诉parmchk2在gaff.dat(默认设置)中搜寻。来自parm10.dat内的参数我们想要保留，而其他参数使用gaff参数填充到frcmod1.cro文件中（这也是为什么我们需要使用-a Y标签打印所有参数）。完成这些设置的命令如下:12grep -v \"ATTN\" frcmod.cro &gt; frcmod1.cro # Strip out ATTN linesparmchk2 -i cro.prepin -f prepi -o frcmod2.cro 至此，我们拥有两个frcmod文件，一个参数来自于Amber参数数据库(frcmod1.cro,可以再此下载副本进行比较),另一个参数为gaff原子类型(frcmod2.cro,可以再此下载副本进行比较),在这两个参数之中拥有所有我们需要的内容。如果你想，你可以从frcmod2.cro种提取7个缺失参数（和附加的高惩罚参数），将其添加到frcmod1.cro中。然而，如果你按照教程顺序进行操作，这些参数会在下一部分加载，不需要进行这一步操作。然我们继续下面的步骤来创建prmtop和inpcrd文件。 与往常一样，这里生成的参数 - 尤其是由gaff提供的参数，应被视为一个起点，应该根据可用的实验或高水平QM数据进行验证。 为了本教程的目的，我们将简单地继续我们在这里生成的内容。 第4部分:创建用于模拟的拓扑和坐标文件我们现在有了我们需要的所有文件来创建用于sander或pmemd的拓扑和坐标文件！我们只需要将这些文件加载到LEaP来创建这些文件。 如果你使用R.E.D. 或其他一些工具来做电荷推导和原子类型，欢迎回到教程。 对于这个例子，我们使用ff14SB力场和igb=8隐性水模型，描述可以查看Amber参考手册。将默认PBRadii设置为“mbondi3”集是指定力场的一部分。 我们之后加载之前创建的cro.prepin文件。在这种情况下，我们需要首先加载frcmod2.cro文件，随后是frcmod1.cro文件，确保gaff参数会被我们更加想用的ff14SB参数所覆盖。然后我们加入我们准备的1EMA PDB文件（为gfp.pdb），并保存这个结果。脚本展示如下，将其保存为tleap.in:12345678source leaprc.protein.ff14SBset default PBRadii mbondi3loadAmberPrep cro.prepinloadAmberParams frcmod2.croloadAmberParams frcmod1.crox = loadPDB gfp.pdbsaveAmberParm x gfp.parm7 gfp.rst7quit 我们可以通过如下命令运行tleap:1tleap -f tleap.in 这一步骤以后，你应该有完整的拓扑和坐标文件，你已经准备开始模拟啦！你可以下载我们创建的副本和你的进行比较.进入部分5！ 第5部分：模拟；最小化，加热，平衡和正式（模拟）由于本教程的目的是通过对修饰聚合物“link”进行参数化，本部分仅作简要介绍。 在你自己的项目中，你当然可以自由选择显式溶剂模型和比我们在这里使用的更小心的最小化，加热和平衡程序（也许利用位置限制来防止结构扭曲）。 最小化我们使用的最小化输入文件如下。我们将该文件命名为min.in:1234 simple generalized Born minimization script&amp;cntrl imin=1, ntb=0, maxcyc=100, ntpr=10, cut=1000., igb=8, / 我们可以使用sander模块运行最小化:1sander -O -i min.in -p gfp.parm7 -c gfp.rst7 -o min1.out -r min1.rst7 如同往常一样，我们建议可视化查看结果结构(mini1.rst7)来确保观察没有糟糕的事情发生，并且输出文件确保所有的看起来都正常（例如:结构完整，在最小化期间总能量最大梯度稳步下降）。我们创建的输出文件可以作为压缩包的一部分进行下载，压缩包包含本节最后的计算过程中生成的大部分文件。 加热下面显示了我们用于加热的输入文件。 我们将这个文件命名为heat.in，并且将在从10K到300K的200ps的过程中线性地改变目标温度。1234567891011121314Implicit solvent initial heating mdin &amp;cntrl imin=0, irest=0, ntx=1, ntpr=1000, ntwx=1000, nstlim=100000, dt=0.002, ntt=3, tempi=10, temp0=300, gamma_ln=1.0, ig=-1, ntp=0, ntc=2, ntf=2, cut=1000, ntb=0, igb=8, ioutfm=1, nmropt=1, / &amp;wt TYPE=&apos;TEMP0&apos;, ISTEP1=1, ISTEP2=100000, VALUE1=10.0, VALUE2=300.0, / &amp;wt TYPE=&apos;END&apos; / 需要注意的是，我们加热结构时，我们需要使用上一步（最小化）生成的结构来加热。所用使用sander来进行加热操作的命令看起来如下:12sander -O -i heat.in -p gfp.parm7 -c min1.rst7 -o heat.mdout \\ -x heat.nc -r heat.rst7 值得注意的是使用sander可能需要很长世间，我们使用pmemd.cuda运行我们的模拟，在我们的GTX680上运行能够更加快速的完成。与往常一样，使用您最喜爱的可视化工具检查所得结构和轨迹，以确保没有发生任何明显的不良事件。和以前一样，我们生成的文件将在本节末尾的压缩包中提供。 正式模拟！！！这一段翻译的不是很好我们成功的加热了我们的结构！现在我们已经准备开始正式的模拟。请注意，许多人称之为“平衡”的过程实际上只是在分析过程中忽略的正式模拟的一部分，因为要么就是稳定约束的结构，要么就是让系统向平衡位置迁移。为了本教程的目的，我们不区分这两个阶段，我们使用相同的输入对待两者。 我们将使用的输入文件如下，命名为md.in:123456789Implicit solvent molecular dynamics &amp;cntrl imin=0, irest=1, ntx=5, ntpr=1000, ntwx=1000, nstlim=500000, dt=0.002, ntt=3, tempi=300, temp0=300, gamma_ln=1.0, ig=-1, ntp=0, ntc=2, ntf=2, cut=1000, ntb=0, igb=8, ioutfm=1, / 你可以使用随后的命令来运行模拟(再一次，我们将使用pmemd.cuda):12sander -O -i md.in -p gfp.parm7 -c heat.rst7 -o md1.mdout \\ -x md1.nc -r md1.rst7 所有的都完成了！当然，你仍然需要分析你的模拟，以便测试通过首先运行计算得到的结果。现在你已经知道怎样进行一个新的参数化，修饰包含寡聚链的单体单元（例如修饰核苷酸或者氨基酸残基）。这个侧链可以应用你想应用到的任何寡聚单元。 正如我们的承诺，你可以下载我们生成的版本。值得注意的是你的输出绝大部分时候和我们的都会不同（甚至整体参数都会不同，因为1ns的轨迹实在太短）","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Amber","slug":"Amber","permalink":"http://kangsgo.com/tags/Amber/"}]},{"title":"gromacs2018安装教程","slug":"gromacs2018安装教程","date":"2017-12-21T11:50:59.000Z","updated":"2018-01-02T12:07:15.734Z","comments":true,"path":"31.html","link":"","permalink":"http://kangsgo.com/31.html","excerpt":"","text":"首次发布:2015-12-02 第一次更新:2017-12-21 第二次更新:2018-01-02 gromacs2018版本其实和gromacs5.X版本差别不大，正好新电脑到了，这里以2018版本为例进行安装 默认安装在各位文件夹（我的用户名yaolab）的install下： 一.预先安装：123456sudo apt-get install gccsudo apt-get install g++sudo apt-get install gfortran#若不需要GPU加速或者只是学习只用，仅需:#sudo apt-get install gromacs#后面无需在看 二.安装cmake方案一：直接apt-get1sudo apt-get install cmake 方案二：编译安装首先我们需要在cmake官网进行下载 发表文章时版本为3.10.1，所以以该版本为例 1.进入文件目录：1cd /home/yaolab/install 2.解压缩：1tar -xvf cmake-3.10.1.tar.gz 3.进入目录：1cd cmake-3.10.1 4.设置，附加安装路径，我将其安装在cmake文件夹下1./bootstrap --prefix=/home/yaolab/install/cmake 5.安装12makemake install 6.设置路径 gedit ~/.zshrc (1.ubuntu默认为bashrc命令，我这里改为了zshrc，下同，所以你可能下面所有的zshrc都需要改为bashrc 2.倘若你安装在/usr/目录下的话需要sudo获得权限，个人建议最好不要sudo su或者最高权限后进行操作，因为那样子所有的文件都是高权限的) 最底部增加 123PATH=&quot;$PATH:/home/yaolab/install/cmake/bin/:.&quot;#其中/home/yaolab/install/cmake/需要替换为你的路径，下同source ~/.zshrc 6*.查看是否安装好1cmake 三.安装fftw方案一.gromacs安装时集成[推荐]方案二.自行编译安装1234567tar xvf fftw-3.3.4.tar.gzcd fftw-3.3.4./configure –enable-DFFTWF_INCLUDE_DIR –enable-sharedmakesudo make install#设置路径，或者gromacs那一步设置，由于不推荐这种方法，就不过多累述 四.安装openmpiopenmpi可以在官方网站进行下载 1.同样先要进入开始放置下载的目录：1cd /home/yaolab/install 2.解压缩和进入目录,将其安装在openmpi目录下：123tar xvf openmpi-1.10.tar.gzcd openmpi-1.10./configure –prefix=/home/yaolab/install/openmpi 3.安装：12make allmake install 4.环境变量设置：123#openmpiexport LD_LIBRARY_PATH=/home/yaolab/install/openmpi/lib:$LD_LIBRARY_PATHexport PATH=/home/yaolab/install/openmpi/bin:$PATH 五.CUDA驱动安装由于amber和gromacs等许多软件都需要用的，我另起一篇文章，具体可以点我查看 注意两种方法都需要设置路径：123# CUDA export PATH=&quot;$PATH:/usr/local/cuda-9.0/bin&quot;export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64“ 六.GROMACS的安装千呼万唤始出来，终于到了gromacs的安装了～其实gromacs的安装反而更加简单明了，我把其安装在/home/yaolab/install下面 1.进入目录解压进入目录（由于是给予新手帮助，原谅我啰嗦）123cd ~/installtar xfz gromacs2018.tar.gzcd gromacs2018 2.创建文件夹：1mkdir build 3.进入文件夹1cd build 4.编译1234cmake .. -DGMX_BUILD_OWN_FFTW=ON -DGMX_GPU=ON -DGMX_MPI=ON -DCMAKE_INSTALL_PREFIX=/home/yaolab/install/gromacs#倘若FFTW不是自动安装，要**手动**安装的话需要更改为：#-DGMX_FFT_LIBRARY=fftw3 #-DFFTWF_LIBRARY=\"/usr/local/lib/libfftw3f.so\" -DFFTWF_INCLUDE_DIR=\"/usr/local/include/\"#这里就不详细说明了 这里解释一下DGMX_BUILD_OWN_FFTW为是否自动安装FFTW，DGMX_GPU和DGMX_MPI为是否使用GPU模块和MPI模块，DCMAKE_INSTALL_PREFIX为安装路径。值得注意的是若为NVIDIA Tesla或者Quadro GPUS显卡最好增加-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda，能够达到最大利用率 5.安装1234#（32表示make时使用32核，如果只用一个核，只需使用make）make -j 32make checkmake install 6.设置环境变量12# gromacssource /home/kangsgo/mdinstall/md/gromacs/bin/GMXRC 到此gromacs安装到此结束！ 7.遇到的一些问题出现类似如下信息:1nvcc fatal : Unsupported gpu architecture &apos;compute_20&apos; 这个问题的原因为cuda9.0以上版本不支持compute_20造成的，解决办法可以下载最新版本的gromacs，或者cmake/gmxManageNvccConfig.cmake中将1list (APPEND GMX_CUDA_NVCC_GENCODE_FLAGS &quot;-gencode;arch=compute_20,code=sm_20&quot;) 注释掉。 参考文章： 1.【致谢飞天大神及各位坛友】ubuntu、gromacs、g_mmpbsa的安装 GMX在ubuntu系统下的安装，小编个人的安装经验仅供参考！ 3.安装的gromacs 5.0.4 bin 里没有g_solvate_mpi 4.gromacs 5.0.2 mpi+GPU+gnu安装教程（联网+单机安装）","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"Amber17的安装","slug":"Amber17的安装","date":"2017-12-20T23:56:01.000Z","updated":"2017-12-27T15:00:18.284Z","comments":true,"path":"77.html","link":"","permalink":"http://kangsgo.com/77.html","excerpt":"","text":"首次版本:2015-12-3 第一次更新日期:2017-9-11第二次更新日期:2017-12-21 首先您可能需要安装CUDA和Openmpi 这里就不再详细说明，您阅读这篇文章时默认已经安装了这两个 我们以将amber安装在/home/kangsgo/mdinstall/md下为例： 1.进入目录：1cd /home/kangsgo/mdinstall/md 2.解压12345tar xvfj AmberTools17.tar.bz2tar xvfj Amber16.tar.bz2#（注意：amber16需要购买,购买amber16后可以使用GPU加速，价格为500美金）#（注意:虽然AmberTools17，但解压以后为amber16文件夹） 3.设置环境变量：123export AMBERHOME=/home/kangsgo/mdinstall/md/amber16 # (for bash,zsh,ksh,etc.)setenv AMBERHOME /home/kangsgo/mdinstall/md/amber16 # (for csh,tcsh 一般不是这些终端) 4.预编译：12sudo apt-get install csh flex gfortran g++ xorg-dev \\zlib1g-dev libbz2-dev patch python-tk python-matplotlib 5.进入目录：1cd $AMBERHOME（也可以输入：/home/kangsgo/mdinstall/md/amber16 绝对路径） 6.设置一般采用默认安装即可： 1234567./configure gnu# (提示安装miniconda选择安装,不会与自己安装的conda发生冲突，因为其不会写入环境变量)# 若是编写脚本安装可以输入yes自动接收协议，如下yes | ./configure gnu 若自己安装了conda，也可以使用自己的conda，方法如下:1./configure --with-python /home/kangsgo/anconda3/python gnu 其中路径需要修改为自己的 这一步不要安装并行选项，并行需要在后面第10步再进行安装。 7.设置环境变量：12source /home/kangsgo/mdinstall/md/amber16/amber.sh # for bash, zsh, ksh, etc.source /home/kangsgo/mdinstall/md/amber16/amber.csh # for csh, tcsh 8.安装：1make install 如果你没有amber16，那么最后会显示 /home/kangsgo/install/amber16/src/Makefile not found, or -noamber was set. 这是正常现象 9.测试：1make test 注:这一步我报错了，但是终端给了提示 1test -f /home/kangsgo/install/amber16/amber.sh &amp;&amp; source /home/kangsgo/install/amber16/amber.sh 输入以上命令后再 make test就成功了 这一步时间较久，可以能1个小时还没有完成，特别是经常屏幕没有反应这是正常现象不需要惊慌。 10.设置环境变量以下是我自己的写法: 1source /home/kangsgo/install/amber16/amber.sh 11.多线程的安装“由于未用到，只是照搬教程” 123456789cd $AMBERHOME./configure -mpi &lt;…other options…&gt;&lt;compiler-choice&gt;make installexport DO_PARALLEL=”mpirun -np 2″ #核心数可以修改make test &nbsp; 1 参考文献：Amber17官方教程","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"},{"name":"amber","slug":"amber","permalink":"http://kangsgo.com/tags/amber/"}]},{"title":"Open Babel API","slug":"OpenBabel API","date":"2017-12-12T08:10:20.000Z","updated":"2017-12-17T05:27:12.521Z","comments":true,"path":"15.html","link":"","permalink":"http://kangsgo.com/15.html","excerpt":"","text":"介绍此文章不完全翻译自官方文档，不定期更新，欢迎关注 Open Babel是一个非常优秀的支持多种分子格式的开源软件，同时可以进行2D 3D格式的转换，也可以编写脚本。编译安装方法可以查看我们之前的文章。 对于python，Open Babel是支持的很好的，其包括了两个Python包，分别为openbabel模块和Pybel模块。 1.Openbabel模块 其包含标准的Python粘合，来自于C++API，通过SWIG自动生成 2.Pybel模块 这是一个轻量级的openbabel封装类和方法，其提供更多的便利和Pythonic方式来操控Open Babel工具 openbabel模块 包含基本类 OBMol，OBAtom，OBBond和OBResidue，以及转换框架 OBConversion 示例(以下均为python3测试通过)普通的自编分子1234567891011121314151617181920212223import openbabel# 创建实例mol=openbabel.OBMol()print('Should print 0 (atoms)')print(mol.NumAtoms())# 创建新原子a=mol.NewAtom()# C原子,见元素周期表a.SetAtomicNum(6)# 设置坐标a.SetVector(0.0,1.0,2.0)b = mol.NewAtom()# 原子键索引为1mol.AddBond(1, 2, 1) # 输出原子树木print(mol.NumAtoms())# 输出键树木print(mol.NumBonds())mol.Clear() 当然也可以通过阅读SML码读取已有分子进行加氢，输出其他文件的操作，主要是使用OBConversion框架 123456789101112131415161718import openbabelobConversion=openbabel.OBConversion()obConversion.SetInAndOutFormats('smi','mdl')mol=openbabel.OBMol()obConversion.ReadString(mol,\"C1=CC=CS1\")# 将会显示5个原子print(mol.NumAtoms())#加氢mol.AddHydrogens()# 将会显示9个原子print(mol.NumAtoms())outMDL=obConversion.WriteString(mol) 当然也可以阅读文件模式进行阅读123456789101112131415import openbabelobConversion = openbabel.OBConversion()obConversion.SetInAndOutFormats(\"pdb\", \"mol2\")mol = openbabel.OBMol()obConversion.ReadFile(mol, \"1ABC.pdb.gz\") # Open Babel will uncompress automaticallymol.AddHydrogens()print(mol.NumAtoms())print(mol.NumBonds())print(mol.NumResidues())obConversion.WriteFile(mol, '1abc.mol2') 使用迭代器许多Open Babel工具包提供迭代器，其后缀为”iter”,所有的API可以在官网查询 Pybel模块Pybel我觉得是更加好用更加容易理解的工具，使用的方法也很容易，就是import pybel或者from pybel import * 原子和分子分子可以通过三种方法进行创建: 1.使用OBMol 2.从文件中阅读（见下） 3.从字符串中阅读（见下） 原子可以通过两种方法创建: 1.使用OBAtom 2.分子中的原子 分子的话有如下属性:atoms,charge,data,dim,energy,exactmass,formula,molwt,spin,sssr,title和unitcell（这个需要晶体数据）,atoms属性主要是提供分子中的所有原子列表，data属性可以看作一个字典，可以阅读和编辑数据。 以下为一个示例，让我们假设有一个SD文件包含数据的描述","categories":[{"name":"预处理","slug":"预处理","permalink":"http://kangsgo.com/categories/预处理/"}],"tags":[{"name":"OpenBabel","slug":"OpenBabel","permalink":"http://kangsgo.com/tags/OpenBabel/"}]},{"title":"gromacs中构建非标准氨基酸残基力场","slug":"gromacs中构建非标准氨基酸残基力场","date":"2017-12-09T12:33:22.302Z","updated":"2017-12-10T05:13:21.335Z","comments":true,"path":"13.html","link":"","permalink":"http://kangsgo.com/13.html","excerpt":"","text":"Gromacs非标准残基构建李老师其实已经有非常详细的实例来讲解如何进行非标准残基的搭建方法，此方法是之前根据李老师的方法结合amber教程进行改编的方法，可以作为参考。 我们使用ser磷酸化的蛋白作为实验，由于还未发表文章，暂时不提供示例步骤下载。若有问题可以邮件联系我交流：kangsgo#vip.qq.com 1.单独保存非标准残基我们首先使用pymol将sep独立导出12select not resn SEPremove sele 将其保存为sep.pdb文件，当然也可以直接用gedit等打开文件，将SEP部分（HETAM）copy导出 sep文件内容如下:1234567891011121314ATOM 1 N SEP A 219 10.386 -7.407 38.687 1.00 31.68 N ATOM 2 CA SEP A 219 10.979 -8.567 39.325 1.00 31.58 C ATOM 3 C SEP A 219 12.450 -8.306 39.481 1.00 28.97 C ATOM 4 O SEP A 219 13.189 -8.279 38.504 1.00 28.84 O ATOM 5 CB SEP A 219 10.724 -9.808 38.495 1.00 0.00 C ATOM 6 OG SEP A 219 11.474 -10.889 39.010 1.00 0.00 O ATOM 7 P SEP A 219 11.419 -12.337 38.313 1.00 0.00 P1+ATOM 8 O2P SEP A 219 12.339 -13.139 39.147 1.00 0.00 O1-ATOM 9 O1P SEP A 219 9.990 -12.703 38.422 1.00 0.00 O1-ATOM 10 O3P SEP A 219 11.893 -12.061 36.938 1.00 0.00 O1-ATOM 11 H SEP A 219 10.767 -7.078 37.811 1.00 31.68 H ATOM 12 HA SEP A 219 10.534 -8.738 40.305 1.00 31.58 H ATOM 13 HB2 SEP A 219 9.662 -10.058 38.502 1.00 0.00 H ATOM 14 HB3 SEP A 219 11.035 -9.614 37.467 1.00 0.00 H 不难看出带的电荷为-2 我们需要补全两端的氢键(封端)，我是用gview补全的，也可以用pymol,chimera等补全，但是需要注意的是要查看补全的氢键是否正确，我在chimera上补全的氢键就有问题，对于补全氢键，个人的经验觉得正确度排序为:gv&gt;chimera&gt;pymol 补全后如下:12345678910111213141516171819202122232425262728293031323334HETATM 1 N SEP A 219 10.386 -7.407 38.687 NHETATM 2 CA SEP A 219 10.979 -8.567 39.325 CHETATM 3 C SEP A 219 12.450 -8.306 39.481 CHETATM 4 O SEP A 219 13.189 -8.279 38.504 OHETATM 5 CB SEP A 219 10.724 -9.808 38.495 CHETATM 6 OG SEP A 219 11.474 -10.889 39.010 OHETATM 7 P SEP A 219 11.419 -12.337 38.313 PHETATM 8 O2P SEP A 219 12.339 -13.139 39.147 OHETATM 9 O1P SEP A 219 9.990 -12.703 38.422 OHETATM 10 O3P SEP A 219 11.893 -12.061 36.938 OHETATM 11 H SEP A 219 10.767 -7.078 37.811 HHETATM 12 HA SEP A 219 10.534 -8.738 40.305 HHETATM 13 HB2 SEP A 219 9.662 -10.058 38.502 HHETATM 14 HB3 SEP A 219 11.035 -9.614 37.467 HHETATM 15 2H SEP A 219 10.544 -6.657 39.329 HHETATM 16 H SEP A 219 12.857 -8.142 40.457 HTER 16 SEP A 219ENDCONECT 1 2 11 15CONECT 2 1 3 5 12CONECT 3 2 4 16CONECT 4 3CONECT 5 2 6 13 14CONECT 6 5 7CONECT 7 6 8 9 10CONECT 8 7CONECT 9 7CONECT 10 7CONECT 11 1CONECT 12 2CONECT 13 5CONECT 14 5CONECT 15 1CONECT 16 3 2.制作高斯输入文件1antechamber -fi pdb -i sep.pdb -fo gcrt -o sep.gjf -ch \"sep.chk\" -gm \"%mem=2048MB\" -gn \"%nproc=4\" -nc -2 如果按照李老师的方法还需要使用-ge 生成高斯esp文件，通过iop(6/50=1)，可以参考下面一条命令1antechamber -fi pdb -i sep.pdb -o ligand.gjf -fo gcrt -pf y -gn \"%nproc=8\" -gm \"%mem=1000MB\" -ch \"ligand\" -gk \"#HF/6-31G* SCF=tight Test Pop=MK iop(6/33=2) iop(6/42=6) iop(6/50=1) opt\" -ge ligand.gesp -gv 1 命令解释如下:-fi为输入格式-i为输入文件-fo为输出文件格式 gcrt为高斯gjf格式-ch为高斯chk文件-gm -gn为使用内存和核数-nc 为电荷数 3.转化为gromacs文件实际上与蛋白配体中的小分子制作方式是一样的，首先在这里下载ACPYPE，注意需要下载sf版本,否则而面角的表达方式不对，首先生成mol2文件1antechamber -fi gout -i sep.log -rn SEP -fo mol2 -o sep.mol2 -c resp -pf y -at amber 在这里最好修改一下原子名称，改成与sep.pdb对应，且需要对其进行修改，因为gromacs加氢从1开始，故将HB2,HB3改为HB1,HB2最后的结果如下:12345678910111213141516171819...@&lt;TRIPOS&gt;ATOM 1 N 3.0030 -1.1500 0.1620 N 1 SEP -1.141452 2 CA 1.8370 -0.4940 -0.4350 CT 1 SEP 0.462377 3 C 1.8020 0.9980 -0.1460 C 1 SEP 0.457721 4 O 2.8040 1.5940 0.1700 O 1 SEP -0.633121 5 CB 0.5190 -1.1870 -0.0550 CT 1 SEP 0.192426 6 OG -0.5100 -0.6800 -0.7990 OS 1 SEP -0.641051 7 P -1.7850 0.1390 0.0880 P 1 SEP 1.339193 8 O2P -2.7260 0.5020 -1.0190 O2 1 SEP -0.920441 9 O1P -2.2370 -0.9110 1.0650 O2 1 SEP -0.920441 10 O3P -1.0110 1.2850 0.7110 O2 1 SEP -0.920441 11 H 2.7710 -1.3680 1.1160 H 1 SEP 0.367588 12 HA 1.9150 -0.5690 -1.5210 H1 1 SEP -0.041482 13 HB1 0.6570 -2.2570 -0.2470 H1 1 SEP -0.007243 14 HB2 0.3490 -1.0790 1.0140 H1 1 SEP -0.007243 15 H2 3.7290 -0.4600 0.2230 H 1 SEP 0.367588 16 H1 0.8340 1.4820 -0.2400 HA 1 SEP 0.046022.... 生成的mol2文件使用parmchk2进行补全参数1parmchk2 -i sep.mol2 -f mol2 -o sep.frcmod 创建leap.in文件，输入如下内容（注意sep修改成自己的名称）:1234567source leaprc.ff99SBildnsource leaprc.gaffloadamberparams sep.frcmodlig=loadmol2 sep.mol2check ligsaveamberparm lig sep.prmtop sep.inpcrdquit 运行1tleap -f leap.in 运行acpype1python2.7 acpype.py -p sep.prmtop -x sep.inpcrd -d 将会生成SEP_GMX.top和SEP_GMX.gro两个文件，其中SEP_GMX.gro我们用不着 4.整理残基的rtp条目为了保存力场rtp信息，我们需要创建一个sep.rtp文件我们需要对SEP_GMX.gro文件进行整理，即把虚拟的原子电荷附加到N端头和C端尾部的位置。如:123456789101112131415161718[ atoms ]; nr type resi res atom cgnr charge mass ; qtot bond_type 1 N 1 SEP N 1 -1.141453 14.01000 ; qtot -1.141 2 CT 1 SEP CA 2 0.462377 12.01000 ; qtot -0.679 3 C 1 SEP C 3 0.457721 12.01000 ; qtot -0.221 4 O 1 SEP O 4 -0.633122 16.00000 ; qtot -0.854 5 CT 1 SEP CB 5 0.192426 12.01000 ; qtot -0.662 6 OS 1 SEP OG 6 -0.641052 16.00000 ; qtot -1.303 7 P 1 SEP P 7 1.339196 30.97000 ; qtot 0.036 8 O2 1 SEP O2P 8 -0.920442 16.00000 ; qtot -0.884 9 O2 1 SEP O1P 9 -0.920442 16.00000 ; qtot -1.805 10 O2 1 SEP O3P 10 -0.920442 16.00000 ; qtot -2.725 11 H 1 SEP H 11 0.367588 1.00800 ; qtot -2.358 12 H1 1 SEP HA 12 -0.041482 1.00800 ; qtot -2.399 13 H1 1 SEP HB1 13 -0.007243 1.00800 ; qtot -2.406 14 H1 1 SEP HB2 14 -0.007243 1.00800 ; qtot -2.414 15 H 1 SEP H2 15 0.367588 1.00800 ; qtot -2.046 16 HA 1 SEP H1 16 0.046022 1.00800 ; qtot -2.000 1 N的电荷应该变为-1.141453+0.3675883 C的电荷应该变为0.457721+0.046022 然后用我写的脚本进行内容的提取:首先创建config.txt文件，在其中写入需要删除的虚拟原子(每一行一个)12HHA 然后运行1python rtp.py SEP_GMX.top SEP&gt;data.txt 结果如下:1234567891011121314151617181920212223242526[ bondedtypes ]; bonds angles dihedrals impropers all_dihedrals nrexcl HH14 RemoveDih 1 1 9 4 1 3 1 0[ SEP ] [ atoms ] N N -0.773865 1... [ bonds ] N CA 1.4620e-01 2.7506e+05 N H 1.0130e-01 3.3740e+05 CA C 1.5240e-01 2.6192e+05... [ angles ] N CA C 1.0906e+02 5.6066e+02 N CA CB 1.1161e+02 5.5153e+02 N CA HA 1.0888e+02 4.1706e+02 CA N H 1.1768e+02 3.8325e+02 CA C O 1.2320e+02 5.6400e+02... [ dihedrals ] ; propers N CA C O 180.00 0.00000 9 N CA CB OG 0.00 0.65084 9 N CA CB HB1 0.00 0.65084 9 N CA CB HB2 0.00 0.65084 9... [ impropers ] 我们需要在[bonds]中增加前一个氨基酸残基的联系连接,[impropers]中增加前后氨基酸残基的联系连接，可以简单的看非标准残基来源的氨基酸残基模板(aminoacids.rtp)或者查看SEP_GMX.top文件中删除的两个氢原子的部分，最后整理结果如下:1234567891011... [ bonds ] -C N N CA 1.4620e-01 2.7506e+05 N H 1.0130e-01 3.3740e+05 CA C 1.5240e-01 2.6192e+05 CA CB 1.5380e-01 2.5179e+05... [ impropers ] -C CA N H CA +N C O 5.整理残基的hdb条目由于氢键一般有问题，我们需要重新绘制氢键，那么我们创建一个sep.hdb的文件，按照下图来进行设置(图片来源李老师博客): 图 结果如下图(可以抄SER的信息):1234SEP 31 1 H N -C CA1 5 HA CA N CB C2 6 HB CB CA OG 6.模拟尝试将gromacs 目录下(gromacs/share/gromacs/top)中的amber99sb-ildn.ff拷贝至实验目录下（如果找不到可以用which gmx_mpi），将sep.rtp文件和sep.hdb文件放到拷贝出来的amber99sb-ildn.ff目录下。且在top目录下的residuetypes.dat中申明SEP为蛋白，即:12345678910SEP Protein ; sep，增加部分ABU ProteinACE ProteinAIB ProteinALA ProteinARG ProteinARGN ProteinASN ProteinASN1 Protein... 最后进行模拟尝试看是否可以跑通1gmx_mpi pdb2gmx -f model.pdb -o model_process.gro -water tip3p -ignh 若提示前一个残基或者末端残基报错，那么检查是否是上述两个文件出错，若提示缺失（SEP的）原子，那么创建sep.atp文件，在SEP_GMX.top,找到提示的缺失原子，放入该文件中，最后将sep.atp文件放到拷贝出来的amber99sb-ildn.ff目录下。 参考资料:GROMACS非标准残基教程2-芋螺毒素小肽实例向gromacs中添加小分子力场方法 amber中非标准氨基酸残基的参数生成Simulating the Green Fluorescent Protein使用AmberTools+ACPYPE+Gaussian创建小分子GAFF力场的拓扑文件","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"mahotas进行细胞统计开胃菜","slug":"mahotas进行细胞统计开胃菜","date":"2017-11-27T04:27:23.000Z","updated":"2017-12-01T11:02:28.344Z","comments":true,"path":"9.html","link":"","permalink":"http://kangsgo.com/9.html","excerpt":"","text":"Python 图像教程介绍需要用到的软件 Python 3+ numpy matplotlib mahotas ipython&amp;notebook 第一个项目:计算细胞核我们的第一个任务是进行细胞核的计算，你可以点击图像进行下载到本地跟着进行运行 1 首先导入包 123import numpy as npimport matplotlib.pylab as pltimport mahotas as mh 对于Python，有能够通过包来完成许多工具，而不是一个包。我们用numpy数组进行储存图像，在我们的案例中，其是一个二维数组（高X宽），或者，对于彩色图像，为三维数组（高X宽X3或者高X宽X4，其中3和4分别表示red，green，blue或者red，green，blue，alpha的元组，其中alpha为透明度）首先我们读取图像进入内存: 1dna=mh.imread('dna.jpeg') 玩弄在交互模式，例如ipython，你可以查看使用如下方法查看图像 12plt.imshow(dna)plt.show() png 你可能惊讶图片并不像原来的图片是黑色的，原因是plt默认展示的为jet() bar，你可以通过切换colormap来切换成默认的灰度图，例如如下: 123plt.imshow(dna)plt.gray()plt.show() png 你还可以探索如下: 1234print(dna.shape)print(dna.dtype)print(dna.max())print(dna.min()) (1024, 1344) uint8 252 0 12plt.imshow(dna // 2)plt.show() png 我们将图片所有性质除以2，然而得到的结果居然一样，实际上plt在展示图片之前会进行对比扩展 一些实际的工作现在我们开始实际的计算核酸的工作，我们对开篇导入的图片的物体（objects）进行计算 123T=mh.thresholding.otsu(dna)plt.imshow(dna&gt;T)plt.show() png 在这里，我们又一次利用了dna是一个numpy数组，并在逻辑运算中使用它（dna&gt; T）的事实。 结果是一个布尔值的数组，这个pylab显示为一个黑白图像。但是看起来不是那么美好，因为图像包含了许多小的物体。这里有两个方法解决它。一个简单的方法是使用Gaussian筛选抚平小的物体 1234dnaf = mh.gaussian_filter(dna, 8).astype('uint8')T = mh.thresholding.otsu(dnaf)plt.imshow(dnaf&gt;T)plt.show() png mh.gaussian_filter接收图像并过滤器的标准偏差(以像素为单位)并返回过滤后的图像，但是一个更好的方法是使用mahotas筛选图像并且计算阈值，使用numpy操作创建的图像，并用plt展示他们，但是所有的工作都是数组完成的，这样的结果会更好。 我们现在进行一些细胞核的merged。 最后的计数只是一个额外的函数调用： 12345labeled,nr_objects=mh.label(dnaf&gt;T)print(nr_objects)plt.imshow(labeled)plt.jet()plt.show() 18 我们拥有物体的图像为18个，展示的为标记的（labeled）图像，使用jet()进行着色我们可以探索标记的物体，其是一个整数的数组，它的值是该位置上对象的标签，所以值的范围从0（背景）到nr_objects。 第二个项目:分隔图像通过第一个项目，我们完成的还是令人满意，但是仍然有一些核酸是黏在一起的，然我们to do better这里有一个简单的，传统的想法: 平滑图像 寻找区域最大值 使用区域最大值作为watershed的种子 寻找种子但是且慢，有一些细胞在照片上重叠了，被我们算作一个细胞了。显然是这不科学的，因此我们需要更精确的计算方法。接下来我们要讨论的方法寻找团块的中心点并计算中心点的个数。这里我们假设在灰度图上，团块比较中心的地方比较亮，最亮的地方就是最中心的地方。这个东西叫regional maxima，相当于一片山脉中的最高峰。我们找到这个点之后，进行标亮，并且与原来的灰度图重叠在一起。首先我们进行如下的尝试 12345#plt.figure(figsize=(15,15))dnaf=mh.gaussian_filter(dna,8).astype('uint8')rmax=mh.regmax(dnaf)plt.imshow(mh.overlay(dna,rmax))plt.show() png mh.overlay()返回一个彩色图像，第一个参数给出灰度级分量，而第二个参数作为红色通道。 结果看起来不太好：稍微摆弄一下后，我们决定用一个更大的sigma尝试相同的想法： 12345plt.figure(figsize=(15,15))dnaf=mh.gaussian_filter(dna,15).astype('uint8')rmax=mh.regmax(dnaf)plt.imshow(mh.overlay(dna,rmax))plt.show() png 看起来好许多，我们可以方便的统计核算数量了 12seeds,nr_nuclei=mh.label(rmax)print(nr_nuclei) 22 Watershed我们打算将Watershed应用于阈值图像的距离变换(使用矩阵最大值减去矩阵内所有元素，使得矩阵元素的数值原来大的变小，小的变大,得到下图)： 12345678T=mh.thresholding.otsu(dnaf)dist = mh.distance(dnaf&gt;T)dist = dist.max()-distdist -= dist.min()dist = dist/float(dist.ptp())*255dist = dist.astype(np.uint8)plt.imshow(dist)plt.show() png 现在，根据矩阵的元素的大小，以之前得到的一堆最高峰（seeds）为核心位置，观察每个核心与邻居核心之间的边界（元素数值的局域极大值），把这个边界标记出来。就得到了核心的区域划分图。 123nuclei=mh.cwatershed(dist,seeds)plt.imshow(nuclei)plt.show() png 参考资料:原文使用python做图像处理","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"mahotas","slug":"mahotas","permalink":"http://kangsgo.com/tags/mahotas/"}]},{"title":"mahotas安装教程","slug":"mahotas安装教程","date":"2017-11-25T16:38:23.000Z","updated":"2017-11-25T16:56:10.346Z","comments":true,"path":"8.html","link":"","permalink":"http://kangsgo.com/8.html","excerpt":"","text":"hi!各位好久不见，小伙伴们的科研道路是否顺利。我的导师告诉我要讲好故事，才能让人觉得生动有趣，所以我今天想用另外一种方式和大家分享今天发现的一个大玩意儿 故事的开始是我有一张图片，想计算图片里东西的长宽，如果一个一个数，一个个比，那太费劲了，所以就百度了一下，看一下有什么办法解决没有，然后谷歌到了一个python处理细胞细胞核的工具，觉得自己应该能够用的上（后面和大家分享），进一步挖掘发现他是用的mathotas这个包。 进一步进入github上发现其作者是如下光头男(luispedro): luispedro是一个计算生物科学家（小伙伴们看到这里是否两眼发光），其原来是利用宏基因组分析微生物群体，对其机器学习和数学等打下了非常坚实的基础，现在主要是利用生物图像信息学进行细胞亚定位分析，现在其工作于Murphy Lab 所以小伙伴们有细胞等图像处理的时候可以关注一下这个包，我在后期也会分享一些包的应用给大家。今天仅仅简答介绍一下。 Mahotas 是一个快速的视觉算法的Python包，其主要是用C++写成，速度甚至超过了numpy数组计算操作。 现在有如下算法: watershed convex points calculation hit &amp; miss, thinning Zernike &amp; Haralick, LBP, and TAS features Speeded-Up Robust Features(SURF), a form of local features. thresholding convolution Sobel edge detection spline interpolation SLIC super pixes 现在Mahotas有超过100种的图像程序处理功能和计算机视觉功能，且现在还在增加。 安装言归正传我，我们简单介绍一下安装方法，最简单的安装方法就是使用conda安装，其中conda加强包（conda-forge）具有mahots12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda install mahotas 其他方法包括pip安装1pip install mahotas windows 还可以进行包安装，地址为:http://www.lfd.uci.edu/~gohlke/pythonlibs/ 不过还是建议用conda安装，是否安装成功仅需要import mahotas as mh导入一下看一下是否报错即可","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"mahotas","slug":"mahotas","permalink":"http://kangsgo.com/tags/mahotas/"}]},{"title":"利用Pymol将周边图像虚化","slug":"利用Pymol将周边图像虚化","date":"2017-11-16T12:09:30.000Z","updated":"2017-11-16T12:09:45.494Z","comments":true,"path":"7.html","link":"","permalink":"http://kangsgo.com/7.html","excerpt":"","text":"FocalBlur是一个Pymol脚本可以创建非常cool的图像，将周边的的图像虚化，更加突出中心的object。虚化图片如下: 图片1 使用首先加载FocalBlur脚本:1run focal_blur.py 然后在pymol中进行使用:1FocalBlur aperture=2.0,samples=20,ray=1 如果是python脚本运用的话那么:1FocalBlur(aperture=2.0,samples=20,ray=1) 注意事项 当时使用镭射(raytracing)，图像创建的时间将会变得更长，具体的时间和采样n设置的大小有关 aperture为相机孔隙，值越大越模糊 示例 图片2 FocalBlur aperture=1,samples=100,ray=1 图片3 FocalBlur aperture=2,samples=100,ray=1 图片4 FocalBlur aperture=4,samples=400,ray=1 图片5 FocalBlur aperture=4,samples=400,ray=0 非常简单直观","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"使用python得到TCGA表格","slug":"使用python处理TCGA数据库","date":"2017-11-14T01:53:21.000Z","updated":"2017-11-14T02:17:38.013Z","comments":true,"path":"6.html","link":"","permalink":"http://kangsgo.com/6.html","excerpt":"","text":"我们需要提取下面的表格到本地，具体图片如下: 图片1 我们首先先点击表格右上角的JSON下载为JSON格式(假设保存的为data.json格式)，打开可以发现其数据与表格上的数据是有差别的，我们用如下代码进行处理:1234567891011121314151617181920212223#-*-coding:utf-8-*-# author:kangsgoimport jsonmodel=&#123;&#125;#解码jsonwith open('data.json','r',encoding='utf-8') as json_file: model=json.load(json_file)#写入到data.csv文件中f=open('data.csv','w')count=0for i in model: a=[] for j in i['consequence']: a.append(j['transcript']['aa_change']) a=list(set(a)) f.write(i['genomic_dna_change']+';'+i['ssm_id']+';'+i['mutation_subtype']+';' \\ +str(len(a))+'/567'+';'+str(len(i['consequence']))+'/10188') f.write('\\n') count += 1f.close() 将会得到data.csv的csv文件，可以用excel等工具进一步处理分析。","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"SMINA教程以CDPK1为例","slug":"SMINA教程以CDPK1为例","date":"2017-11-08T07:04:21.000Z","updated":"2017-11-12T06:29:44.946Z","comments":true,"path":"5.html","link":"","permalink":"http://kangsgo.com/5.html","excerpt":"","text":"SMINA教程以CDPK1为例 原作者:David Ryan Koes翻译:康文渊 若进行精读建议查看原文以及参考文献，本文是我根据教程快速阅读做的笔记 Q1:我们有autodock vina，为什么还要SMINA？ A1:SMINA有更加优秀的速度和更加的扩展性 Q2:用该对接软件有什么优势？ A2:首先该对接软件为免费/学术免费软件，其次其有非常良好的对接准确度，甚至在商业软件中都为上乘，同时可以很好的运用SMINA进行得分改造，进一步提升性能和速度 本教程是一个使用SMINA进行对E.tenella中的钙依赖性蛋白激酶1(calcium-dependent protein kinase 1 CDPK1)进行的结构为基础的虚拟筛选的教程。E.tenella是一种感染幼禽并且导致潜在致命球虫病的寄生虫。尽管这种酶并未解析晶体结构（译者翻译时该结构已经被解析，pdb:4YSJ），但是有相关寄生虫的该种酶的结构。C. parvum 和 T. gondii的该种酶结构已经被解析，并且有生物活性数据表明他们的小分子竭抗剂。我们将会对怎么分析已知结构，评价SMINA对于这些结构的表现，对于对接结果创建自定义的得分函数，使用SWISS-MODEL创建E.tenella的结构模型，并且进行E.tenellaCDPK1的虚拟筛选。（个人认为作者提到的E.tenella均表示的为E.tenellaCDPK1）。 假设和惯例假设读者对Linux命令行有一定的了解，并对一些用到的软件熟悉。教程在Ubuntu Linux12.04（原作者）和Ubuntu Linux16.04（译者）测试通过。bash命令行如下:1echo \"Hello\" python基础的PyMOL环境展示如下:12#python2.xprint \"Hello\" 以下为（译者）用到的软件:|–Software–|–License–|–Source–||—|—|—||color_by_mutation|GNU|http://www.pymolwiki.org/index.php/Color_By_Mutations||PyMOL 1.7.x|Python|http://sourceforge.net/projects/pymol/||RDKit 2017_03|BSD Style|http://rdkit.org/||smina|GPLv2|http://sourceforge.net/projects/smina/| 1. 检查C.parvum和T.gondii晶体结构该部分内容可以参考早期博客文章同源建模系列首先我们分析E.tenella序列和验证三个结构的异同（三个寄生虫中改结构）。然后我们使用C.parvum和T.gondii创建一个虚拟筛选的测试集，并且对接这些测试集化合物。我们使用这些对接结果来进行晶体结构的筛选和模型的增加。 1.1 靶标分析首先，我们分析E.tenella序列和C.parvum和T.gondii*结构 1.1.1 E.tenella序列分析1.复制或者下载E.tenella的FASTA序列,你可以点击这里进入网址,同样也可以下载我们已经下载好的。 2.进行BLAST搜索，若你为进入的网址，可以直接点击ncbi右侧的BLAST进行搜寻（如下图）。若为下载的文件可以进入BLAST页面上传fasta文件进行搜寻。 3.进入页面。 4.点击BLAST。 5.结果如图3,可以发现得分最高的为已经解析的结构，相似度为99%，但是我们在这里假装没有。排第二的为Neospora Caninum（4M97），但是更加相近的为T.gondii的几个结构（4M7N，3KU2,3I79,3HX4,3I7C），相似度大于80%。C.parvum的首次命中（3IGO）相似度为62%。 从中我们得出的结论为T.gondii的CDPK1相比于C.parvum具有更高的相似度。建议T.gondii结构选为同源建模的模板更为合理。 1.1.2 结构分析为了鉴定T.gondii和E.tenella之间CDPK1结合位点的差别，我们创建了一个E.tenella同源模型。并且使用color_by_mutation和PyMOL进行结构可视化序列的不同。1.在SWISS-MODEL进行自动建模，你也可以参考之前的教程 译者注：我认为该方法并不是建模的最佳方法，最佳方法为找到具有共同抑制剂的晶体结构进行基于配体的多模板建模，这样可以保证重要的活性腔的相似，而不是使用没有结合配体的晶体结构进行建模。 2.输入E.tenella的FASTA序列和3I79进行建模（图4） 3.下载结果文件，你可以在这里下载我已经建模好的。 4.在PyMOL中加载模型，3I79和3NCG 123load swissmodel.pdbfetch 3I79fetch 3NCG 译者注：在这里3NCG来的有点突然，搜索一下可以发现3NCG为C.parvum的激活状态下的晶体结构 5.比对结构 1alignto 6.从3NCG中提取BK1配体，并且隐藏该pdb的其余结构，因为3I79为非结合状态，我们使用这个配体来占有结合位点 12extract bk1,resn BK1hide (/3NCG/) 7.探索模型和3I79结合位点周围的残基，值得注意的是SWISS-MODEL忠实的复制了侧链构像。 8.着色两者之间的突变位点 12run color\\_by\\_mutation.pycolor\\_by\\_mutation swissmodel,3i79 9.探索结合位点，注意的是3I79中GLY128在E.tenella模型中被突变为THR 108，其余在结合位点是大体不变的。 10.重复分析3NCG，可以发现C.parvum在结合位点附近具有更多的突变 1.2 测试集的创建PubChem上有T.gondii和C.parvum的CDPK1诘抗击。我们使用这些数据作为虚拟筛选的测试集对这两个靶标进行筛选. 1.2.1组装活性化合物(a)在PubChem搜索CDPK1然后排序活性化合物,每个靶点选择三个最大的化合物数据集,为了保证和教程一致,我们选择的为和原教程相同的数据集. T.gondii aid:677062,600378,672956 C.parvum aid:600379,672955,66097 (b)选择active,然后点击Structures下载,之后选择没有压缩的SMILES格式,可以点此下载我们下载好的 (c)修正SMILES结构。下载的SMILES文件字符串和标题顺序相反。另外，我们需要去除salt，并将关键字“active”添加到所有活性化合物的标题中。我们每个文献执行如下命令（例如aid677062.txt为例）：1awk '&#123;print $2,$1\"_active\"&#125;' aid677062.txt | sed 's/\\.Cl//' &gt; aid677062.smi awk主要是进行了前后的颠倒，并且在标题后增加active标签，sed主要是将Cl进行替换，替换成空，中间用管道链接，输出到smi文件格式。 (d)将每个靶点的内容合并为单个文件 1cat aid*.smi &gt; activaes.msi T.gondii和C.pavum分别包含156个和89个活性化合物。你可以在这里下载合并好的文件。 1.2.2 创建诱饵数据集 该在线网站说只需要10min，实际上需要1-2天左右时间 由于这些靶点的无活性配体数量较少，我们使用诱饵数据库Database of Useful Decoys：Enhanced（DUDE）方法来从ZINC数据库中进行采样。这些诱饵被选择的方法为化学性质不相同（即和有活性的配体相比较不相似，认为是不结合的）。但分子质量，logP，旋转键和氢键受体供体这些简单的分子参数是相同的。 (a)使用DUDE网站创建诱饵数据集,将会生成dude-decoys.tar.gz文件，里面包含50个参数匹配的诱饵。 (b)将诱饵结合进入单个文件 1cat decoys/* | grep -v ligand &gt; decoys.msi 点此下载decoys文件，(T.gondii诱饵和活性化合物。C.pavum诱饵和活性化合物)。 1.2.3 生成三维结构 我们将使用开源软件RDKit利用2D SMILES生成3D构像 (a)将RDKit写入你的PYTHONPATH，并且执行rdconf.py脚本 12wget http://bits.csb.pitt.edu/tdtCDPK1/rdconf.pychmod + x rdconf.py (b)每个active/decoy生成单一构像 12rdconf.py --maxconfs 1 decoys.smi decoys.sdfrdconf.py --maxconfs 1 actives.smi actives.sdf (c)将文件合并 1cat actives.sdf decoys.sdf &gt; combined.sdf 由于有两个文件，我们将T.gondii和C.pavum分别命令为gondii.sdf和parvum.sdf 1.3 对接我们使用SMINA通过对接化合物进入受体结构进行虚拟筛选,采用AutoDock Vina得分功能。由于我们对一个固定的受体对接，所以我们选择一个好的受体结构是非常重要的。我们将会使用CDPK1的测试集来模拟评价我们的对接工具和选择受体结构。 1.鉴定PDB中所有C.parvum和T.gondii文件，搜索’calcium-dependent protein kinase 1’,并且选择恰当的生物（organism.） C. parvum: 2QG5 2WEI 3DFA 3F3Z 3HKO 3IGO 3L19 3LIJ 3MWU 3NCG T. gondii: 3I79 3I7B 3I7C 3KU2 3N51 3NYV 3SX9 3SXF 3T3U 3T3V 3UPX 3UPZ 3V51 3V5P 3V5T 4M84 由于教程较老，故和自己搜索有差异 2.下载这些pdb文件,你可以用如下的简单方法，或者直接下载我下载好的。 将以下代码保存为脚本，例如down.sh123456789#!/bin/bash str=\"2QG5 2WEI 3DFA 3F3Z 3HKO 3IGO 3L19 3LIJ 3MWU 3NCG\" arr=($&#123;str// / &#125;) for i in $&#123;arr[@]&#125; do wget https://files.rcsb.org/download/$i.pdb done 执行如下命令: 12chmod +x down.sh./down.sh 3.比对和提取结构。在pymol中打开靶标pdb文件。比对他们。除去水和原子。提取每个配体到自己的对象。 12345678910111213141516#pymol中执行from glob import globfor fil in glob(\"*.pdb\"): cmd.load(fil)aligntoremove solventremove metalremove GOL#选择配体BK1周围5埃外的小分子，并且删除，因为并未在结合位点内，不是配体select unligand,byres resname BK1 gap 5 and hetatmremove unligand#选择配体select ligand,hetatmextract parvum,ligand#保存配体save parvumlig.pdb,parvumremove ligand 4.保存受体和配体文件，注意的是3LI9没有酶结构域，3DFA和2QG5为未结合态结构，综合考虑我们将其删除。 1remove 3LI9 and 3DFA and 2QG5 保存(注意一下需要保存为python文件后run进行操作) 1for name in cmd.get_names():cmd.save(name + \".pdb\" , name ) 5.将配体导入进单一文件，由于我们之前做了，该步骤无需做 6.对接测试集化合物到每个受体结构，例如: 12smina --seed 0 --autobox_ligand parvumlig.pdb -r 2WEI.pdb \\-l combined.sdf -o 2WEI_docked.sdf.gz 在这里我们制定了一个随机种子。结合盒子采用autobox_ligand设置，创建的盒子大小为对于提供的配体8埃缓冲。配体，受体和输出文件可以使用任意OpenBabel支持的格式。 7.获取每个化合物输出得分最高的对接姿势。 12sdsorter -sort minimizedAffinity -reduceconfs 1 2WEI_docked.sdf.gz \\-print -c &gt; 2WEI_docked.txt 8.分析对接结果，原文是使用的R进行的分析，大家可以以下做参考，当然也可以依葫芦画瓢使用Python进行处理。 (a)R版本方法如下: 1234567891011121314151617install.packages(\"pROC\")library(\"pROC\")rarr=list()for (file in Sys.glob(\"*docked.txt\")) &#123; d = read.table(file,header=T) r = roc(grepl(\"active\",d $Title) , d$minimizedAffinity,direction=\"&gt;\") rarr[[length(rarr)+1]]=r&#125;names(rarr) = Sys.glob(\"*docked.txt\")for (n in names(rarr)) &#123; r = rarr[[n]] a = auc(r,partial.auc=c(1,.9),partial.auc.correct= T ) s = sprintf(\"%s %.4 f%.4f\\n\" , sub(\"_docked.txt\" ,\"\",n),r$auc[1],a[1]) cat(s)&#125; 图大致如下: 图6 AUC和Partial AUC的值分别为0.8520,0.6485。此数据运用的为官方数据，python版本为我自己写的方法，供参考 (b) ython版本如下: 首先我们使用awk处理一下原始文本 12awk 'BEGIN&#123;FS='_';OFS='\\t'&#125;&#123;print $1,$2&#125;' 2WEI_docked.txt rocdata.txt#打开文件，在Title后加type项 得到的文件可以从这里下载，python脚本如下： 12345678910111213141516171819202122232425262728293031#-*-coding:utf-8-*-#python=3.ximport pandas as pdfrom sklearn.metrics import roc_curve, roc_auc_scoreimport matplotlib.pyplot as plt# 读取数据df=pd.read_csv('rocdata.txt',sep='\\t')df.loc[lambda df: df.type=='active',['type']]='1'df.loc[lambda df: df.type=='unactive',['type']]='0'df['minimizedAffinity']=df['minimizedAffinity']/-10.76520y=df['type'].astype('int64')scores=df['minimizedAffinity']# ROCfpr,tpr,thresholds=roc_curve(y,scores,pos_label=1)#auc值auc=roc_auc_score(df['type'].astype('int64'),scores)#绘图plt.figure()plt.plot(fpr,tpr,color='darkorange',lw=2,label='pavum ROC curve,auc %0.2f' % auc)plt.xlim([0.0,1.0])plt.ylim([0.0,1.05])plt.plot([0,1],[0,1],color='navy',lw=2,linestyle='--')plt.xlabel('False Positive Rate')plt.ylabel('True Positive Rate')plt.title('2WEI ROC curve')plt.legend(loc=\"lower right\")plt.show() 图9 2. E.tenella CDPK1 模型和 测试集预测现在我们创建一个E.tenella模型来进行虚拟筛选和发展基于先前得分结果的用户自定义的得分功能。 2.1 建模基于之前章节的对接结果，T.gondii在全局和结合位点的序列中是更加接近E.tenella的.3T3U是T.gondii最优得分性能的一个结构（AUC和早期经验性AUC评价），因此我们使用SWISS-Model构建swissmodel3T3U.pdb 2.2 对接测试集这里有提供22个化合物和详细实验数据作为模型的测试集 1.转化为SMILES格式 12awk ' NR&gt;1&#123;print $2, $1&#125; ' tdt2-challenge3-cdpk1_externaltestset.txt \\&gt; testset.smi 2.生成构像 1rdconf.py --maxconfs 1 testset.smi testset.sdf 3.对接测试集 12smina --autobox_ligand allligs.pdb -r swissmodel3T3U.pdb \\ -l ../testset.sdf -o testset_docked.sdf --seed 0 4.选择和排序得分 12sdsorter -sort minimizedAffinity testset_docked.sdf -reduceconfs 1 \\testset_docked_best.sdf -print -c &gt; testset_default_ranking.txt 最佳得分构像如下图 图7 2.3 用户自定义得分我们发展了用户自定义得分功能用以T.gondii测试集参数化。增加到默认的得分功能上。 1.删除atom-types项目（如果考虑所有可能的原子类型组合，这将是一个非常大的项目），同样包括默认的第二Gaussian项目，他同样存在于默认得分之中。所有的权重均设为1.0 1234smina --print_terms | \\ grep -v -E 'atom_type|constant|num_|ligand_length' &gt; allterms echo \"gauss(o=3,_w=2,_c=8)\" &gt;&gt; allterms sed -i 's/^/1.0 /' allterms grep -v -E的用法比较少，-v表示不包含匹配文本的所有行，-E为启用正则表达式 2.得分最高的构像3T3U测试集拿来进行比较,由于我这里只做了2WEI，所以实际上此步我用的2WEI 12345678# 提取最高得分构像sdsorter -sort minimizedAffinity -reduceconfs 1 \\ 3T3U_docked.sdf.gz 3T3U_docked_single.sdf.gz# 重新打分，不用再继续跑smina --custom_soring allterms --score_only -l 3T3U_docked_single.sdf.gz -r 3T3U.pdb | \\ grep \"##\" | sed \"s/##//\" | \\ awk '&#123;print $1 ~ /_active/, $0&#125;' &gt; allscores 原文档中最后一行为/active/，但是个人觉得并没有达到区分active和unactive的用途，故本人对其进行了修改。可以从此下载文件。 3.作者使用R中的rms包和logistical回归来进行后向变量选择来契合活性数据的得分。为了防止过拟合，只选择p-值较低的功能（&lt;.0001）。 12345678910install.packages(\"rms\")library(rms)scores=read.table(\"allscores\",header=T)[c(-2)] #remove Name columcolnames(scores)[1]=\"activity\"formula=reformulate(name(scores)[c(-1)],respinse=\"activity\")fit=lrm(formula,data=scores,x=T,y=T)fit2=fastbw(fit,rule=\"p\",sls=0.0001)for(n in names(fit2$coefficients))&#123; cat(sprintf(\"%f %s\\n\",fit2$coefficients[[n]],n))&#125; 4.保存测定的系数coefficients以创建新的评分函数。因为项目名称中包含特征符，其在R中是无效命名，所以需要编辑输入以重新储存适当的terms，得分函数的结果如图下: 5.通过将系数乘以每一项的平均值来创建该评分函数中每个项的贡献的平均估计 1234aves=apply(scores[name(coef(fit2))[-1]],2,mean)*coef(fit2)[-1]for(n in names(aves))&#123; cat(sprintf(\"%f %s\\n\",aves[[n]],n))&#125; 结果如下图 疏水性，VDW，氢键和溶剂化为有利相互作用，非疏水性，排斥性和受体-受体为负相关作用。VDW和gauss具有非常强的权重，线性氢键和Lennard Jones氢键展示了一些权重。 4*.Python包实现，Python的scikit-learn中对于logistical并没有P-值，译者对与R也不是特别理解，不知道能否领会作者的含义，以下仅供参考。 我们采用scikit-learn包中的logistical回归，同时将数据为训练集（75%）与测试集，检测是否过拟合，若没有测试集效果也不错，就使用所有的作为训练集再次训练。 12345678910111213141516import pandas as pdfrom sklearn import linear_modelfrom sklearn.model_selection import train_test_split# 首先将文件的两个空格，替换为一个空格，或者sep 写成`空格+`df=pd.read_table('allscores',sep=' ')# 采用的为分层采样，以避免训练集和测试集不均匀的现象X_train,X_test,y_train,y_test=train_test_split(df.iloc[:,2:],df['type'],test_size=0.15,stratify=df['type'])# sklearn是机器学习库，而非统计库，所以去掉不相关的feature的话可以使用l1 regularization，默认的阈值为0.0001，相同regr=linear_model.LogisticRegression(penalty='l1')regr.fit(X_train,y_train)print('Coefficients:%s,intercept %s'%(regr.coef_,regr.intercept_))print('Score: %.2f' % regr.score(X_test,y_test)) 结果如下:1234Coefficients:[[-0.03864204 0.40028821 -0.00676393 -0.09159704 -0.0345586 -0.10145013 2.79993056 0.38033068 0. 0. -0.00837466 0. 0.04403177]],intercept [-3.04932666]Score: 0.82 译者计算出来和原作者计算出来有差异，主要就是hydrophobic和non_hydrophobic项两者的权重都为负数,项和值上也有差异。接下来我们乘上平均值得到最终权重。 1df.iloc[:,2:].mean()*regr.coef_[0] 结果如下:12345678910111213gauss(o=0,_w=0.5,_c=8) -2.447950repulsion(o=0,_c=8) 0.602891hydrophobic(g=0.5,_b=1.5,_c=8) -0.331807non_hydrophobic(g=0.5,_b=1.5,_c=8) -5.150272vdw(i=6,_j=12,_s=1,_^=100,_c=8) 20.386651non_dir_h_bond_lj(o=-0.7,_^=100,_c=8) 1.535267non_dir_anti_h_bond_quadratic(o=0,_c=8) 0.205500non_dir_h_bond(g=-0.7,_b=0,_c=8) 0.000000acceptor_acceptor_quadratic(o=0,_c=8) 0.000000donor_donor_quadratic(o=0,_c=8) 0.000000gauss(o=3,_w=2,_c=8) -13.474894electrostatic(i=2,_^=100,_c=8) 0.000000ad4_solvation(d-sigma=3.6,_s/q=0.01097,_c=8) 0.797093 6.评价这个新的得分函数，使用这个新的得分函数fitscore（个人觉得是第一次得出的权重进行的计算，因为我用第二次的权重进行计算数值很大，此处待考）除了重新打分最高的对接姿势以外，我们重新打分和重新排序所有的对接姿势。值得注意的是这个得分函数是预测的活性而不是亲和力。越大的positive值表示的是复合物可能具有活性的概率更大，所以复合物在选择最佳构像排序的时候需要逆转数字顺序。 12345678910smina --score_only -r 3T3U.pdb -l 3T3U_docked_single.sdf.gz \\ --custom_scoring fitscore -o 3T3U_docked_single_rescore.sdf.gzsdsorter -print -c 3T3U_docked_single_rescore.sdf.gz &gt; 3T3U_docked_single_rescore.txtsmina --score_only -r 3T3U.pdb -l 3T3U_docked.sdf.gz \\ --custom_scoring fitscore -o 3T3U_dcoked_rescore.sdf.gzsdsorter -reversesort minimizedAffinity -reduceconfs 1 -print -c \\ 3T3U_docked_rescore.sdf.gz &gt;3T3U_docked_rescore.txt 译者在做的时候对第6条不是很理解 7.使用新的得分函数对接E.tenella化合物集: 12345smina --custom_scoring fitscore --score_only -l testset_docked.sdf \\ -r swissmodel3T3U.pdb -o testset_rescored.sdfsdsorter -print -c testset_rescored.sdf -reversesort minimizedAffinity \\ -reduceconfs 1 testset_rescored_best.sdf \\ &gt; testset_custom_ranking.txt 应该使用在这个测试集上表现更好的评分函数来进行完整的虚拟筛选选择化合物，结果可以从此下载 译者认为自定义得分并未达到非常好的效果，可以进一步优化 3.虚拟筛选 已经阐明精心设计的自定义得分可以很好的应用在E.tenella结构模型，我们进行筛选eMolecules化合物库。需要注意的是我们的自定义得分函数并不使用于对接，而是参数化预测已经对接好的姿势的活性。 1.下载eMolecules数据库 12wget http://downloads.emolecules.com/ordersc/2017-11-01/parent.smi.gzgunzip parent.smi.gz 2.根据环境切割不同大小。例如，10000每块进行切割 12split -n 1/10000 parent.smi -d -a 4 split_for i in split*; do mv $i $&#123;i&#125;.smi; done 3.生成构像 1rdconf.py --maxconfs 1 split_0000.smi split_0000.sdf.gz 4.对接每个块 12smina --autobox_ligand allligs.pdb -r swissmodel3T3U.pdb \\ -l split_0000.sdf.gz -o docked_0000.sdf.gz --seed 0 5.对获得的最高排名姿势使用默认的得分和自定义得分进行评价 1234sdsorter -sort minimizedAffinity -reduceconfs 1 -nbest 100 \\ docked_0000.sdf.gz best_default_0000.sdf.gzsmina --custom_scoring fitscore --score_only -l docked_0000.sdf.gz \\ -r swissmodel3T3U.pdb -o rescored_0000.sdf.gz 6.将对接姿势放入一个文件并排序 12345678zcat bets_default_*.sdf.gz | gzip &gt; best_default.sdf.gzzcat best_custom_*.sdf.gz | gzip &gt; best_custom.sdf.gzsdsorter -sort- minimizedAffinity best_default.sdf.gz \\ -nbest 1000 top1000_default.sdf.gz -print -c \\ &gt; top1000_default.txtsdsorter -reversesort minimizedAffinity best_custom.sdf.gz \\ -nbest 1000 top1000_custom.sdf.gz -print -c \\ &gt; top1000_custom.txt 参考文献:Ojo KK, Larson ET, Keyloun KR, Castaneda LJ, Derocher AE, Inampudi KK, Kim JE, Arakaki TL, Murphy RC, Zhang L, Napuli AJ, Maly DJ, Verlinde CL, Buckner FS, Parsons M, Hol WG, Merritt EA, Van Voorhis WC. (2010) Toxoplasma gondii calcium-dependent protein kinase 1 is a target for selective kinase inhibitors. Nat Struct Mol Biol. 17:602-7. PMID: 20436472 PMCID: PMC2896873 Murphy RC, Ojo KK, Larson ET, Castellanos-Gonzalez A, Perera BG, Keyloun KR, Kim JE, Bhandari JG, Muller NR, Verlinde CL, White AC, Merritt EA, Van Voorhis WC, Maly DJ. (2010) Discovery of Potent and Selective Inhibitors of Calcium-Dependent Protein Kinase 1 (CDPK1) from C. parvum and T. gondii. (2010) ACS Med Chem Lett. 1(7):331-335. PMID: 21116453 PMCID: PMC2992447 Johnson SM, Murphy RC, Geiger JA, Derocher A, Zhang Z, Ojo K, Larson E, Perera BG, Dale E, He P, Fox A, Mueller N, Merritt EA, Fan E, Reid M, Parsons M, Van Voorhis WC, Maly DJ. (2012) Development of Toxoplasma gondii Calcium-Dependent Protein Kinase 1 (TgCDPK1) Inhibitors with Potent Anti-Toxoplasma Activity. J Med Chem. 55(5):2416-26. PMID: 22320388 PMCID: PMC3306180 Larson ET, Ojo KK, Murphy RC, Johnson SM, Zhang Z, Kim JE, Leibly DJ, Fox AM, Reid MC, Dale EJ, Perera BG, Kim J, Hewitt SN, Hol WG, Verlinde CL, Fan E, Van Voorhis WC, Maly DJ, Merritt EA. (2012) Multiple Determinants for Selective Inhibition of Apicomplexan Calcium-Dependent Protein Kinase CDPK1. J Med Chem. 55(6):2803-10. PMID: 22369268 PMCID: PMC3336864 Ojo KK, Pfander C, Mueller NR, Burstroem C, Larson ET, Bryan CM, Fox AMW, Reid MC, Johnson SM, Murphy RC, Kennedy M, Henning Mann H, Leibly DJ, Hewitt SN, Verlinde CLMJ. Kappe S, Merritt EA, Maly DJ, Billker O, Van Voorhis WC. (2012) Transmission of malaria to mosquitoes blocked by bumped kinase inhibitors. J. Clin. Invest. 122(6):2301–2305. doi: 10.1172/JCI61822 PMID:22565309 PMCID: PMC3366411 Zhang Z, Ojo KK, Johnson SM, Larson ET, He P, Geiger JA, Castellanos-Gonzalez A, White AC Jr, Parsons M, Merritt EA, Maly DJ, Verlinde CL, Van Voorhis WC, Fan E. (2012) Benzoylbenzimidazole-based selective inhibitors targeting Cryptosporidium parvum and Toxoplasma gondii calcium-dependent protein kinase-1. Bioorg Med Chem Lett. 22:5264-7. PMID: 22795629 PMCID: PMC3420979 Castellanos-Gonzalez A, A. White AC Jr, Ojo KK, Vidadala R, Zhang Z, Reid MC, Fox AMW, Keyloun KR, Rivas K, Irani A, Dann SM, Fan E, Maly DJ, Wesley C Van Voorhis. (2013). A novel Calcium Dependent Protein Kinase Inhibitor as a lead compound for treating Cryptosporidiosis. J Infect. Dis. PMID: 23878324 2013 Jul 21. [Epub ahead of print] Ojo KK, Eastman RT, Vidadala R, Zhang Z, Rivas KL, Choi R, Lutz JD, Reid MC, Fox AMW, Hulverson MA, Kennedy M, Isoherranen N, Kim LM, Comess KM, Kempf DJ, Verlinde CLMJ, Su X-Z, Kappe S, Maly DJ, Fan E, &amp; Van Voorhis WC. (2013) Specific inhibitor of PfCDPK4 blocks malaria transmission: Chemical-genetic validation. J Infect Dis. 2013 Oct 10. [Epub ahead of print] PMID: 24123773","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"dock","slug":"dock","permalink":"http://kangsgo.com/tags/dock/"}]},{"title":"Anaconda虚拟环境的构建与包管理","slug":"Anaconda虚拟环境的构建与包管理","date":"2017-11-05T14:56:01.000Z","updated":"2017-11-05T14:50:17.139Z","comments":true,"path":"4.html","link":"","permalink":"http://kangsgo.com/4.html","excerpt":"","text":"做生物信息，个人感觉R与python都挺重要的，个人更加喜欢python，因为其除了R的功能以外还可以做很多事情，可以成为一个全技jian工程师，当然公认的python的画图还是没有R强大。做python的科学计算，不得不提到大名鼎鼎的跨平台管理工具conda了，其有许多优势，再也不要看pip缺少什么依赖环境了，同时可以在任意版本的python中进行切换以及构建环境，非常好用。 管理环境对于conda，你可以创建，输出，列出，移出和升级环境，可以切换你的不同版本的包环境。假如希望看到所有的命令文档，你可以使用--help进行查看，例如，了解conda环境命令:1conda env --help 简单的参数文档可以在commnand reference documentation进行查阅。 创建环境为了管理环境，我们需要创建至少两个环境来进行移动切换他们，为了创建新的环境，使用conda create命令，如下：1conda create --name snowflakes biopython 其将会创建一个名为/envs/snowflakes的新环境，包括biopython项目，这个环境使用的python版本为现在所使用的版本，因为你没有特别的指定版本。 改变环境（activate/deactivate）激活Linux,OS X： source activate snowflakesWindows： activate snowflakesconda 添加path名（snowflakes）在你的系统命令中TIP：环境默认安装在conda目录，你也可以特别的指定其它目录，具体查看create --help来获取更多描述 失活Linux, OS X: source deactivateWindows: deactivateconda将移出路径（snowflakes）于你的系统命令 创建独立的环境你可以创建新的环境采用不同的python版本，安装不同的包等等，例如:1conda create --name bunnies python=3 astroid babel 列出所有的环境可以通过info信息来列出所有环境内容:1conda info --envs 你可以列出所有的环境参数:123conda environments:snowflakes /home/username/miniconda/envs/snowflakesbunnies /home/username/miniconda/envs/bunnies 验证当前环境1conda info --envs conda 将列出所有环境，当前环境会高亮且带有’*’的特征符 克隆环境1conda create --name flowers --clone snowflakes 删除环境1conda remove --name flowers --all 设置国内镜像123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 设置了清华大学镜像源，速度肯定嗖嗖的。 但是清华大学的镜像包还是不够给力，我们可以增加bioconda隧道，这样就不用在官网龟速安装了~12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/conda config --set show_channel_urls yes 执行完上述命令后，会生成~/.condarc(Linux/Mac)或C:\\Users\\USER_NAME\\.condarc文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。 参考资料:Conda-Anaconda的虚拟环境和包管理功能Anaconda使用总结 简单例子创建一个python2.7环境 激活环境并下载wxpython12activate wxpythonpip install expython","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[{"name":"anconda","slug":"anconda","permalink":"http://kangsgo.com/tags/anconda/"}]},{"title":"smina安装与简介","slug":"smina安装与简介","date":"2017-11-02T15:36:39.000Z","updated":"2017-11-02T15:38:05.329Z","comments":true,"path":"3.html","link":"","permalink":"http://kangsgo.com/3.html","excerpt":"","text":"概要smina 是基于Autodock Vina的软件，主要聚焦于提升算法和最小化。主要的改变包括: 通过OpenBabel提供能多的配体分子格式 支持多配体文件 增加术语类型（例如:去溶剂化能，静电势能） 支持用户自定义得分参数和得分功能 基于特异的结合配体自动计算盒子 允许输出超过20个对接姿势 提升了最小化算法 *如果配体不是pdbqt格式，那么在文件中需要局部电荷。完成这项工作在OpenBabel和AutoDock Tools中的prepare_ligand4.py脚本中会有不同的结果。 静态编译文件提供了openbabel和boost（1.5.4），但是要求内核高于2.6.24 Ubuntu下安装首先在网站上下载smina.static文件。1sudo cp smina.static /usr/local/bin/smina 然后可以输入smina --help查看预编译版本是否可用 输入文件简介输入:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# arg表示该参数后面需要加参数 -r [--receptor] arg刚性受体（PDBQT） --flex arg 柔性侧链（PDBQT） -l [--ligand] arg 配体（s） --flexres arg 特别的柔性侧链，通过逗号分隔 chain:resid --flexdist_ligand arg 用于flexdist的配体 --flexdist arg 该参数表示flexdist配体多少距离以内设为柔性配体 搜寻空间 (required): --center_x arg X中心坐标 --center_y arg Y中心坐标 --center_z arg Z中心坐标 --size_x arg X尺寸大小 (Angstroms) --size_y arg Y尺寸大小 (Angstroms) --size_z arg Z尺寸大小 (Angstroms) --autobox_ligand arg 自动创建盒子的配体 --autobox_add arg 若为自动创建盒子，那么缓冲空间的数量，默认为+4 --no_lig 无配体;对于取样/最小化柔性残基评分和最小化设置: --custom_scoring arg 自定义得分文件 --score_only 配体姿势得分 --local_only 使用盒子进行局部搜索 (可能需要附带使用 --minimize) --minimize 能量最小化 --randomize_only 生成随机姿势，避免空间位阻 --minimize_iters arg (=0) 最陡下降法迭代数量，默认值是无法收敛的，我用的ahr为5000，可以用gmx等软件查看收敛系数 --accurate_line 使用精确的线性搜索 --minimize_early_term S最小化搜索的终止能量 --approximation arg 使用的近似 (linear, spline, or exact) --factor arg 近似因子: finer-grained效果较好 --force_cap arg 最大允许力，低值对于最小化clashing结构更好 --user_grid arg 用户计算若需要用到的格点文件Autodock map 文件 --user_grid_lambda arg (=-1) 缩放user_grid和功能得分 --print_terms 打印所有项目和默认值 --print_atom_types 打印所有可用原子类型输出设置 (optional): -o [ --out ] arg 输出文件，格式根据后缀来 --out_flex arg 对于柔性残基的输出文件 --log arg 可设置的log文件 --atom_terms arg 可设置的输出每个残基的联系值 --atom_term_data 封装每个残基的联系值进入sd数据Misc (optional): --cpu arg 使用的cpu数量，默认全使用 --seed arg 随机种子 --exhaustiveness arg (=8) 用尽一切的全局搜索 --num_modes arg (=9) 最大结合模式生成数量 --energy_range arg (=3) 最好和最低结合之间的数值设置(kcal/mol) --min_rmsd_filter arg (=1) rmsd阈值 -q [ --quiet ] 禁止输出消息 --addH arg 自动加氢（默认是执行的） --flex_hydrogens 开启氢键转角设置文件 (optional): --config arg 以上的设置可以放入这个文件信息 (optional): --help 展示帮助 --help_hidden 展示包含隐藏设置的帮助 --version 版本 具体的分子对接待编辑未完待续","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Dock","slug":"Dock","permalink":"http://kangsgo.com/tags/Dock/"},{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"}]},{"title":"chimera制作旋转动画","slug":"制作旋转动画","date":"2017-10-29T04:42:20.000Z","updated":"2017-10-29T04:45:51.442Z","comments":true,"path":"834.html","link":"","permalink":"http://kangsgo.com/834.html","excerpt":"","text":"示例如下： 12345678910111213141516171819202122232425Open 2GHA.pdb.Delete chain B. Select / Chain / B and Actions / Atoms / DeleteColor ribbon. Presets / Interactive 1 (ribbons)Highlight ligand. Select / Structure / Ligand and Actions / Atoms / SphereClear selection. Select / Clear SelectionRotate 360 degrees. Favorites / Command Line turn y 1 360Record “spin” movie. movie record ; turn y 1 360 ; wait ; movie encodeSemicolons separate commands on one line.movie record starts capturing images.wait prevents going to the next command until motion finishes.movie encode writes the images to a movie file. 如果是windows一般保存在桌面上","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"chimera","slug":"chimera","permalink":"http://kangsgo.com/tags/chimera/"}]},{"title":"shell脚本读取PDB文件中的长宽高","slug":"shell脚本读取PDB文件中的长宽高","date":"2017-10-29T04:41:15.000Z","updated":"2017-10-29T04:42:05.851Z","comments":true,"path":"840.html","link":"","permalink":"http://kangsgo.com/840.html","excerpt":"","text":"123456789#!/bin/sh#作者：GROMACS中文组群: 广药-阿福#x轴grep ^ATOM $1 | awk ‘&#123;print $7&#125;’| sort -n |sed -n ‘1p;$p’#y轴grep ^ATOM $1 | awk ‘&#123;print $8&#125;’| sort -n |sed -n ‘1p;$p’#z轴grep ^ATOM $1 | awk ‘&#123;print $9&#125;’| sort -n |sed -n ‘1p;$p’","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"Dock6安装教程","slug":"Dock6安装教程","date":"2017-10-29T04:36:39.000Z","updated":"2017-10-29T04:40:52.806Z","comments":true,"path":"844.html","link":"","permalink":"http://kangsgo.com/844.html","excerpt":"","text":"好久没有使用Dock了，不知不觉中已经更新到了6.8。首先需要在官网填写资料下载:http://dock.compbio.ucsf.edu/DOCK_6/index.htm 每个邮箱可以登陆5次，不过用完了可以新用一个邮箱，申请过的邮箱不能再次申请，需要发邮件或者重新使用一个邮箱。 dock 安装方法也非常简单，如下: 1.安装依赖环境1234sudo apt-get install c++sudo apt-get install g++sudo apt-get install gfortransudo apt-get install cmake 2.解压文件进入目录12tar -zxvf dock.6.8.tar.gzcd dock6/install 3.设置Configure文件1./configure [configuration file] [configuration file]完整的可以看官方教程http://dock.compbio.ucsf.edu/DOCK_6/dock6_manual.htm#Installation 这里介绍几个常用的:gnu : GNU编译（需要CUDA？）gnu.parallel :GNU和多线程编译intel :Intel编译intel.parallel :Intel多线程编译 我选择的是gnu版本，即 1./configure gnu 4.安装1make all 5.测试123cd testmake testmake check 如果安装了maber的话，由于$AMBERHOME被占用，会导致ambersize测试失败。大致提示如下: 123456789101112131415161718192021&gt; make[2]: Leaving directory &apos;/home/rdx12/Downloads/dock6/dock6&gt; Apr/install/test/zou_gbsa_score&apos;&gt; &gt; cd amber_score_181l &amp;&amp; make test&gt; &gt; make[2]: Entering directory &apos;/home/rdx12/Downloads/dock6/dock6&gt; Apr/install/test/amber_score_181l&apos;&gt; &gt; ../../../bin/prepare_amber.pl lig.mol2 181l.pdb&gt; &gt; Error from amberize_receptor; examine amberize_receptor.out&gt; &gt; ../default_targets.h:18: recipe for target &apos;amberize&apos; failed&gt; &gt; make[2]: *** [amberize] Error 25&gt; &gt; make[2]: Leaving directory &apos;/home/rdx12/Downloads/dock6/dock6&gt; Apr/install/test/amber_score_181l&apos;&gt; &gt; Makefile:43: recipe for target &apos;amberdock&apos; failed&gt; make[1]: *** [amberdock] Error 2 你需要解掉变量 12unset AMBERHOME #(bash)unsetenv AMBERHOME #(tcsh) 6.设置环境变量常规的设置环境变量如下: 123456gedit ~/.bashrc #打开.bashrc #DOCK6.8 export PATH=$PATH:/home/kangsgo/install/dock6/bin source ~/.bashrc #source立即生效 查看可以发现dock6.8自带了antechamber等一些amber里也有的东西,不知道会不会产生问题，我仅仅设置了一个DOCK目录 123456gedit ~/.bashrc #打开.bashrc #DOCK6.8 DOCKHOME=/home/kangsgo/install/dock6/bin source ~/.bashrc #source立即生效 这样每次输入的时候都是用的$DOCKHOME加命令","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Dock","slug":"Dock","permalink":"http://kangsgo.com/tags/Dock/"},{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"}]},{"title":"Martini 2.2P力场笔记","slug":"MARTINI2","date":"2017-10-10T03:02:14.000Z","updated":"2017-10-28T04:00:38.002Z","comments":true,"path":"811.html","link":"","permalink":"http://kangsgo.com/811.html","excerpt":"","text":"&nbsp; 阅读前请注意: 1.此文仅是我看Martini文献的一些总结，若需要使用Martini力场建议仔细的查看官网信息和相关文献。此文花费较大精力，若有什么意见或者建议欢迎发邮箱交流。邮箱为kangsgo@vip.qq.com 湖大-小康 2.由于我只关注蛋白模拟，故只查阅了Martini力场2.2的文献以及蛋白参数文献 3.此笔记对于Martini性能评测部分只关注了部分内容Martini力场自问世以来就受到了很多人的喜爱，特别是蛋白的力场，最近（2013年）Martini力场在许多方面都有应用。包括如下:1.蛋白调节囊泡的融合.2.膜结构域的形成.3.磷脂的翻转（flip-flopping）.4.磷脂和表面行为（？lipid and surfactant phase behavior）5.单磷脂层的折叠.6.膜束缚（?tether）的形成.7.肽和蛋白介导的膜的重构.7.膜蛋白的自组装和磷脂的分类.8.膜蛋白的门控和构象的变化.9.固体上蛋白的吸附作用.10.蛋白纤维的机制研究.10.蛋白的聚集.11.肽的两亲性12.淀粉纤维研究.13.纳米孔吸附和表面湿度.14.纳米孔的跨膜转运和磷脂吸附.15.膜工程.16.多聚物介导的膜黏附和束缚(?tether).17.nanocoating of a polymer matrix.17.蛋白配体的结合.18.脂蛋白颗粒和纳米圆盘的结构和动力学研究.19.药物传递体系等等。 Martini 2.2和Martini 2.0相比较，做了如下内容的提升: 对蛋白力场进行了修复，包括： (i)新的脯氨酸，苯丙氨酸和色氨酸侧链拓扑，以改善分区自由能(?partitioning free energies) (ii)引入偏心电荷模型，以更实际地描述相反电荷的残基之间的联系。 以上两条简而言之就是对之前的电荷模型进行很大的优化 (iii)对于极性侧链参数化极性珠子以提升在非极性环境中的二聚化和表明的结合(iv)调整键的项目来提升α螺旋的长度和增加多聚丙氨酸和谷氨酸的稳定性。 新版本力场命名为Martini 2.2（若为极性水模型，则为2.2P） Martini 2.2的评价使用了如下的参考评价内容:伞状采样（PS:文献中纳入为分区自由能中）:对氨基酸残基侧链类似物（SCAs）进行了跨膜（DOPC膜）伞状采样，方法如同Martini 2.0文献中 分区自由能(Partitioning Free Energy):SCAs在水和油（癸烷,decane）中的分区自由能使用热力学整合的方法计算。具体的为自由能和相应误差使用GROMACS的g_bar（gmx5以上对应的为 gmx bar）分析工具。分区自由能ΔGpart 为水中的自由能减去油中的自由能。 二聚化自由能（Dimerization Free Energy）:也是进行一个另外一种伞状采样（大致为两个SCAs，拉动其中一个SCAs运动）。后经过如下公式计算ΔGdim: 其中kB为波尔兹曼（Boltzmann）约束，T为模拟温度，r为SCAs’ COM距离，rc 是二聚物-单体之间的cutoff（PMF达到第一个最大值的距离），Rmax是考虑的最大距离， v⌀为标准体积(1.66nm3，等于1mol L-1)，g(r)为径向分布函数（?回转半径？），其通过PMF可以如下计算: WW肽结合力（Binding of WW Peptides）:WW表示的为Wimlery-White，是一个五肽，序列为Ac-WLXLL，其中X为可变残基。ΔGWW获得主要是通过free energy perturbation（FEP）和multiple Bennett acceptance ratio（MBAR）相互联系的方法，计算公式为: zs=1.0nm,zf=4.0nm，其定义分别为POCC/water限制和bulk water限制。数值使用的Simpson’s 规则计算。相关的X残基ΔΔGWW(X)的计算为ΔGWW(X)减去ΔGWW(Ala) 优化方法和实验结果:1.改变Phe,Trp和Pro的颗粒类型作者第一个方法为通过改变Phe,Trp和Pro的颗粒类型，能够解决Martini 2.1力场中这三个原子类型疏水性太强的弱点，如下表: 其中ref为全原子模拟的结果，通过上表可以发现通过改变颗粒的类型可以使得结果有一定的提升。同时也不会影响伞状采样的结果，对于部分伞状采样的评价相比有更好的结果产生。如下图: 2.改变电荷偏移中心来改善电荷残基作者通过改变电荷偏移中心来改善电荷残基，在Martini 2.1和Martini 2.1P进行同电荷和异电荷残基的PMF实验时，结果如下图: 可以发现，在Martini 2.1种，对于带相反电荷的残基仅仅捕捉到微弱的联系，然而，全原子力场表现出非常强的联系。相反，对于相同电荷残基，Martini 2.1预测了稳定的联系，而全原子模型则相反。当使用极性水模型以后（Martini 2.1P）,库伦联系下降为1/r,同时因为CG珠子拥有更大的大小（定义的范德华力为~0.26nm）限制了其接近电荷珠子到~0.5nm。然而全原子模型可以更加的接近。 为了弥补这个问题，作者为带电侧链设计了一个替代模型，其中静电和范德华相互作用由两个不同的粒子承载。如下图: 两个颗粒通过一个共约束的0.11nm长的键相互联系。使用这个偏移中心的设置，在Lys-Glu联系对的情况下，电荷可能更接近，并且相互作用增加约3倍（如图2）。但Lys-Lys联系对没有得到改善。 对于其它珠子是否有改善还有待检验。 同时作者还做了以下优化，由于自己用不到，仅在这里做简单介绍: 提升非极性残基使用非极性颗粒 提升骨架α螺旋和Ala和Gly多聚物序列的稳定性 3. 在溶解肽中测试新的参数作者进行了一条16肽的模拟（GCN4亮氨酸拉链，PDB code:2ZTA）,8号位（Lys）和12号位（Leu）残基突变为非极性的Asn，突变后的肽总共包含5个非极性氨基酸残基(Gln4, Asn8, Asn12, Ser14, Asn16)和6个电荷残基(Lys3, Glu6, Asp7, Glu9, Glu10 and Lys14),统计COM距离结果如下图: 对于非极性氨基酸残基，Martini 2.1P和Martini 2.2P之间有两个方面不同，第一点，峰在短的距离（侧链指向彼此）和长的距离（侧链远离彼此），在Martini 2.2P中转变为一个更小的平均距离，这和全原子模拟更加匹配。第二点为分布更窄（Asn12−Ser14 and Ser14−Asn16）。对于带有相反电荷残基的Lys3-Glu6和Glu11-Lys15联系对，当使用Martini 2.2P时，在短距离处观察到的峰值变得更宽或完全消失。 对于带有相反（Glu6-Asp7）和相等电荷（Glu10-Glu11）direct neighbors，用新参数对相同的方向进行采样。 对于带有相反电荷的Asp7-Glu10残基对，新方向更近的距离被采样到，从而更好地再现了全原子模拟的分布。 虽然这种特定肽的侧链的整体行为似乎已经随着我们的新模型而改善，但是也很清楚，我们的CG模型不能捕获使用原子模型时所看到的分布的一些细节。需要做更多的测试。 文章最后还提到了考虑以后二级结构可以发生转变 参考文献: de Jong D H, Singh G, Bennett W F D, et al. Improved parameters for the martini coarse-grained protein force field[J]. Journal of Chemical Theory and Computation, 2012, 9(1): 687-697.","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"},{"name":"粗粒化","slug":"粗粒化","permalink":"http://kangsgo.com/tags/粗粒化/"}]},{"title":"MARTINI 2.0力场笔记","slug":"MARTINI1","date":"2017-09-30T10:29:37.000Z","updated":"2017-10-28T03:59:18.782Z","comments":true,"path":"770.html","link":"","permalink":"http://kangsgo.com/770.html","excerpt":"","text":"阅读前请注意: 1.此文仅是我看Martini文献的一些总结，若需要使用Martini力场建议仔细的查看官网信息和相关文献。此文花费较大精力，若有什么意见或者建议欢迎发邮箱交流。邮箱为kangsgo@vip.qq.com 湖大-小康 2.由于我只关注蛋白模拟，故只查阅了Martini力场2.0的文献以及蛋白参数文献 3.此笔记并未包含Martini力场性能测评部分，可能后续会加上粗粒化（CG ）模拟在各种各样的模拟化技术中提供与全原子模型（AA model）相比更广的空间和时间尺度研究。在粗粒化模拟研究的早期一般运用在蒙特卡洛模拟上，这是一种基于概率的模拟算法，与经典模拟在理论上还是有大的差别，早期的CG模型其缺点是需要每次模拟前都进行参数的设置矫正，而Martini力场开发的初衷是更为提供一种能够进行普适应用的操作简单的力场。 Martini的力场开发目的主要是应用于囊泡的形成，薄层相的转移，结构和膜的自组装等等，其比较关注于极性与非极性之间的相互转换/作用。Martini力场相比之前的力场模拟（2007年以前）有更多的能量”等级”和类型，与实验参数也拟合的更好，同时提供了环类物质的CG 模型的方法。 力场概述（2.0版本）：联系位点：Maritini力场与其他CG力场一样，均为4个heavy原子用一个单一珠子所联系。珠子主要有四种主要类型。polar（P），nonpolar（N），apolar（C）和charged（Q）。同时有18种亚型，比如按照成氢键能力用单字母分为（d=donor，a=acceptor，da=both，0=none）或者指示极性（1，最低极性，5，最高极性） 蛋白的原子类型: 蛋白残基中侧链表示:非极性残基Leu，Pro，Ile，Val，Cys和Met用C-类型颗粒表示。非极性残基Thr，Ser，Asn和Gln通过P-类型颗粒表示，氨基酸残基带有小的负电荷侧链Glu和Asp残基用Q-类型颗粒表示。正电荷氨基酸残基Arg和Lys采用带电荷的Q类型和不带电荷颗粒组成。带环芳香烃残基通过三（His，Phe和Tyr）或者四（Trp）个珠子来表示特别的环颗粒。Gly和Ala残基仅仅设置骨架颗粒。骨架参数依赖二级结构，如下图: 在溶液中或者无规卷曲或者弯曲中，骨架拥有非常强的极性特征（P类型），在部分螺旋或者β折叠中，内部骨架键减少了极性特征的放大（N类型）。辅氨酸是低极性的因为其缺乏氢键供体能力。其全原子映射结果如下表: 非键联系：首先是Lennard-Jones(LJ)12-6势，公式如下: 其中r为原子对距离，ε(字母代考)与σ为势能参数，因原子的种类而异，具体可以查看陈正隆老师的分子模拟一书。在martini力场中统一为σ=0.47nm，除了两个特别的类rings和antifreeze以外,还有一个例外就是Q类型和大多数极性类型 ，其C1和C2 斥力σ范围扩展为0.62nm。这个变化利于带电粒子在非极性介质中利于生成水化层。完整的参数数据如下表： 除了LJ势能以外，电荷组（类型Q）还有完整的qi,j联系，通过库能势： 库能势与之前的比较准确性略有降低，主要是为了和之前的模型相比平衡增加的疏水强度。εr(字母代考)相对介电常数为15，与之前相比略微降低。 键联系：键的描述和上一个版本相比没有升级，主要还是微弱的简谐振动提供的。此项在陈正隆老师的书籍版本中译为键伸缩势能项。平均键长与σ相同，为0.47nm，约束力为Kbond=1250Kj*mol-1，公式如下: 键角的简谐震荡项，参数依据为与全原子模型相互比较,计算公式如下：[ 一般情况下Kangle=25KJmol-1，θ0=180°，在涉及cis double bond时，参数为Kangle=45KJmol-1（之前参数为35KJmol-1），θ0=120°，因为和全原子相比联系过于微弱。 蛋白的键联系: 蛋白的键长，键角，二面角和他们各自的力场约束统计起来作为键参数的参考。这些参数来源于PDB库中近2000个蛋白作为数据集。蛋白的二级结构来源于DSSP项目。计算的键长，键角和二面角如下图: PDB数据库中的参数分布如下图: 环化物参数:对于环化物，4个原子称为1个珠子是不怎么适用的，最佳为2个或者3个位1个珠子，具体可以查看文章中给的环己烷，苯环等的例子。由于会照成很大CG珠子密度，因此这些参数需要差别对待。特别的设置标签为“S”,其LJ势能的σ也是不同的，σ=0.43nm,ε(字母代考)缩小至75%。环的话分子内的LJ不适合该体系，而更换improper dihedral angle势来合理的解释。其公式如下: θ的角度由i,j,k和j,k,l构成，θid则为平均角度，力场约束为Kid。 二面角（dihedral angle）参数(蛋白):对于氨基酸残基还有两个二面角势,其中improper 二面角势 Vid主要被用来阻止平面组的面外扭曲。Proper二面势Vd被使用来约束肽骨架的二级结构。这是一个非常重要的点，因此，若有蛋白序列二级结构的改变是不适合这个模型的（分别为公式5,6），公式如下: 二面角参数仅仅在四个联系的珠子拥有相同的二级结构（螺旋或者延长(extended)），下表统计了所有侧链的键长和联系约束。 键角统计如下表: 抗凝剂参数:由于水模型是P4颗粒，相对于真实的水更容易freezing，故需要Antifreez参数。CG 水在280到300K可能会freezes。freezing是一个核驱动的过程，一般CG水能够保留其流动性(fluid)非常长的时间，但是一旦成核形成，将会很快速的形成，在固态表面甚至膜表面可能都会加速水的freeze。若研究更低温度同样如此，故需要增加水的无序程度。引入抗凝剂BigP4，LJ参数从0.47nm改为0.57nm，为了避免相的分离，BP4-P4联系上升为等级“O”。其他按照正常颗粒。当加入抗凝剂以后会对液体平衡性产生一定的影响,但作者对膜水体系进行分析，发现在膜表面积，形成gel phase的转移温度，膜分子的横向扩散长度都没有很大的影响，故认为为可接受范围之内。 模拟参数:对于模拟参数，非键联系的cut off距离设置为rcut=1.2nm。为了避免产生不必要的噪音，使用GROMACS 的标准偏移功能，其中能量和约束力设置在截止距离处消失。LJ势能的偏移从rshift=0.9nm到rcut。静电势偏移从rshift=0.0nm到rcut。静电势的偏移会对模拟距离依赖性的screening造成影响。neighbor list可以升到10 steps， neighbor list cutoff设置等于rcut。模拟步长可以升至dt=40fs。当然设置成25fs到30fs可能会更加稳定。选择时间步长的不同对自由能有一定的影响，影响约为5%。（从40到5fs），所以说影响不是很大。 对于粗粒化模拟时间因子一般扩大为2到10倍，文献中默认的时间因子为4（注:文献1如是说，文献3说的为2到8倍，但时间因子均说的为4），即CG模型模拟10ns，实际上相当于现实中40ns，可以粗略的乘以4。产生这个现象的原因是CG模型相对于AA模型联系更加的平滑。 蛋白模拟: 文献中提供的作者使用的模拟参数如下，可能和官网的有出入，毕竟时间和版本较久（文献中的gromacs为3.3），故以下内容是过时的，仅供参考和笔记作用。 拓扑文件使用官网的脚本 每个组（lipids，water 和proteins）的温度算法采用Berendsen温度耦合算法，时间为1ps 使用Berendsen算法进行半均匀（ Semi-isotropic）压力耦合，大气压为1bar任意的在膜平面上且垂直于膜，使用的时间约束为5.0ps，压缩率为4.5*10-5 bar-1 芳香氨基酸残基Val，Ile和Thr侧链和骨架侧链键使用的约束算法为LINCS算法，主要是为了避免快速波动（fluctuations，看到这个单词是否想到了RMSF?）所造成的大量的不稳定现象的发生。 neighbor list 设置为10 steps，neighbor list cutoff等于rcut=1.2nm和其他设置为一样 由于计算影响的原因（猜测是为了更快），所有的珠子设置的相对质量为72，依据为4个水分子，对于环（ring）结构，相对质量设置为45 时间尺度和前面一样，时间因子为4，即25fs相当于有效时间100fs，当然这个估计是不精确的，故需要进行精确时间的模拟计算是行不通的，但是精确模拟计算运用是较少的,故对于研究扩散的时候要特别小心，即时有些扩散的CG模型研究与实验吻合较好。 拓扑中离子需要注意:对于粒子，考虑到AA力场对ions难度已经很大，CG ion力场仅在定性上准确。 这段我也不是很懂，原文如下: Keeping in mind the difficulty of model-ing of ions already with AA force fields, the CG ion force field is only qualitatively accurate Martini力场性能测评部分结果:氨基酸残基侧链在DOPC膜上跨膜研究对不同侧链从DOPC膜中拉出（PMF）研究，将CG模型和全原子模型进行比较，研究结果表明疏水性氨基酸与全原子模拟相比有非常好的吻合，特别是barrier方面。如图中的leucine，isoleucine和valine。对于tryptophan和tyrosine，barrier在全原子profiles中不存在，且在CGprofiles低于5KJ/mol。且最小区域和全原子模拟拟合较好。对于极性氨基酸残基，对于全原子模型和CG模型，也有合理的分布。电荷残基在全原子模拟和CG模拟之间显示了非常大的不同。对于CG模型，其在进入膜中的自由能惩罚被严重低估，但是还是仍然高的（glu，asp和arg超过40，lys超过35）进入膜的数量是可以忽略不计的，换而言之其对于入膜这个时间是没有影响的，但是其他影响是有可能的，这也是力场需要改进的地方。完整的PMF结果如下图: 但是需要注意的是与其相比较的全原子力场为OPLSAA力场，OPLSAA在全原子力场中对于蛋白的表现也并不是那么的好，其对于蛋白是用的老的amber力场，且开发的人较少，长时间未开发（来源:GROMACS中文组-李继存老师） 氨基酸残基联系常数:氨基酸残基i和j的定义如下: 其中1 / C是校正系统中物种浓度的因子,P(x)是在X状态下找到的概率。其中 ，NA是Avogadro’s 数，V是盒子的体积。bound和unbound状态通过计算复合物溶液可及表面（solvent accessible surface area ASA）的不同。当ASA低于阈值的话表示两个残基是联系的，若高出阈值则定义为不联系，阈值的选择来自ASA的直方图分布。得到的结果如下表: 可以发现CG模型和全原子模拟的比例是一样的，但是CG模型较全原子模型数值有低估。 Martini力场的限制:1.参数对于固体相并不是那么准确，相比液体相来说固体和气体相显得太稳定 2.内在熵变会丢失，温度依赖性受到了影响。Martini模型，也许在大多数CG方法中一样遇到的另一个困难是将极性和带电荷的化合物分配成低介电常数。因为极性物质的相互作用强度在非极性环境中会被低估。 3.由于开发的初衷是涉及在非极性环境中形成极性/带电复合物的应用尤其容易受到影响 4.忽略了长程电荷力是另一个限制，超过1.2nm的长程电荷不会被统计！但原则上是可以增加长程电荷的，必须认识到，静电相互作用方案的改进可能影响其他性质，例如每个脂质的面积或自发曲率 5.由于氨基酸残基二面角的存在，使得蛋白的二级结构无法改变，进行模拟的前提之一是蛋白二级结构是没有变化的，若需要查看二级结构的变化，可以使用Go模型。具体可以查看参考文献2. 由于这些限制，个人看法Martini力场还是有很多可以开发和提升的地方，这个力场还是很不是完美，特别是对于带电性质的研究，Martini力场可能是不可行的，有许多需要做的工作来进行完善，否则很难得到自己想要得到的结果！ 最后更新于2017-9-30 参考文献: Marrink S J, Risselada H J, Yefimov S, et al. The MARTINI force field: coarse grained model for biomolecular simulations[J]. The journal of physical chemistry B, 2007, 111(27): 7812-7824. Go N, Taketomi H. Respective roles of short-and long-range interactions in protein folding[J]. Proceedings of the National Academy of Sciences, 1978, 75(2): 559-563. Monticelli L, Kandasamy S K, Periole X, et al. The MARTINI coarse-grained force field: extension to proteins[J]. Journal of chemical theory and computation, 2008, 4(5): 819-834.","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"},{"name":"粗粒化","slug":"粗粒化","permalink":"http://kangsgo.com/tags/粗粒化/"}]},{"title":"[转载]ubuntu16耳机没声音解决","slug":"[转载]ubuntu16耳机没声音解决","date":"2017-09-24T05:08:02.000Z","updated":"2017-10-29T03:33:30.922Z","comments":true,"path":"766.html","link":"","permalink":"http://kangsgo.com/766.html","excerpt":"","text":"本文转自:小ks强博客的ubuntu16耳机没声音解决 由于需要用到GPU显卡用于 gromacs计算，但是装了CUDA驱动后就没有声音了，网上很多办法都没解决，今天看到这个方法完美解决 首先用在终端输入如下命令，安装pulseaudio音量控制软件 1sudo apt install pavucontrol 终端输入指令pavucontrol，在配置中将HDA NVIDIA设置为关，下面设置为模拟立体声双工，如下图 然后在输出设备中选择模拟耳机，就可以听到声音啦","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"VMD可视化粗粒化力场简单介绍","slug":"VMD可视化粗粒化力场简单介绍","date":"2017-09-23T04:22:18.000Z","updated":"2017-10-28T03:26:25.393Z","comments":true,"path":"759.html","link":"","permalink":"http://kangsgo.com/759.html","excerpt":"","text":"此篇文章是简单的归纳总结官网的Rendering CG bonds &amp; constraints with VMD, 查看的时候的时间为16 August 2017，请注意时效性。 该脚本分为两个版本，一个是gromacs5以前版本，一个是gromacs5版本（包括2016），以下均以cg_bonds-v5.tcl为例 使用方法：使用的方法与VMD其他脚本类似，即source一下即可 source /path/to/cg_bonds-v5.tcl 现在脚本可以通过-top设置来读入.top和.itp文件 cg_bonds：-molid “top” VMD-defined ID of the molecule to process -gmx /usr/bin/gmxdump gmxdump绝对路径的执行脚本，对于版本5，默认的为/usr/bin/gmx -tpr topol.tpr 顾名思义 -top topol.top 顾名思义 -topoltype “martini” 蛋白拓扑类型:”martini”,”elastic”,”elnedyn” -net “martini” 绘制网络:”martini”,”elastic”,”both” -bndrcnstr “both” 绘制键和/或约束”bonds”,”constraints”,”both” -cutoff 7.0 键截距（埃） -color “red” 颜色名称或者VMD定义ID对于elastic 键 -mat “Opaque” 对于elnedyn键的材料 -rad 0.2 elastic键半径 -res 6 elastic键分辨率 例子:12345user@machine $ vmd protein.grovmd &gt; source /home/user/scripts/cg_bonds.tclvmd &gt; cg_bonds -top system.top -topoltype “elastic”vmd &gt; cg_bonds -gmx /home/user/bin/gmx-4.5.4/bin/gmxdump -tpr dyn.tpr -net “elastic” -cutoff 12.0 -color “orange” -mat “AOChalky” -res 12 -rad 0.1 -topoltype “elastic”vmd &gt; cg_delete_elastic_bonds","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"粗粒化","slug":"粗粒化","permalink":"http://kangsgo.com/tags/粗粒化/"},{"name":"VMD","slug":"VMD","permalink":"http://kangsgo.com/tags/VMD/"}]},{"title":"不同软件中参数单位","slug":"不同软件中参数单位","date":"2017-09-21T04:49:47.000Z","updated":"2017-10-18T12:17:14.231Z","comments":true,"path":"755.html","link":"","permalink":"http://kangsgo.com/755.html","excerpt":"","text":"看了贾壮老师的博文Gromacs中添加CHARMM力场发现不同软件的力场数值是不一样的，进一步分析可以发现就是单位的变化导致的，所以在这里总（chao）结（xi）常用的力场软件使用的单位。 以下是常用的单元系统 UnitSystem Length unit Mass unit Time unit Charge unit Temperature Amount unit Energy unit si_unit_system meters kilograms second Ampere Kelvin mole joule cgs_unit_system centimeters gram second Ampere Kelvin mole 1e-7 joule md_unit_system nanometers daltons picosecond q electron Kelvin mole kilojoule planck_unit_system pl. length pl. mass pl. time pl. charge pl. temperature item pl. energy akma_unit_system angstroms daltons akma time q electron Kelvin mole kilocalorie 以下为常用软件以及其单元系统: 软 件 单元系统 AMBER akma_unit_system CHARMM akma_unit_system Tinker akma_unit_system Desmond akma_unit_system LAMMPS akma_unit_system NAMD akma_unit_system AceMD akma_unit_system OpenMM md_unit_system Gromacs md_unit_system Gromos md_unit_system","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"linux安装GAUSSIAN 09（G09）和GVIEW简略版","slug":"linux安装GAUSSIAN 09（G09）和GVIEW简略版","date":"2017-09-13T09:50:28.000Z","updated":"2017-10-28T04:02:32.844Z","comments":true,"path":"83.html","link":"","permalink":"http://kangsgo.com/83.html","excerpt":"","text":"首发时间: 2015年12月9日 更新时间:2017年9月13日 一、安装Linux版Gaussian例如安装在/home/kangsgo/install/g09下，下同 首先解压 123456789unzip gaosi09-D01.zipmv g09D01 g09cd g09mkdir scratchgedit ~/.bashrc 在里面加入 123export g09root=/home/kangsgo/installexport GAUSS_SCRDIR=/home/kangsgo/install/g09/scratchsource /home/kangsgo/install/g09/bsd/g09.profile 接下来可以在/home/kangsgo/g09/Default.Route中设置默认参数（需要自己创建），如： 12-M- 12000MB-P- 8 在/home/kangsgo/install/g09/目录下运行： 12chmod 750 -R *source ~/.bashrc 大工告成！ 本段来自于：计算化学公社 二、安装gview在.bashrc末尾加上以下内容: 1234export GV_DIR=/home/kangsgo/install/g09/gv/export LIBPATH=/home/kangsgo/install/g09/gv/libexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/kangsgo/install/g09/gv/libPATH=$PATH:/home/kangsgo/install/g09/gv/ 转载自：计算化学公社","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"},{"name":"Gaussian","slug":"Gaussian","permalink":"http://kangsgo.com/tags/Gaussian/"}]},{"title":"amber非标准残基生成的小坑","slug":"amber非标准残基生成的小坑","date":"2017-09-13T07:10:59.000Z","updated":"2017-12-10T04:32:57.855Z","comments":true,"path":"748.html","link":"","permalink":"http://kangsgo.com/748.html","excerpt":"","text":"由于gromacs需要二面角参数，然而文献中给的CHARMM力场的二面角力场不够，正好看到amber有非标准残基的制作，所以想看一下能不能出坑，没想到一坑比一坑高，爬出一个坑又掉进另外一个坑，坑坑相连，所以在这里把amber非标准残基的小坑给理清楚，给后来人，当然等我非标准氨基酸残基系统的跑完以后会分享给大家完整的流程，大家同样可以看一下是否可以跑出来。 问题1在使用如下命令生成bcc电荷时发生了报错 1antechamber -fi ccif -i CRO.cif -bk CRO -fo ac -o cro.ac -c bcc -at amber 错误信息如下： Residue CRO has a type of LINKING. Quitting 解决办法为删除含有LINKING那一行。 问题2但是有出现了另外一个问题 123processor.acdoctor mode is on: check and diagnosis problems in the inputfile.antechamber: mmcif.c:70: rmmcif: Assertion `col2 &amp;gt;= 0&apos; failed.Aborted(core dumped)* 这个问题在2017年8月提交的错误邮件，所以说应该是AmberTools17工具新的问题，可能老版本没有问题 这个解决办法稍微复杂一些，方法如下: 在$AMBERHOME/AmberTools/src/antechamber 下的mmcif.c中的第68行那一段进行编辑，可以对那一段使用*进行注释， 然后在该目录下进行重新编译 1make install 至此两个问题都可以得到解决，跑出来的文件也是一样的。 参考: [AMBER] Tutorial B5 - Loading CRO from ccif file[AMBER] Error while running antechamber for modified amino acid residue","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"[转载]amber中非标准氨基酸残基的参数生成","slug":"[转载]amber中非标准氨基酸残基的参数生成","date":"2017-09-13T03:38:06.000Z","updated":"2017-10-29T02:46:06.300Z","comments":true,"path":"746.html","link":"","permalink":"http://kangsgo.com/746.html","excerpt":"","text":"转载自:李思琪的博客，由于没有联系上作者未授权，自己的在写，写完就删除该转载：http://blog.csdn.net/sinat_23241095/article/details/53836200 在amber教程中给出了相关的教程，具体流程都是根据这个教程来制作的。 http://ambermd.org/tutorials/basic/tutorial5/ 但是他的电荷使用的是bcc电荷，但是并没有介绍如何把电荷转换为resp。 流程： 0.在pdb数据库中搜索残基名称，选择 ligand id 进行下载对应的cif文件； 1.antechamber -fi ccif -i CRO.cif -bk CRO -fo gcrt -o cro.gjf -ch “cro.chk” -gm “%mem=2048MB” -gn “%nproc=24” -nc 0 #直接将下载的cif转为高斯输入文件，进行高斯计算； 2.antechamber -fi ccif -i CRO.cif -bk CRO -fo ac -o cro_step1.ac -at amber #和教程上一致，目的为了生成参照的ac文件，-at 必须制定，否则原子类型默认gaff； 3.antechamber -fi gout -i cro.log -rn CRO -fo ac -o cro_step2.ac -c resp -at amber #赋予resp电荷到新的ac文件中； 4.文本操作将cro_step2.ac中的坐标以及电荷信息列覆盖到cro_step1.ac中，同时修改主链N原子的原子类型从NT到N，保存为cro_step3.ac； 5.制作mc文件，格式如下图，参照cro_step3.ac文件制作； 6.prepgen -i cro_step3.ac -o cro.prepin -m cro.mc -rn CRO #得到主链信息文件； 7.parmchk2 -i cro.prepin -f prepi -p frcmod.cro -a Y -p $AMBERHOME/dat/leap/parm/parm10.dat #检查生成的参数信息，查看frcmod文件，若其中出现某一行参数为0且有 “ATTN,need revision” 标识则说明在parm10.dat中参数不完整需要用gaff进行补充； 8.grep -v “ATTN” frcmod.cro &gt; frcmod1.cro #剔除不包含的参数，其余存成参数文件； 9.parmchk2 -i cro.prepin -f prepi -o frcmod2.cro #剩余的参数利用gaff生成参数，由于命令中没有指定 “-a Y” 则只生成了原力场中未包含的参数文件； 10.在leap中导入文件即可，loadamberprep cro.prepin ，loadamberparams frcmod1.cro ,loadamberparams frcmod2.cro ,对蛋白无需额外处理，（需要去除H，pdb4amber）。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"},{"name":"amber","slug":"amber","permalink":"http://kangsgo.com/tags/amber/"}]},{"title":"[转载]Gromacs中添加CHARMM力场","slug":"[转载]Gromacs中添加CHARMM力场","date":"2017-09-07T12:05:36.000Z","updated":"2017-10-29T02:51:33.909Z","comments":true,"path":"725.html","link":"","permalink":"http://kangsgo.com/725.html","excerpt":"","text":"转自贾壮老师博客:http://blog.sciencenet.cn/blog-794272-718384.html 待整理 CHARMM力场提供了很多生物分子的力场参数，如蛋白质、脂质、核酸等，Gromacs中自带了CHARMM27力场，当然也可在Gromacs官网上下载到已转换成Gromacs支持的CHARMM36力场。不过使用Gromacs做MD模拟的朋友如果想模拟一个Gromacs中没有定义力场参数的分子，如糖，就需要手动为Gromacs添加相关力场参数了。这些力场参数多数从文献中得到，并且一般都是CHARMM格式的，即.prm 和 .rtf 格式，如何将它们转换成Gromacs支持的格式呢？这篇文章会详细讲解转换过程，并且给出python脚本以供参考。 首先分别讲解一下CHARMM软件和Gromacs软件如何完整定义一个分子的力场。在CHARMM软件中，主要通过2个文件来实现：.rtf 和.prm。 .rtf 文件定义了原子类型、各类型原子的质量、原子偏电荷、分子的键连接以及氢键等，它的格式如图1。MASS是用来定义原子类型的，每一行都定义了一种原子类型。 图1. TIP3水分子的 .rtf 文件，CHARMM中“！”后面的内容是注释 MASS后面跟着原子编号、原子类型名、原子质量和元素符号。GROUP语句用来定义一个残基（也可以是单独的分子）：ATOM定义了残基中各原子的名字、所属的原子类型和该原子所带的偏电荷；BOND定义残基中原子的键连接情况，以原子对形式列出，如图1中的水分子定义了3个键OH2-H1、OH2-H2和H1-H2（最后一个键是SHAKE限制算法用到的）；ANGLE定义键角；DONOR和ACCEPTOR分别用来定义氢键供体和受体。 .prm文件中定义了与能量相关的参数，如键伸缩能，键角、二面角的力常数以及范德华参数，图2给出了TIP3水分子的 .prm 文件。 BONDS数据块是用来定义键伸缩振动能量的，用简谐振动来近似： BONDS数据块每行有4个字段，前两个是成键原子的类型，后两个分别是公式中的Kb（kcal/Å2/mol）和b0（Å）。 ANGLES数据块用来定义键角振动，同样是用简谐振动来近似： ANGLES数据每行有5或7个字段，后者是加了Urey-Bradley项的。前3项是形成键角的原子的类型，后面4项分别对应公式中的Kθ（kcal/度2/mol）、θ0（度）、KUB（kcal/Å2/mol）和b1-3,0（Å）。 关于Urey-Bradley项的解释可以查看gromacs手册:http://jerkwin.github.io/GMX/GMXman-4/#428-urey-bradley势 DIHEDRALS数据块用来定义二面角振动，用余弦函数来近似： DIHEDRALS数据块每行有7个字段，前4项是形成二面角的原子的类型，后面3项分别对应公式中的Kφ（kcal/mol）、n（无单位）和δ（度）。 图2. TIP3水分子的 .prm 文件 IMPROPER数据块用来保证分子中原子共平面的，用简谐振动近似： IMPROPER数据块每行有7个字段，前4项是形成二面角的原子的类型，第5项对应公式中的Kω（kcal/度2/mol），第6项一般是0，暂时不知道干嘛用的，第7项对应公式中的ω0（度）。 NONBONDED数据块用来定义非键作用，其中静电力可通过原子偏电荷求得，不需要额外参数，范德华力通常用L-J形式来描述： 通常力场中只定义单个原子的ε和rmin，成对原子的范德华力参数可以通过组合规则（combination rule）获得，常用的组合规则是εi,j = sqrt(εi×εj)，rmini,j = (rmini+ rminj)/2。另外CHARMM力场将1-4作用单独分出来描述，也采用L-J形式，只是ε和rmin值有所不同。NONBONDED数据块每行有7个字段组成，第1个字段是原子类型，第2、5字段标识为ignored，通常是0，暂不知道干嘛用的，第3，4字段分别为vdw力的ε（kcal/mol）和rmin/2（Å），第6，7字段分别为1-4作用的ε（kcal/mol）和rmin/2（Å）。这里可以提前说明一下，Gromacs中1-4作用是以原子对的形式定义的，叫做pairtypes，转换时需要将CHARMM中的1-4作用通过组合规则两两组合生成pairtypes，这在后面还会详细讲到。 下面讲一下Gromacs中力场文件的格式。Gromacs主要通过5个文件来定义：.rtp、.hdb、atomtypes.atp、ffbonded.itp和ffnonbonded.itp。 .rtp文件用来定义残基（或分子）中原子所属的类型、原子偏电荷、键连接以及共平面原子，其余如键角和二面角是在这里不是必须的，程序一般通过原子类型生成，它将出现在ffbonded.itp文件中。图3是 .rtp 文件的一个示例，里面的注释很详尽，唯一需要说 tmp.png 图3. 甘氨酸的 .rtp 文件，Gromacs中“;”后的内容是注释 明的是chargegroup项，同一个chargegroup中的原子偏电荷变化是以相同比例进行的，对于一个新加入的分子可简单的将每个原子划分到不同的chargegroup中。 .hdb文件是用来给残基（或分子）加氢的，我们知道用X-衍射得到的蛋白结构中一般没有氢，pdb2gmx命令会查询.hdb文件中定义的加氢规则为蛋白加氢。如果你的小分子中氢原子已在 .rtp文件中定义了，就不需要用 .hdb文件来加氢。因为一般力场中都会详细定义蛋白各种参数，我们只需添加一些小分子，而小分子中的氢原子多在 .rtp文件中定义，很少用到 .hdb文件，所以这里不再讲 .hdb文件格式。 atomtypes.atp文件中定义了力场中用到的所有原子类型，格式很简单，第一列是原子类型名，第二列是原子质量，如果你添加的分子用到了新的原子类型，就需要在这里添加相关信息。 ffbonded.itp文件定义了力场中的键作用：键伸缩振动、键角、二面角振动（func=9） 捕获.PNG 图4. ffbonded.itp文件格式 以及IMPROPER（在Gromacs中称为dihedraltypes（func=2））。它们定义及算法与CHARMM中相同，只是公式的形式以及单位有差异： 公式的差异表现在键长、键角、IMPROPER的简谐振动公式在Gromcas中多了一个系数1/2；单位的差异表现在CHARMM中能量单位为kcal，而Gromcas中使用kJ，CHARMM中长度单位为Å，而Gromacs中使用nm。参数从CHARMM转换到Gromacs规则如下： （1） 键伸缩振动：Kgromacs= 2×Kcharmm×cal2j×100 （即Kgromacs = 836.8×Kcharmm，其中cal2j =4.184是cal转换到J的转换系数）；b0gromacs = b0charmm/10。 （2） 键角振动：Kθgromacs = 2×Kθcharmm×cal2j（即Kθgromacs = 8.368×Kθcharmm）；θ0不变；KUBgromacs = 2×KUBcharmm×cal2j×100（即KUBgromacs = 836.8×KUBcharmm）；bUgromacs = bUcharmm/10。 （3） 二面角振动：Kφgromacs = Kφcharmm×cal2j（即Kφgromacs = 4.184×Kφcharmm）；n和φ0不变。 （4） IMPROPER:Kξgromacs = 2×Kξcharmm×cal2j（即Kξgromacs = 8.368×Kξcharmm）；ξ0不变。 值得注意的是这些参数在文件中位值不同，一定要弄清哪一列放哪个参数！ ffnonbonded.itp定义了力场中的非键作用，因静电力可通过原子偏电荷和coulomb公式求的，所以这个文件主要定义范德华力（在atomtypes数据块中）。与CHARMM类似，Gromacs也对1-4作用进行单独处理，处理方式与CHARMM完全相同，1-4作用定义在pairtypes数据块中。Gromacs中描述范德华力的L-J公式与CHARMM中也有差异： 在转换之前我们需将CHARMM和Gromacs中的L-J公式化成相同的形式： 非键作用的参数转换规则如下： εgromacs = -εcharmm×cal2j（即εgromacs = -4.184×εcharmm，不知道问什么CHARMM中加了负号） σgromacs = 2×σcharmm/10/21/6（即σgromacs = 0.1781797436×σcharmm，CHARMM中记录的是rmin/2） 对于1-4作用，转换规则同上，只是Gromacs中通过组合规则（上文讲CHARMM时有提到）以原子对的形式记录在pairtypes数据块中，这需要自己计算添加。图5给出了一个转换示例，注意pairtypes是通过两两组合计算得到的，不区分先后，共6对。 convert.PNG 图5. 非键作用转换示例 对于简单分子可以手动转换并添加到Gromacs力场中，但是当分子较为复杂时手动转换将会变得非常繁琐并且容易出错，这时候就需要用脚本来进行批量处理。附件提供了用python写的转换脚本： cvt_bd.py: 键伸缩项转换，输入文件bonds，输出文件bonds.out cvt_agl.py: 键角转换，输入文件angles，输出文件angles.out cvt_dihedral.py: 二面角转换，输入文件dihedrals，输出文件dihedrals.out cvt_improper.py: improper项转换，输入文件impropers，输出文件impropers.out cvt_nb.py: 非键作用转换，输入文件nobonded，输出文件vdw.out, pair.out 使用方法： 将.prm文件按数据块分成bonds（记录BONDS数据块）、angles（记录ANGLES数据块）、dihedrals（记录DIHEDRALS数据块）、impropers（记录IMPROPER数据块）和nonbonded（记录NONBONDED数据块）5个文件，然后按下面步骤处理： （1）删除关键字BONDS、ANGLES、DIHEDRALS、IMPROPER和NONBONDED所在的行。 （2）删除“！”及其后面的注释内容，这可以在vim中使用命令： :%s/!.*// （3）删除行末多余的空格，可用vim命令： :%s/ *$// （4）删除空行，vim命令： :g/^$/d 处理后的文件应该是每行具有相同列数（angles和nonbonded各行列数不全相同），格式一致的文本。然后运行上面的python脚本，将输出文件拷贝到ffbonded.itp和ffnonbonded.itp文件中对应的数据块内： （1）bonds.out内容拷贝到ffbonded.itp文件[bondtypes]数据域中 （2）angles.out内容拷贝到ffbonded.itp文件[angletypes]数据域中 （3）dihedrals.out内容拷贝到ffbonded.itp文件[dihedraltypes] （func=9）数据域中 （4）impropers.out内容拷贝到ffbonded.itp文件[dihedraltypes]（func=2）数据域中 （5）vdw.out内容拷贝到ffnonbonded.itp文件[atomtypes]数据域中 （6）pair.out内容拷贝到ffnonbonded.itp文件[pairtypes]数据域中 （7）vdw.out的1、3列内容拷贝到atomtypes.atp文件中 最后根据 .rtf 文件中记录的残基（或分子）原子类型、偏电荷、键连接和IMPROPER信息，按照Gromacs的 .rtp文件格式制做该残基（或分子）的 .rtp文件，将该文件放到相应的力场文件目录下（即ffbonded.itp所在目录）。最后提醒大家，分子的pdb文件一定要与 .rtp文件原子顺序和命名完全一致！ 以上所有操作都正确的话就可以用Gromacs模拟该分子了，Happy simulating！ convert_script.rar","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Gromacs如何添加非标准残基进入力场","slug":"Gromacs如何添加非标准残基进入力场","date":"2017-09-07T06:56:48.000Z","updated":"2017-10-29T03:29:31.841Z","comments":true,"path":"722.html","link":"","permalink":"http://kangsgo.com/722.html","excerpt":"","text":"最近在捣鼓一个蛋白，而蛋白内包含有标准残基，弄了许久也没弄进去，谷歌的时候找到一个gromacs添加力场的流程，故简单翻译一遍分享给大家，若需要查看完整的内容可以移步官网:http://www.gromacs.org/Documentation/How-tos/Adding_a_Residue_to_a_Force_Field 如果你有新的残基想要放入已存在的力场文件中，从而使得可以使用已经存在pdb2gmx文件或者修正已经存在的一个，这有几个文件你需要进行修改。当然你需要仔细的查看手册中对与格式的要求。具体下来有如下几步: 在你选择的相应力场中的.rtp文件中增加残基，你可以copy已经存在的残基，重命名以后在进行修改，或者你可以使用额外的拓扑生成工具来适应.rtp文件的格式。 如果你需要对你的新定义残基进行加氢，你可以创建紧密相关的内容至.hdb文件 如果你拥有新的原子类型，增加进入atomtypes.atp和ffnonbonded.itp文件 如果你有新的键类型，增加进入ffbonded.itp文件中 增加你的残基进入resudetypes.dat文件并且指定类型（Protein,DNA，Ion等等） 如果你的残基设计特别的connectivity到其它残基，升级specbond.dat文件特别提醒的是如果仅仅是一个配体的话建议使用配体教程的方法而不是使用这个方法，这个方法会对力场造成污染，而且麻烦。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"一个快速修改PDB中残基编号的脚本","slug":"一个快速修改PDB中残基编号的脚本","date":"2017-09-06T08:47:09.000Z","updated":"2017-10-29T03:12:01.555Z","comments":true,"path":"717.html","link":"","permalink":"http://kangsgo.com/717.html","excerpt":"","text":"不知道他家有没有遇到一个这样的问题，比如我同源建模构建了氨基酸序列200-300的蛋白，但是其建模后蛋白还是会从1开始标注，这在一些绘图和分析的时候非常不方便，需要计算相应的残基编号的改变。又比如晶体结构或者蛋白存在一些缺失，使得残基序列发生跳段，遗憾的是同源建模并不能使得其智能的残基序列跳段，以前我一直使用的是Wincoot，但是安装比较麻烦，而且为了这么一功能安装这么大的网站有点“大材小用”。故写了这么一个献丑的小工具。 使用方法(python 3.6测试可用): 1python residueid.py -h 示例: 1python residueid.py -f gfp.pdb -n 65 -a 3 -s 23 -na -1406 脚本下载地址: https://pan.baidu.com/s/1i5QmkSl","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"Pymol小脚本之Rotkit","slug":"Pymol小脚本之Rotkit","date":"2017-09-05T12:25:21.000Z","updated":"2017-10-28T03:49:13.010Z","comments":true,"path":"714.html","link":"","permalink":"http://kangsgo.com/714.html","excerpt":"","text":"Rotkit是一个pymol小脚本工具包，依稀记得还是大四的时候有人在bioms群里出售一个脚本，可以将配体周围的氨基酸残基进行突变，然后进行突变对接或者分析，来简单的查看突变对配体与蛋白之间的相互影响。当时觉得非常的高达上，今天查看Pymol的时候发现这个小脚本就可以非常容易的实现这个功能，当然pymol的功能不仅仅如此，还有更多的功能。 这个脚本套件是一个小的脚本合集，能够精确的将小分子放在你想要的蛋白质上。（虽然官方介绍这么说，但是还是要强调一下功能远不止如此） PyMOL可用的脚本功能12345678910rotateline(Pos1,Pos2,degangle,molecule): \"Pos1&gt;Pos2\"定义了一个“分子”将旋转“degangle”的度数 rotateline Pos1=P513C_CA, Pos2=P513C_CB, degangle=5, molecule=Atto590 rotateline Pos1=dyeatom87, Pos2=dyeatom85, degangle=10, molecule=Atto590mutate(molecule,chain,resi,target=\"CYS\",mutframe=\"1\"): 突变目标一个/分子/链/残基，并且选择最可能的帧 mutate 1HP1, chain=A, resi=515, target=CYS, mutframe=1toline(Pos1,Pos2,atom,molecule,dist=1): 平移分子原子，1 埃的距离，方向为Pos1&gt;Pos2 toline Pos1=P513C_CA, Pos2=P513C_CB, atom=dyeatom87, molecule=Atto590, dist=3 通过rotkit.functionname1234567891011121314151617181920printMat(matrix): 打印 TTT matrix 格式. (4X4)getxyz(Sel): 输出一个列表[x,y,z]，为浮点数vector(Sel1,Sel2): 寻找两个点的向量vectorstr(vector): 将vector的格式转换为str格式（开始为列表格式）transmat(vector,dist=1): 根据输入向量制作TTT转换矩阵。 矢量乘以距离。unitvector(vector): 将vector变为单位矢量radangle(angle): 转换角度变为弧度（radians）rotmat(angle,vectornorm,pointcoord): 围绕一个坐标点进行旋转point.crossprod(Vector1, Vector2): 两个向量进行矢量积crosspoint(Pos1, crossprod):Returns the endpoint for the Position plus the crossproduct vector. Suitable if one would like to rotate around a crossvector. 示例示例1-对结构进行旋转12345678910111213141516171819202122232425262728293031323334353637383940reinitializeimport rotkit fetch 1HP1, async=0show_as cartoon, 1HP1show_as sticks, 1HP1 and resn ATP ###################### Make rotation axis #################pseudoatom axisA, vdw=1.0pseudoatom axisB, vdw=1.0rotkit.toline(\"/1HP1//A/477/C\",\"/1HP1//A/423/CG1\",\"axisA\",\"axisA\",20)rotkit.toline(\"/1HP1//A/423/CG1\",\"/1HP1//A/477/C\",\"axisB\",\"axisB\",5)show spheres, axisA or axisB label axisA, \"axisA\" label axisB, \"axisB\" dist rotaxis, axisA, axisBcolor green, rotaxisset dash_width, 5set dash_gap, 0hide label, rotaxis ## Create rotate states of 1HP1create 1HP1_rot, 1HP1, 1, 1pythonang_incr = 1anglerange = range(2,98,ang_incr)nrstates = len(anglerange)+1states = 1for angle in anglerange: states += 1 rot_1HP1 = \"1HP1_rot_%s\"%angle cmd.create(rot_1HP1,\"(1HP1 and resi 363-550) or (1HP1 and resn ATP)\") rotkit.rotateline(\"axisA\",\"axisB\",-(angle-1),rot_1HP1) cmd.create(\"1HP1_rot\",rot_1HP1,1,states) cmd.create(\"1HP1_rot\",rot_1HP1,1,2*nrstates-states) cmd.delete(rot_1HP1)python endhide cartoon, (1HP1 and resi 363-550)hide sticks, (1HP1 and resn ATP)mplay 示例2-模拟染料的自由度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667reinitializeimport rotkit fetch 1HP1, async=0show_as cartoon, 1HP1show_as sticks, 1HP1 and resn ATPset auto_zoom, off ###################### Make rotation axis #################pseudoatom axisA, vdw=1.0pseudoatom axisB, vdw=1.0rotkit.toline(\"/1HP1//A/477/C\",\"/1HP1//A/423/CG1\",\"axisA\",\"axisA\",20)rotkit.toline(\"/1HP1//A/423/CG1\",\"/1HP1//A/477/C\",\"axisB\",\"axisB\",5)show spheres, axisA or axisB label axisA, \"axisA\" label axisB, \"axisB\" dist rotaxis, axisA, axisBcolor green, rotaxisset dash_width, 5set dash_gap, 0hide label, rotaxis ####################### Create rotate states of dye atoms ######################## First mutate, the mutate functions take 0.2 seconds, so we put in a refesh command to wait for everything is donerotkit.mutate(\"1HP1\", chain=\"A\", resi=308, target=\"CYS\", mutframe=1)cmd.refresh()rotkit.mutate(\"1HP1\", chain=\"A\", resi=513, target=\"CYS\", mutframe=1)cmd.refresh() ##### Create simulated dye movement atomspseudoatom Donor, vdw=0.5pseudoatom Acceptor, vdw=0.5show spheres, Donor or Acceptor rotkit.toline(\"1HP1 and resi 308 and name CA\",\"1HP1 and resi 308 and name SG\",\"Donor\",\"Donor\",15.0)rotkit.toline(\"1HP1 and resi 513 and name CA\",\"1HP1 and resi 513 and name SG\",\"Acceptor\",\"Acceptor\",15.0) pythonDye_ang_incr = 6Donor_angle_range = range(0,359,Dye_ang_incr)Acceptor_angle_range = range(0,359,Dye_ang_incr)nrstates = len(Donor_angle_range)+1Donor_states = 1Acceptor_states = 1for Donor_angle in Donor_angle_range: Donor_states += 1 Donor_angle_name=\"Donor_%s\"%(Donor_angle) cmd.create(Donor_angle_name,\"Donor\") rotkit.rotateline(\"1HP1 and resi 308 and name CA\",\"1HP1 and resi 308 and name CB\",Donor_angle,Donor_angle_name) # Save it as states in Donor cmd.create(\"Donor\",Donor_angle_name,1,Donor_states) cmd.create(\"Donor\",Donor_angle_name,1,2*nrstates-Donor_states) cmd.group(\"All_Donors\",Donor_angle_name)for Acceptor_angle in Acceptor_angle_range: Acceptor_states += 1 Acceptor_angle_name=\"Acceptor_%s\"%(Acceptor_angle) cmd.create(Acceptor_angle_name,\"Acceptor\") rotkit.rotateline(\"1HP1 and resi 513 and name CA\",\"1HP1 and resi 513 and name CB\",Acceptor_angle,Acceptor_angle_name) # Save it as states in Acceptor cmd.create(\"Acceptor\",Acceptor_angle_name,1,Acceptor_states) cmd.create(\"Acceptor\",Acceptor_angle_name,1,2*nrstates-Acceptor_states) cmd.group(\"All_Acceptors\",Acceptor_angle_name)python enddisable All_Donorsdisable All_Acceptorscmd.create(\"Donor\",\"All_Donors\",1,1)cmd.create(\"Acceptor\",\"All_Acceptors\",1,1)mplay 示例3-创建距离分布直方图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980reinitializeimport rotkit fetch 1HP1, async=0show_as cartoon, 1HP1show_as sticks, 1HP1 and resn ATPset auto_zoom, off ####################### Create rotate states of dye atoms ######################## First mutate, the mutate functions take 0.2 seconds, so we put in a refesh command to wait for everything is donerotkit.mutate(\"1HP1\", chain=\"A\", resi=308, target=\"CYS\", mutframe=1)cmd.refresh()rotkit.mutate(\"1HP1\", chain=\"A\", resi=513, target=\"CYS\", mutframe=1)cmd.refresh() ##### Create simulated dye movement atomspseudoatom Donor, vdw=0.5pseudoatom Acceptor, vdw=0.5show spheres, Donor or Acceptor rotkit.toline(\"1HP1 and resi 308 and name CA\",\"1HP1 and resi 308 and name SG\",\"Donor\",\"Donor\",15.0)rotkit.toline(\"1HP1 and resi 513 and name CA\",\"1HP1 and resi 513 and name SG\",\"Acceptor\",\"Acceptor\",15.0) pythonDye_ang_incr = 6Donor_angle_range = range(0,359,Dye_ang_incr)Acceptor_angle_range = range(0,359,Dye_ang_incr)Donor_names = []Acceptor_names = []for Donor_angle in Donor_angle_range: Donor_angle_name=\"Donor_%s\"%(Donor_angle) Donor_names.append([Donor_angle,Donor_angle_name]) cmd.create(Donor_angle_name,\"Donor\") rotkit.rotateline(\"1HP1 and resi 308 and name CA\",\"1HP1 and resi 308 and name CB\",Donor_angle,Donor_angle_name) cmd.group(\"All_Donors\",Donor_angle_name)for Acceptor_angle in Acceptor_angle_range: Acceptor_angle_name=\"Acceptor_%s\"%(Acceptor_angle) Acceptor_names.append([Acceptor_angle,Acceptor_angle_name]) cmd.create(Acceptor_angle_name,\"Acceptor\") rotkit.rotateline(\"1HP1 and resi 513 and name CA\",\"1HP1 and resi 513 and name CB\",Acceptor_angle,Acceptor_angle_name) cmd.group(\"All_Acceptors\",Acceptor_angle_name)python enddisable All_Donorsdisable All_Acceptorscmd.create(\"Donor\",\"All_Donors\")cmd.create(\"Acceptor\",\"All_Acceptors\")cmd.refresh() # Make a distribution for the Open caseDon_Acc_distribution = []pythonfor Don in Donor_names: for Acc in Acceptor_names: distname = \"%s_%s\"%(Don[1],Acc[1]) distance = cmd.dist(distname,Don[1],Acc[1]) Don_Acc_distribution.append([Don[0], Acc[1], distance]) cmd.delete(distname)python endNewdir=rotkit.createdirs(\"results_rotkit\")os.chdir(Newdir) rotkit.makehistogram(Don_Acc_distribution,dataname=\"Don_Acc_Open\",datalistindex=2,nrbins=100,binrange=[0,0]) # Make a distribution for angle rangecmd.create(\"Acceptor_rot\",\"All_Acceptors\")pythonang_incr = 1anglerange = range(2,98,ang_incr)nrstates = len(anglerange)+1states = 1for angle in anglerange: states += 1 rot_Acceptor = \"Acceptor_rot_%s\"%angle cmd.create(rot_Acceptor,\"Acceptor_rot\") rotkit.rotateline(\"/1HP1//A/423/CG1\",\"/1HP1//A/477/C\",-(angle-1),rot_Acceptor) cmd.create(\"Acceptor_rot\",rot_Acceptor,1,states) cmd.create(\"Acceptor_rot\",rot_Acceptor,1,2*nrstates-states) cmd.delete(rot_Acceptor) for Acc in Acceptor_names: rotkit.rotateline(\"/1HP1//A/423/CG1\",\"/1HP1//A/477/C\",(angle-1),Acc[1])python endmplay 示例5-功能向导文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161reinitializeimport rotkitfetch 1HP1, async=0pythonif 'PYMOL_GIT_MOD' in os.environ: example_dir = os.path.join(os.path.split(os.environ['PYMOL_GIT_MOD'])[0],\"files_for_examples\") cmd.load(os.path.join(example_dir,\"Atto590.pdb\"))else: cmd.load(\"Atto590.pdb\")python end# Make sure everything is loaded before we continuecmd.refresh() ### Get the names of the loaded objectsprotname = cmd.get_names()[0]molname = cmd.get_names()[1] ### Make the names we are going to useprotselectCB=\"%s and resi 308 and name CB\"%protnameprotnameselectCB=\"K308CB\"protselectCA=\"%s and resi 308 and name CA\"%protnameprotnameselectCA=\"K308CA\"molselect13=\"%s and id 13\"%molnamemolnameselect13=\"dyeatom13\"molselect12=\"%s and id 12\"%molnamemolnameselect12=\"dyeatom12\" ### Make some selectionscmd.select(\"%s\"%protnameselectCB,\"%s\"%protselectCB)cmd.select(\"%s\"%protnameselectCA,\"%s\"%protselectCA)cmd.select(\"%s\"%molnameselect13,\"%s\"%molselect13)cmd.label(\"%s\"%molnameselect13,\"13\")cmd.select(\"%s\"%molnameselect12,\"%s\"%molselect12)cmd.label(\"%s\"%molnameselect12,\"12\") ### Make nice representationscmd.show_as(\"cartoon\",\"%s\"%protname)cmd.show(\"sticks\",\"byres %s\"%protnameselectCB) ##### PART I: Use of functions ######## This view will take you to the first partset_view (\\ 0.377224118, 0.880101919, -0.288305759,\\ 0.661396861, -0.473919988, -0.581338286,\\ -0.648268998, 0.028612033, -0.760871351,\\ 0.000000000, 0.000000000, -56.408561707,\\ 19.480533600, 34.572898865, 6.978204727,\\ 46.615653992, 66.201446533, -20.000001907 ) #### Just unhash each part for itself, as you continue through### To print a objects TTT matrix in a readable formatrotkit.printMat(cmd.get_object_matrix(molname)) ##### We want to move the dye to a desired location, and rotate it to a view we desire##### First get the vector bewteen the dyeatom and the protein atomdiffvector = rotkit.vector(\"%s\"%molselect13,\"%s\"%protnameselectCB)##### Then move the dyemove = rotkit.transmat(diffvector)##### print the matrix for funrotkit.printMat(move)##### Move the dyecmd.transform_selection(\"%s\"%molname,move) ##### Now we want to displace the dye in the CA-CB bond direction##### First find the vector/direction to displace it in. From A -&gt; Bdiffvector = rotkit.vector(\"%s\"%protnameselectCA,\"%s\"%protnameselectCB)##### Make the vector so its lenth is equal 1uvector = rotkit.unitvector(diffvector)[0]##### Make the move translation matrix, and we multiply the matrix with 3, so it moves 3 Angstrommove = rotkit.transmat(uvector,3)##### Print the matrixrotkit.printMat(move)##### Displace it in the CA-CB directioncmd.transform_selection(\"%s\"%molname,move) ##### Now we want to rotate it a single time. We convert 40 degress to radians##### The input is the angle, the line to rotate around, and a point where the line goes throughCBxyz = rotkit.getxyz(\"%s\"%protnameselectCB)[0]rmat = rotkit.rotmat(rotkit.radangle(40),uvector,CBxyz)rotkit.printMat(rmat)##### Copy paste this line into pymol to see it manuallycmd.transform_selection(\"%s\"%molname,rmat) ##### We are not quite satisfied, we want to rotate it around its own bond##### So we rotate in around its own 13 -&gt; 12 bondsdiffvector = rotkit.vector(\"%s\"%molnameselect13,\"%s\"%molnameselect12)uvector = rotkit.unitvector(diffvector)[0]xyz12 = rotkit.getxyz(\"%s\"%molnameselect12)[0]rmat = rotkit.rotmat(rotkit.radangle(10),uvector,xyz12)##### Copy paste this line into pymol to see it manuallycmd.transform_selection(\"%s\"%molname,rmat) ##### Now, lets make a function that collects all these call in one function##### We only want to define two positions that defines the line, the angle and the object to rotaterotkit.rotateline(\"%s\"%molnameselect13,\"%s\"%molnameselect12,180,\"%s\"%molname)##### This is made as a pymol command as well. I first print the names that we should write manually in the consolprint(\"rotateline Pos1=%s, Pos2=%s, degangle=15, molecule=%s\"%(molnameselect13, molnameselect12, molname)) ##### To illustate best, we create som copies of the dyepythonanglerange = range(90,360,90)for angle in anglerange: ### Make a suitable name for the new molecule molanglename=\"%s%s\"%(molname,angle) ### Now make a copy cmd.create(molanglename,molname) cmd.label(\"%s and id 12\"%molanglename,\"12\") cmd.label(\"%s and id 13\"%molanglename,\"13\") ### Rotate the copy rotkit.rotateline(\"%s\"%protnameselectCB,\"%s\"%molnameselect13,angle,\"%s\"%molanglename)python end ####### End of PART I ########### PART II: More advanced functions ########## This view will take you to the second partset_view (\\ 0.723298192, 0.467510879, 0.508201897,\\ 0.371686131, -0.883831143, 0.284063697,\\ 0.581970334, -0.016570913, -0.813038886,\\ 0.000000000, 0.000000000, -76.609786987,\\ 11.790571213, 64.992294312, 20.803859711,\\ -31.181428909, 184.401092529, -20.000001907 ) ##### We can fast mutate a protein. frame 1 is the most probable mutationrotkit.mutate(protname, chain=\"A\", resi=513, target=\"CYS\", mutframe=1)##### The mutate functions take 0.2 seconds, so we put in a refesh command to wait for everything is donecmd.refresh()##### This is made as a pymol command as well. I first print the names that we should write manually in the consolprint(\"mutate %s, chain=%s, resi=%s, target=CYS, mutframe=1\"%(protname, \"A\", 515)) ##### We now make some selections for this mutationprotselectCBcys=\"%s and resi 513 and name CB\"%protnameprotnameselectCBcys=\"P513C_CB\"protselectCAcys=\"%s and resi 513 and name CA\"%protnameprotnameselectCAcys=\"P513C_CA\"cmd.select(\"%s\"%protnameselectCBcys,\"%s\"%protselectCBcys)cmd.select(\"%s\"%protnameselectCAcys,\"%s\"%protselectCAcys) ##### Now, lets make a function that collects all the commands to put on an atom on the same line defined by two points##### The input is the two points that define the line, the atom of a molecule to be put on the line, and the distance to moverotkit.toline(protnameselectCAcys,protnameselectCBcys,molnameselect13,molname,3)rotkit.rotateline(protnameselectCAcys,protnameselectCBcys,180,molname)rotkit.rotateline(molnameselect13,molnameselect12,10,molname)print(\"toline Pos1=%s, Pos2=%s, atom=%s, molecule=%s, dist=%s\"%(protnameselectCAcys,protnameselectCBcys,molnameselect13,molname,3))print(\"rotateline Pos1=%s, Pos2=%s, degangle=180, molecule=%s\"%(protnameselectCAcys, protnameselectCBcys, molname))print(\"rotateline Pos1=%s, Pos2=%s, degangle=10, molecule=%s\"%(molnameselect13, molnameselect12, molname))cmd.refresh()####### End of PART II #### ####### Now we make a cross product ####molselect14=\"%s and id 14\"%molnamemolnameselect14=\"dyeatom14\"cmd.select(\"%s\"%molnameselect14,\"%s\"%molselect14)cmd.label(\"%s\"%molnameselect14,\"14\") cross = rotkit.crossprod(rotkit.vector(molselect13,molselect12),rotkit.vector(molselect13,molselect14))unity_cross = rotkit.unitvector(cross)[0]point_cross = rotkit.crosspoint(molselect13,cross)rotkit.rotateline(molnameselect13,point_cross,180,molname)print(\"rotateline Pos1=%s, Pos2=%s, degangle=10, molecule=%s\"%(molnameselect13, point_cross, molname))","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"Pymol 选择速查手册","slug":"Pymol 选择速查手册","date":"2017-09-05T05:27:24.000Z","updated":"2017-10-18T14:39:47.606Z","comments":true,"path":"706.html","link":"","permalink":"http://kangsgo.com/706.html","excerpt":"","text":"此内容主要是为了对Pymol进行选择的小结总结，完全的内容可以查看PymolWiki。 pymol.png 此内容主要是为了对Pymol进行选择的小结总结，完全的内容可以查看PymolWiki。 原子选择的命名123456789#表达式select selection-name,selection-expression#例子select bb,name c+o+n+ca #创建名称“bb”的原子，包括“C”，“O”，“N”或者“CA”的原子color red, bb #给bb赋予红色hide lines, bb #隐藏线状representationshow sticks, bb #棒状展示zoom bb #聚焦bb 单字母选择 –单字母– –短选择– –描述– all * PyMOL中加载全原子 none none 啥也不选 hydro h. 所有氢原子，足以后面有. hetatm het 加载HETATM标签 visible v. 选择所有可见的原子 polymer pol. 聚合物 backbone bb. 骨架原子 sidechain sc. 侧链原子 center 居中 origin 旋转 orgainic org. 所有非聚合的有机化合物（如:配体，buffers等等） inorganic 非有机分析 metals 金属离子（PyMOL1.6.1以上） solvent 溶剂分析，包括HOH，WAT，H2O，TIP，SOL 12345678910#示例color blue, all #所有颜色标记为bluecolor blue, *hide hydro #所有氢原子都隐藏hide h.show spheres, hetatom #所有定义为HETATOMS的原子show spheres, het 特征选择 –匹配参数选择– –短字符– –例子和解释– symbol e. 一到两个化学特征字符select polar,symbol O+N name n. 最高4个字符的蛋白或者核酸原子select carbons,name CA+CB+CG+CD resn r. 残基名select aas, resn ASP+GLU+ASN 核酸名select bases,resn A+G resi i. 残基编号select mults10,resi 1+10+100``select nterm,resi 1-10 alt alt alternate-conformation-identifier-list select altconf,alt A+&quot;&quot; chain c. 选择相应的链select firstch,chain A segi s. 选择片段特征select ligand,segi lig flag f. 从0到31的单整数select f1,flag 0 numeric_type nt. 单个整数select typel, nt. 5 text_type tt. type-stringselect subset,text_type HA+HC id id 单整数外部索引select idno,id 23 index idx. 单整数内部索引select intid,index 11 ss ss 二级结构select allstrs,ss H+S+L+&quot;&quot; 数字选择表 –数字选择– –短字符– –参数和例子– b b beta因子select fuzzy,b&gt;10 q q 占有率值select lowcharges,q&gt;0.50 formal_charge fc. 形成电荷值select doubles,fc.=-1 partial_charge pc. 部分电荷值select hicharges,pc.&gt;1 1234# 例子select nterm,resi 1+2+3select nterm,resi 1-3select unstruct,ss \" \" 选择操作和修饰表格 –操作– –短字符– –影响– not s1 !s1 不包括select sidechains,!bb s1 and s2 s1&amp;s2 选择既在s1又在s2中的原子select far_bb,bb&amp;farfrm_ten s1 or s2 s1\\ s2 选择s1或者s2中的原子（也就是包含全部的s1和 s2原子）`select all_prot,bb\\ sidechain` s1 in s2 选择s1中的那些原子，其identifiers (name, resi, resn, chain, segi) 全部符合s2中对应的原子select same_atms,pept in prot s1 like s2 s1 \\ .s2 选择s1中的那些原子，其identifiers (name, resi) 符合s2中对应的原子select similar_atms,pept like prot s1 gap X 选择那些原子，其van der Waals半径至少和s1的 van der Waals半径相差Xselect farfrm_ten,resi 10 gap 5 s1 around X s1 a.X 选择以s1中任何原子为中心，X为半径，所包括的所 有原子 select near_ten,resi 10 around 5 s1 expand s1 x.X 选择以s1中任何原子为中心，X为半径，然后把s1 扩展至该新的范围所包含的所有原子 select near_ten_x,near_ten expand 3 s1 within X of s2 s1 w.X of s2 选择以s2为中心，X为半径，并包含在s1中的原子 select bbnearten,bb w. 4 of resi 10 byres s1 br. s1 扩展完整的分子select complete_mol, bm. bbnear10 bymolecule s1 bm.s1 故名思义，下同 byfragment s1 bf. s1 select complete_frag, bf. bbnear10 bysegment s1 bs. s1 select complete_seg, bs. bbnear10 byobject s1 bo. s1 把选择扩展到全部object select near_obj, bo. near_res bycell s1 byring s1 1.8.2新功能select rings,byring (all) neighbor s1 nbr. s1 选择直接和s1相连的原子.select vicinos,neighbor resi 10 bound_to s1 bto. s1 s1 extend X s1 xt. X selecr connect_x,near10 extend 3 pepseq SEQ ps. SEQ select 1tvn and ps. FATEW rep rep select sele,rep spheres 大量快速选择1select pept and segi lig and chain b and resi 142 and name ca 可以压缩成如下格式:1select /pept/lig/b/142/ca","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"VMD粗粒化显示插件Bendix简单介绍","slug":"VMD粗粒化显示插件Bendix简单介绍","date":"2017-08-24T01:19:52.000Z","updated":"2017-10-28T15:07:43.095Z","comments":true,"path":"700.html","link":"","permalink":"http://kangsgo.com/700.html","excerpt":"","text":"VMD是一个分子可视化程序, 它采用三维图形技术以及内置脚本来对生物大分子体系进行展示, 动画制作和分析. VMD官方网站 http://www.ks.uiuc.edu/Research/vmd/.其展示的蛋白非常漂亮，而且是免费软件，是与Pymol，UCSF Chimera齐名的可视化软件。但是粗粒化的显示效果不佳，好在可以在VMD 1.9.2以后自带的Bendix插件的帮助下显示非常美丽的粗粒化模型。 先一饱眼福粗粒化模拟做出来的图： 图片1： DPPC bilayer formation 官方教程这里对官方显示教程做一个简单的介绍：首先下载官方示例包：http://sbcb.bioch.ox.ac.uk/Bendix/data/tutorial_files.zip其中包含pdb文件（PDB ID：1PV7）和一个分析文件（pdb）以及一个分析轨迹文件（dcd） 1.VMD中一般螺旋表示首先我们可以把背景设置为白色VMD Main &gt; Graphics &gt; Colours，选择Display，设置Background颜色为8 white加载 1PV7_LacY.pdb。通过Graphics &gt;Representations设置为下图所示： 2.Bendix中螺旋的功能图形的显示从VMD Main&gt;Extensions&gt;Visualization&gt;Bendix中打开工具，保持默认设置，点击Draw按钮，结果如下： 3.设置成单一颜色这个非常的简单，在Uniform color中设置 full selection即可，如果是多个蛋白，设置by chain即可显示不同颜色 4.热图显示热图仅需设置为Heatmap color即可，Scale选项默认为RGB，即Red-Green-Blue，Color threshold为颜色阈值。 5. 绘制non-Bendices仅需Rep 0修改为Tube即可 完整的教程包括轨迹教程可以查阅官方文档：http://sbcb.bioch.ox.ac.uk/Bendix/tutorial.html","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"},{"name":"粗粒化","slug":"粗粒化","permalink":"http://kangsgo.com/tags/粗粒化/"},{"name":"VMD","slug":"VMD","permalink":"http://kangsgo.com/tags/VMD/"}]},{"title":"Gromacs 5.1.2做拉伸动力学的几点笔记","slug":"Gromacs 5.1.2做拉伸动力学的几点笔记","date":"2017-08-19T07:14:18.000Z","updated":"2017-10-28T15:04:45.815Z","comments":true,"path":"694.html","link":"","permalink":"http://kangsgo.com/694.html","excerpt":"","text":"因为后期实验需要用到，最近几天在学习拉伸动力学模拟，虽然拉伸动力学教程为5.X版本，但是自5.1版本对于pull模块还是有较大的变化，这里和大家分享一下其中遇到的问题和我自己的解决方法。 英文版已经升级到5.1最新了，可能用5.1版本不会遇到这些问题 首先第一条就遇到了一点小问题 gmx pdb2gmx -f input.pdb -ignh -ter -o complex.gro 其提示选择什么水模型，我选择的SPC模型，个人觉得加-water tip3p更佳？因为不知道最后采用的什么水模型。也没要TIP3P，TIP4P之类的选项让人没有底。 在进行构型生成的时候，会有一系列的错误，我们首先来看教程中的 12345678910111213; Pull codepull = yespull_ngroups = 2pull_ncoords = 1pull_group1_name = Chain_Apull_group2_name = Chain_Bpull_coord1_type = umbrella ; harmonic biasing forcepull_coord1_geometry = distance ; simple distance increasepull_coord1_groups = 1 2pull_coord1_dim = N N Ypull_coord1_rate = 0.01 ; 0.01 nm per ps = 10 nm per nspull_coord1_k = 1000 ; kJ mol^-1 nm^-2pull_start = yes ; define initial COM distance &amp;gt; 0 第一个为pull_start提示的warning，现在该参数在新版中已经没有，需要改成pull_coord1_start （英文版本已经改过来了）参考的为：https://mailman-1.sys.kth.se/pipermail/gromacs.org_gmx-users/2016-March/104109.html NOTE 1提示的没有设置特定的cutoff-scheme的值，cutoff-schemegromacs中只有group方案和Verlet方案，group方案较老，可能新的版本已经不存在了，同时速度也较差，具体可以查看。http://www.gromacs.org/Documentation/Cut-off_schemes nstlist可以设置超过10，因为在Verlet算法中nstlist不影响精确度 leapfrog does not yet support Nose-Hoover chains, nhchainlength reset to 1这个问题有人说无关紧要，有人说可以http://gromacs.org_gmx-users.maillist.sys.kth.narkive.com/cXo18Y84/dr-lemkul-s-umbrella-sampling-tutorial-grompp-note-on-leap-frog-nose-hoover nstcomm &amp;amp;lt; nstcalcenergy defeats the purpose of nstcalcenergy, setting nstcomm to nstcalcenergy中nstomm选项是用来去除质心的整体运动的，如果不使用的话，体系整体会有平动速度，沿某一方向平移，去除后就没有这种现象了，轨迹看起来也正常一些。一个办法是不去管他（我的方法），另外一个可以nstcalcenergy设置为10 distances.pl脚本李老师翻译的版本中gmx distance中-oaxy命令已经过时，可以使用英文网站上的perl脚本，但是我使用还是会有阅读不全的问题，好像是阻塞的缘故，但是自己不会用perl就重新用python写了一个，如下： 1234567891011121314151617181920212223242526272829303132#-*-coding:utf-8-*-# usage:python distances.py [filenum=501]# example:python distances.pyimport os,re,systry:num=int(sys.argv[1])except:num=501for i in range(num):cmd=\"gmx distance -s pull.tpr -f conf%s.gro -n index.ndx -oall dist%s.xvg -select \\'com of group \\\"Chain_A\\\" plus com of group \\\"Chain_B\\\"\\' \" %(str(i),str(i))os.system(cmd)output=open('summary_distances.dat','a')for i in range(num):file='dist'+str(i)+'.xvg'if os.path.exists(file):input=open(file,'r')for line in input:if re.match(r'^[#@]',line):passelse:num,distance=line.split()#print(distance)output.write(str(i)+\"\\t\")output.write(distance)output.write('\\n')input.close()output.close() setupUmbrella.pypython版本为2.x，像我这种用3版本的就尴尬了，又不想重新写，就用conda环境包弄一下。12conda create --name python2 python=2.7source activate python &nbsp; run-umbrella.sh中需要前面需要加gmx，如下: 1234567#!/bin/bash# Short equilibrationgmx grompp -f npt_umbrella.mdp -c confXXX.gro -p topol.top -n index.ndx -o nptXXX.tprgmx mdrun -deffnm nptXXX# Umbrella rungmx grompp -f md_umbrella.mdp -c nptXXX.gro -t nptXXX.cpt -p topol.top -n index.ndx -o umbrellaXXX.tprgmx mdrun -deffnm umbrellaXXX -pf pullf-umbrellaXXX.xvg -px pullx-umbrellaXXX.xvg 后面也是pull_coord1_start的问题，修改一下即可 &nbsp; &nbsp;","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"GromacsWrapper:Gromacs的Python框架包","slug":"GromacsWrapperGromacs的Python框架包","date":"2017-08-10T08:15:21.000Z","updated":"2017-10-28T04:05:54.693Z","comments":true,"path":"690.html","link":"","permalink":"http://kangsgo.com/690.html","excerpt":"","text":"GromacsWrapper是一个调用Gromacs工具的封装Python包，其能够完美的通过python脚本来运行gromacs工具。其相比shell脚本在错误处理和结构检测中更具优势，同时其模块化以及代码的循环利用也是该软件包的一大特色。其支持的gromacs版本有（v4.6.x, v5.x, and 2016.x）笔者写这篇文章时版本为0.6.2，版本更新请查看最新文档 一、安装1.快速安装建议使用这个方法，简单方便:1pip install GromacsWrapper 2.手动安装如果你更加喜欢下载安装，可以进入https://github.com/Becksteinlab/GromacsWrapper/releases下载安装，笔者写此篇文章时版本为0.6.21pip install GromacsWrapper-0.6.2.tar.gz 或者下载下来本地安装:123tar -zxvf GromacsWrapper-0.6.2.tar.gzcd GromacsWrapper-0.6.2python setup.py install 3.要求GromacsWrapper包需要使用python2.7版本，同时需要numpy,matplotlib以及scipy和RecSQL的支持，同时官网强烈推荐ipython的安装，所以强烈建议下载一个Anconda若还没有使用过anconda建议看一下先前的一篇文章我们仅需要创建一个新的python环境，然后pip RecSQL，conda安装以上包即可。 简单代码可以参考如下,也可以当作是一个温故知新吧：1234567#配置环境与安装conda create --name gromacsw python=2.7 matplotlib scipy numpy jupyter#激活环境source activate gromacsw#安装剩余依赖与软件pip install recsqlpip install GromacsWrapper 二、设置GromacsWrapper安装好以后我们需要对其进行设置，从而能够使得其来阅读与操作。其gromacswarapper.cfg在模块根目录可以查看到，例如我安装的位于miniconda3/envs/gromacsw/lib/python2.7/site-packages/gromacs/templates目录下。在首次导入时，将会提示你进行设置，设置的方法也非常的简单。12import gromacsgromacs.config.setup() 其将会在~/.gromacswrapper.cfg创建一个设置文件，同时会创建一个~/.gromacswapper的目录文件，那么你可以对其进行编辑了，以下为具体的设置内容与解释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[DEFAULT]# 存储用户模板与rc文件.configdir = ~/.gromacswrapper# 存储用户系统脚本.qscriptdir = %(configdir)s/qscripts# 存储用户模板例如mdp文件.templatesdir = %(configdir)s/templates# 存储用户管理设置文件managerdir = %(configdir)s/managers[Gromacs]# gromacs安装的版本.# gromacs路径## GMXRC = /usr/local/gromacs/bin/GMXRC#如果为空默认先搜索gromacs5，然后是gromacs4##release = 5.1.2# Gromacs工具所有的工具名#编辑此列表仅在重新加载软件包时才起作用。.# - for Gromacs 4: Generated with &apos;ls [^Gac]*&apos; from the Gromacs bin dir## tools = ...# - 对于Gromacs5版本，仅需设置如下即可## tools = gmx gmx_d# 哪些工具可用作为 gromacs.NAME# 一般不需要修改## groups = tools[Logging]# 在当前目录下写下什么日志文件logfilename = gromacs.log# 日志文件等级 (see Python&apos;s logging module for details)## ERROR only fatal errors# WARN only warnings# INFO interesting messages# DEBUG everything# # 写在屏幕上什么内容loglevel_console = INFO# file 什么消息写在日志文件中loglevel_file = DEBUG 其中版本可以通过gmx -version（5X版本）查看，GMXRC路径可以搜索一下，若是apt-get安装我的是/usr/share/gromacs/shell-specific/GMXRC仅供参考。 最后我们可以检测一下是否设置好1gromacs.config.check_setup() 不出意外的话返回的为True","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"PLIP:蛋白配体联系分析工具","slug":"PLIP蛋白配体联系分析工具","date":"2017-08-10T08:08:23.000Z","updated":"2017-11-12T07:38:18.568Z","comments":true,"path":"684.html","link":"","permalink":"http://kangsgo.com/684.html","excerpt":"","text":"&gt; PILP（Protein-Ligand Interaction Profiler）是一个在线的蛋白配体非共价联系的分析工具，其简单易用，同时提供Github版本利于学习其设计模式。PILP可以直接使用四字符的PDB code或者使用自己的pdb结构文件。之后分析复合物，结果将会展示所有可测定的在原子水平的非共价联系（氢键，水桥，盐桥，卤键，疏水联系，π-堆积，π-离子联系，金属复合物）。同时结果可以下载文本结果，机器可读的XML格式以及PyMOL可视化文件（pse），同时网站上也有JSmol应用的3D联系图像。其网址为:http://plip.biotec.tu-dresden.de/plip-web/plip/indexGithub地址为:https://github.com/ssalentin/plip首先上传PDB或者直接输入PDB code，例如1XDN： 主界面 结果如图： 结果图 可以看出结果图片可以说达到发表级，也难怪其可以在2015年发表到NAR这种高水平的杂志上，相关的解释与测定标准可以看官网上的帮助文档:http://plip.biotec.tu-dresden.de/plip-web/plip/help同样你也可以下载pse文件，导入进PyMOL中查看: PyMOL 参考文献:Salentin,S. et al. PLIP: fully automated protein-ligand interaction profiler. Nucl. Acids Res. (1 July 2015) 43 (W1): W443-W447. doi: 10.1093/nar/gkv315​","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[]},{"title":"LigParGen:配体OPLS/CM1A力场在线生成","slug":"LigParGen配体OPLSCM1A力场在线生成","date":"2017-08-10T08:06:49.000Z","updated":"2017-10-28T04:05:23.210Z","comments":true,"path":"681.html","link":"","permalink":"http://kangsgo.com/681.html","excerpt":"","text":"LigParGen是一个提供有机分子或者配体力场的在线服务网站，其能够提供键长，二面角以及Lennard-Jones OPLS-AA参数，电荷算法为1.14*CM1A或1.14*CM1A-LBCC。生成的配体力场可以非常容易的在Gromacs，NAMD以及OpenMM中使用，文章中说明将在不久提供Amber软件的支持。最大配体原子大小不超过200个原子，计算模型的电荷最大为正负2。 该在线服务器的使用方法非常的简单，并且使用的电荷计算模型1.14CM1A在OPLS-AA力场中水化自由能计算（hydration free energies ，HFE）与实验具有良好的拟合效果，而改进的局部电荷校正（LBCC）方法更加提供了电荷的精确度，称之为1.14\\CM1A-LBCC模型。在在线服务中，对于不带电的小分子提供1.14*CM1A和1.14*CM1A-LBCC模型，而带电荷的分子仅提供不放大1.14倍的CM1A模型。故带电荷的小分子还是最好使用GAFF力场制作方法。 LigParGen服务网址为:http://zarbi.chem.yale.edu/ligpargen/index.html 理论基础CM1A方法使用来自于电荷密度的Mulliken分布分析，而电荷密度获得的方式为AM1方法基于配体几何计算，*故配体几何的差别会导致电荷计算轻微差别，但影响不大。Mulliken电荷对原子A的计算方法大致如下(具体可以查看参考文献4)： qA是部分Mulliken 电荷，ZA是原子A的中性电荷，NA是原子A的电荷密度分布，计算方法如下: N是分子的总电荷数，Cn,i 为分子轨道系数，χn 和SnkQM多重积分，但1.14*CM1A电荷模型在苯环，醚类和酮类中参数不理想， 在426个有机分子的测试集中和实验数据相比mean unsigned error (MUE)达到1.5kcal/mol，而改进的局部电荷校正（LBCC）方法具有更好的效果。作者进行了水化自由能（HFE）的评价，模拟的计算方法软件采用的NAMD，一共计算了10个分子，每个分子进行了36个窗口计算，每个窗口模拟1ns，力场采用OPLS-AA/1.14*CM1A-LBCC，水采用的TIP3P，完成参数请看底部的参考文献3。实验结果与模拟的结果拟合的较好，结果如下: 说明模拟结果和实验结果拟合的非常棒！ LigParGen使用方法LigParGen的使用方法非常的简单:首先上传MOL或者PDB文件或者SMILES Code: 当然也可以通过JSME自己画，如下图: 首先点一下Make SMILES，画完以后再点击一下Make SMILES即可。 然后选择电荷模型，是否优化分子，分子电荷等选项。 之后便可以下载不同软件需要用到的文件。软件的工作流程如下: 蛋白配体复合物模拟LigParGen提供了3种模拟软件的蛋白配体复合物模拟的方法，可以在官网上查看，我们这里翻译GROMACS的蛋白配体复合物模拟。 1.准备蛋白配体系统Gromacs，Chimera和python被要求安装。 1.1 获得复合物使用T4溶菌酶L99A与苯环分子复合物（PDB ID:4W52）作为教程，结构如下图，仅包含一条链 T4 Lysozyme L99A with Benzene 1.2 模拟前的蛋白准备工作清理蛋白使用Chimera的对接准备功能（dockprep ），增加缺失残基使用Dunbrack rotamer库，这一部并不会进行蛋白加氢，因为在后面pdb2gmx会对蛋白进行加氢。Chimera脚本如下: 123456789101112131415161718## PDB_FILE SHOULD THE COMPLETE PATH OF THE FILE## REPLACE BNZ with LIGAND resname ## USAGE: Chimera --nogui --script \"prep_prot_lig.py 4w52.pdb BNZ\" import chimerafrom DockPrep import prepimport Midasimport sysimport osPDB_file = sys.argv[1] lig_name = sys.argv[2]os.system('grep ATOM %s &gt; %s_clean.pdb'%(PDB_file,PDB_file[:-4]))os.system('grep %s %s &gt; %s.pdb'%(lig_name,PDB_file,lig_name))protein=chimera.openModels.open('%s_clean.pdb'%PDB_file[:-4])ligand=chimera.openModels.open('%s.pdb'%lig_name)prep(protein,addHFunc=None,addCharges=False)prep(ligand)Midas.write(protein,None,\"protein_clean.pdb\")Midas.write(ligand,None,\"ligand_wH.pdb\") 使用脚本:1Chimera --nogui --script \"prep_prot_lig.py 4w52.pdb BNZ\" 生成的 protein_clean.pdb和ligand_wH.pdb将会在随后使用。 1.3 准备配体使用的方法如第2部分，后下载BNZ.gro（坐标文件）与BNZ.itp（拓扑文件） 2 设置Gromacs模拟2.1 结合蛋白配体坐标其Gromacs版本使用的为4.6.5，若使用的为5.x或者2016版本可以具体查看李继存老师翻译的配体蛋白教程的后续命令。差别不大。1pdb2gmx -f protein_clean.pdb -o protein_processed.gro -water spce 两个蛋白的结合可以手动或者使用如下脚本完成:12345678910import syspro_gro = sys.argv[1]lig_gro = sys.argv[2]pro = open(pro_gro,'r').readlines()lig = open(lig_gro,'r').readlines()pro_dat = [line.rstrip() for line in pro]lig_dat = [line.rstrip() for line in lig]tot_num = int(pro_dat[1])+int(lig_dat[1])com_dat = [pro_dat[0],'%5d'%tot_num]+pro_dat[2:-1] + lig_dat[2:-1] + [pro_dat[-1]]for line in com_dat: print line 运行脚本1python combineGro_prot_lig.py protein_processed.gro BNZ.gro &gt; complex.gro 2.2 蛋白配体拓扑结合我们对拓扑文件(topol.top)进行修改。在#include &quot;oplsaa.ff/forcefield.itp&quot;后加上#include &quot;BNZ.itp&quot;行来merge蛋白和配体。在Protein_chain_A 1后加上BNZ 1 2.3 设置MD模拟后面的部分与载脂蛋白模拟部分类似:首先增加水盒子1editconf -f complex.gro -o complex_box.gro -c -d 1.0 -bt cubic 填充水:1genbox -cp complex_box.gro -cs spc216.gro -o complex_box_wSPCE.gro -p topol.top 增加原子:1grompp -f MDP/ions.mdp -c complex_box_wSPCE.gro -p topol.top -o ions.tpr 1genion -s ions.tpr -o complex_box_wSPCE_ions.gro -p topol.top -pname NA -nname CL -nn 8 能量最小化:12grompp -f MDP/em_real.mdp -c complex_box_wSPCE_ions.gro -p topol.top -o em.tprmdrun -v -deffnm em 一般说来，在进行NVT模拟之前，用户需要增加配体的位置限制从而不会在加热过程中使得配体从蛋白中逃逸位置限制1genrestr -f BNZ.gro -o posre_BNZ.itp -fc 1000 1000 1000 上面命令会使得posre_BNZ.itp生成，需要在#include &quot;oplsaa.ff/ions.itp&quot;上增加#include &quot;posre_BNZ.itp&quot;的内容为了让蛋白配体系统一起进行温度计算，需要通过如下命令使得两者成为一个体系1234make_ndx -f em.gro -o index.ndx#选择蛋白和配体选项1|13q 平衡与正式模拟:123456grompp -f nvt.mdp -c em.gro -p topol.top -n index.ndx -o nvt.tprmpirun.lsf mdrun -deffnm nvtgrompp -f npt.mdp -c nvt.gro -p topol.top -n index.ndx -o npt.tprmpirun.lsf mdrun -deffnm nptgrompp -f md.mdp -c npt.gro -p topol.top -n index.ndx -o md.tprmpirun.lsf mdrun -deffnm md 如果对配体为进行限制，那么NVT和NPT平衡设置文件中define = -DPOSRES ; position restrain the protein and ligand需要被移去模拟中用到的mdp文件可以在github上下载:https://github.com/leelasd/ligpargen/tree/master/GMX_LP_MDPS 参考文献: Potential energy functions for atomic-level simulations of water and organic and biomolecular systems. Jorgensen, W. L.; Tirado-Rives, J. Proc. Nat. Acad. Sci. USA 2005, 102, 6665-6670 1.14*CM1A-LBCC: Localized Bond-Charge Corrected CM1A Charges for Condensed-Phase Simulations. Dodda, L. S.; Vilseck, J. Z.; Tirado-Rives, J.; Jorgensen, W. L. J. Phys. Chem. B. DOI:10.1021/acs.jpcb.7b00272 LigParGen web server: An automatic OPLS-AA parameter generator for organic ligands. Nuc. Acids. Res., DOI: 10.1093/nar/gkx312 Storer J W, Giesen D J, Cramer C J, et al. Class IV charge models: a new semiempirical approach in quantum chemistry.[J]. Journal of computer-aided molecular design, 1995, 9(1):87-110.","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"}]},{"title":"GROMACS之水中部分載脂蛋白","slug":"GROMACS之水中部分載脂蛋白","date":"2017-07-11T02:18:51.000Z","updated":"2017-10-28T14:18:18.339Z","comments":true,"path":"670.html","link":"","permalink":"http://kangsgo.com/670.html","excerpt":"","text":"GROMACS之水中部分載脂蛋白本教程来自于李继存老师博客：http://jerkwin.coding.me/GMX/GMXtut-1/#%E6%A6%82%E8%BF%B0特此说明 今天带和大家介绍一下gromacs最简单的教程，这个教程李老师已经组织翻译了一遍，翻译的质量非常高，我仍然炒一遍剩饭主要是想准备把自己所学的温故知新一遍，为了更加快速的进行模拟，我们将两个教程的蛋白进行了替换，即将載脂蛋白替换了溶菌酶，实际上是一样的。 首先看一下GROMACS做MD的一般流程 GROMACS MD一般流程 下载PDB文件首先我们在PDB数据库下载小肽的PDB文件，注意我采用的为jupyter notebook编写，若在终端运行的话无需加out=!{}例如：out=!{“ls”},在终端运行只需要为ls即可 1out=!&#123;\"wget http://www.rcsb.org/pdb/files/1ODQ.pdb\"&#125; 生成蛋白拓扑（Topology文件）在用GROMACS的程序对pdb文件进行处理前, 要做许多检查, 以保证pdb文件的完整性. 根据pdb文件的不同, 要进行不同的处理. 需要处理的方面包括但不限于: -氢原子 -C端氧原子 -结晶水 -缺失原子/残基/侧链 -二硫键 -带电残基 请在进行下一步之前仔细简单是否有错误，如教程蜘蛛肽需要进行末尾蛋白的补全，如删除蛋白中本身含有的结晶水等等工作。在本例中你需要从20个模型中获取单一模型，可以使用例如pymol进行操作。下一步需要注意的是我们需要-ignh进行删除pdb中的氢，然后gmx进行自动加氢。我们将其修改为fws.pdb 1!gmx pdb2gmx -f fws.pdb -ignh -o 1ODQ_processed.gro -water spce 12345678910111213141516171819···· Select the Force Field: From &apos;/usr/share/gromacs/top&apos;: 1: AMBER03 protein, nucleic AMBER94 (Duan et al., J. Comp. Chem. 24, 1999-2012, 2003) 2: AMBER94 force field (Cornell et al., JACS 117, 5179-5197, 1995) 3: AMBER96 protein, nucleic AMBER94 (Kollman et al., Acc. Chem. Res. 29, 461-469, 1996) 4: AMBER99 protein, nucleic AMBER94 (Wang et al., J. Comp. Chem. 21, 1049-1074, 2000) 5: AMBER99SB protein, nucleic AMBER94 (Hornak et al., Proteins 65, 712-725, 2006) 6: AMBER99SB-ILDN protein, nucleic AMBER94 (Lindorff-Larsen et al., Proteins 78, 1950-58, 2010) 7: AMBERGS force field (Garcia &amp; Sanbonmatsu, PNAS 99, 2782-2787, 2002) 8: CHARMM27 all-atom force field (CHARM22 plus CMAP for proteins) 9: GROMOS96 43a1 force field 10: GROMOS96 43a2 force field (improved alkane dihedrals) 11: GROMOS96 45a3 force field (Schuler JCC 2001 22 1205) 12: GROMOS96 53a5 force field (JCC 2004 vol 25 pag 1656) 13: GROMOS96 53a6 force field (JCC 2004 vol 25 pag 1656) 14: GROMOS96 54a7 force field (Eur. Biophys. J. (2011), 40,, 843-856, DOI: 10.1007/s00249-011-0700-9) 15: OPLS-AA/L all-atom force field (2001 aminoacid dihedrals) 力场包含了将要写入到拓扑文件中的信息. 这个选择非常重要! 你必须仔细了解每个力场, 并决定哪个力场最适用于你的体系. 在本教程中, 我们选gromos联合原子力场, 因此在命令提示行中输入14, 然后回车.由于在jupyter中shell交互不是很方便，所以我们采用的是在尾部&lt;&lt;EOF\\n14\\nEOF的方式进行交互，下面的情况类似，不再申明，即大家在实际操作中在shell终端输入前面的命令，后面选择的选项与后面命令类似。 1out=!&#123;\"gmx pdb2gmx -f fws.pdb -ignh -o fws_processed.gro -water spce &lt;&lt;EOF\\n14\\nEOF\"&#125; 定义单位盒子并填充溶剂教程中是需要模拟一个简单的水溶液分子，定义模拟用的盒子并添加溶剂分为两步完成：1.使用editconf模块定义盒子的尺寸2.使用solvate模块想盒子中填充水首先我们来定义盒子，本教程用的正方形盒子，其实盒子种类很多，一般使用菱形十二面体晶胞，其可以节省许多水分子，从而节省计算量。-c表示分子在盒子的中心部分。 1out=!&#123;\"gmx editconf -f fws_processed.gro -o fws_newbox.gro -c -d 1.0 -bt cubic\"&#125; 我们可以在vmd或者pymol中查看分子的情况，在用shell交互中下面块的内容不需要输入，转而使用vmd fws_newbox.gro或者pymol fws_newbox.gro进行查看 12#演示使用，真正进行学习时直接vmd或者pymol查看from IPythonTweaks import * 12#演示使用pymolPlotStructure(\"fws_newbox.gro\") output_11_0.png 之后我们进行溶剂分子的增加 1out=!&#123;\"gmx solvate -cp fws_newbox.gro -cs spc216.gro -o fws_solv.gro -p topol.top\"&#125; 同样我们也可以进行可视化查看 12#演示使用pymolPlotStructure(\"fws_solv.gro\") output_15_0.png 增加离子现在我们已经有了一个带电荷的溶液体系，其实在pdb2gmx程序的输出文件会显示带了多少电荷，如果没有查看到我们可以查看一下topol.top文件中[ atoms ]指令的的最后一行, 它应该含有qtot 0这一信息. 由于生命体系中不存在净电荷, 所以我们必须往我们体系中添加离子, 以保证总电荷为零.虽然电荷为0，我们还是增加一下0个离子，作为演示的作用。首先我们创建一个ions.mdp的文件，并输入如下内容：123456789101112131415; ions.mdp - used as input into grompp to generate ions.tpr; Parameters describing what to do, when to stop and what to saveintegrator = steep ; Algorithm (steep = steepest descent minimization)emtol = 1000.0 ; Stop minimization when the maximum force &lt; 1000.0 kJ/mol/nmemstep = 0.01 ; Energy step sizensteps = 50000 ; Maximum number of (minimization) steps to perform; Parameters describing how to find the neighbors of each atom and how to calculate the interactionsnstlist = 1 ; Frequency to update the neighbor list and long range forcesns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces)coulombtype = PME ; Treatment of long range electrostatic interactionsrcoulomb = 1.0 ; Short-range electrostatic cut-offrvdw = 1.0 ; Short-range Van der Waals cut-offpbc = xyz ; Periodic Boundary Conditions (yes/no) 1234567891011121314151617181920#演示使用file=open(\"ions.mdp\",\"w\")file.write(\"\"\"; ions.mdp - used as input into grompp to generate ions.tpr; Parameters describing what to do, when to stop and what to saveintegrator = steep ; Algorithm (steep = steepest descent minimization)emtol = 1000.0 ; Stop minimization when the maximum force &lt; 1000.0 kJ/mol/nmemstep = 0.01 ; Energy step sizensteps = 50000 ; Maximum number of (minimization) steps to perform; Parameters describing how to find the neighbors of each atom and how to calculate the interactionsnstlist = 1 ; Frequency to update the neighbor list and long range forcesns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces)coulombtype = PME ; Treatment of long range electrostatic interactionsrcoulomb = 1.0 ; Short-range electrostatic cut-offrvdw = 1.0 ; Short-range Van der Waals cut-offpbc = xyz ; Periodic Boundary Conditions (yes/no)\"\"\")file.close() 使用如下命令来产生.tpr文件 12out=!&#123;\"gmx grompp -f ions.mdp -c fws_solv.gro -p topol.top -o ions.tpr\"&#125;out=!&#123;\"gmx genion -s ions.tpr -o fws_solv_ions.gro -p topol.top -pname NA -nname CL -nn 0 &lt;&lt;EOF\\n13\\nEOF\"&#125; 1out 12345678910111213··· &apos;GROMACS: gmx genion, VERSION 5.1.2&apos;, &apos;Executable: /usr/bin/gmx&apos;, &apos;Data prefix: /usr&apos;, &apos;Command line:&apos;, &apos; gmx genion -s ions.tpr -o fws_solv_ions.gro -p topol.top -pname NA -nname CL -nn 0&apos;, &apos;&apos;, &apos;Reading file ions.tpr, VERSION 5.1.2 (single precision)&apos;, &apos;Reading file ions.tpr, VERSION 5.1.2 (single precision)&apos;, &apos;No ions to add, will just copy input configuration.&apos;, &apos;&apos;, &apos;gcq#418: &quot;A curious aspect of the theory of evolution is that everybody thinks he understands it.&quot; (Jacques Monod)&apos;, &apos;&apos;] 能量最小化现在, 我们已经添加了溶剂分子和离子, 得到了一个电中性的体系. 在开始动力学模拟之前, 我们必须保证体系的结构正常, 原子之间的距离不会过近, 几何构型合理. 对结构进行弛豫可以达到这些要求, 这个过程称为能量最小化(EM, energy minimization). 能量最小化过程与添加离子过程差不多. 我们要再次使用grompp将结构, 拓扑和模拟参数写入一个二进制的输入文件中(.tpr), 但这次我们不需要将.tpr文件传递给genion, 而是使用GROMACS MD引擎的mdrun模块来进行能量最小化.能量最小化的mdp文件参数与解释如下：123456789101112131415161718192021; 传递给预处理器的一些定义define = -DFLEXIBLE ; 使用柔性水模型而非刚性模型, 这样最陡下降法可进一步最小化能量; 模拟类型, 结束控制, 输出控制参数integrator = steep ; 指定使用最陡下降法进行能量最小化. 若设为`cg`则使用共轭梯度法emtol = 500.0 ; 若力的最大值小于此值则认为能量最小化收敛(单位kJ mol^-1^ nm^-1^)emstep = 0.01 ; 初始步长(nm)nsteps = 1000 ; 在能量最小化中, 指定最大迭代次数nstenergy = 1 ; 能量写出频率energygrps = System ; 要写出的能量组; 近邻列表, 相互作用计算参数nstlist = 1 ; 更新近邻列表的频率. 1表示每步都更新ns_type = grid ; 近邻列表确定方法(simple或grid)coulombtype = PME ; 计算长程静电的方法. PME为粒子网格Ewald方法, 还可以使用cut-offrlist = 1.0 ; 短程力近邻列表的截断值rcoulomb = 1.0 ; 长程库仑力的截断值vdwtype = cut-off ; 计算范德华作用的方法rvdw = 1.0 ; 范德华距离截断值constraints = none ; 设置模型中使用的约束pbc = xyz ; 3维周期性边界条件 1234567891011121314151617181920#演示使用file=open(\"minim.mdp\",\"w\")file.write(\"\"\"; minim.mdp - used as input into grompp to generate em.tpr; Parameters describing what to do, when to stop and what to saveintegrator = steep ; Algorithm (steep = steepest descent minimization)emtol = 1000.0 ; Stop minimization when the maximum force &lt; 1000.0 kJ/mol/nmemstep = 0.01 ; Energy step sizensteps = 50000 ; Maximum number of (minimization) steps to perform; Parameters describing how to find the neighbors of each atom and how to calculate the interactionsnstlist = 1 ; Frequency to update the neighbor list and long range forcesns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces)coulombtype = PME ; Treatment of long range electrostatic interactionsrcoulomb = 1.0 ; Short-range electrostatic cut-offrvdw = 1.0 ; Short-range Van der Waals cut-offpbc = xyz ; Periodic Boundary Conditions (yes/no)\"\"\")file.close() 1out=!&#123;\"gmx grompp -f minim.mdp -c fws_solv_ions.gro -p topol.top -o em.tpr\"&#125; 1out=!&#123;\"gmx mdrun -v -deffnm em\"&#125; 我们可以使用grace打开查看，若没有安装可以使用sudo apt-get install grace进行安装，为了演示方便我们直接在内部做图 1out=!&#123;\"gmx energy -f em.edr -o energy.xvg&lt;&lt;EOF\\n10\\n0\\nEOF\"&#125; 12345#演示使用fig,ax=plt.subplots()plotXVG(ax,\"energy.xvg\")ppl.legend(ax)plt.show() output_27_0.png NVT平衡EM可保证我们的初始结构在几何构型和溶剂分子取向等方面都合理. 为了开始真正的动力学模拟, 我们必须对蛋白质周围的溶剂和离子进行平衡. 如果我们在这时就尝试进行非限制的动力学模拟, 体系可能会崩溃. 原因在于我们基本上只是优化了溶剂分子自身, 而没有考虑溶质. 我们需要将体系置于设定的模拟温度下, 以确定溶质(蛋白质)的合理取向. 达到正确的温度(基于动能)之后, 我们要对体系施加压力直到它达到合适的密度. 还记得好久以前我们用db2gmx生成的osre.itp文件么? 现在它要派上用场了. posre.itp文件的目的在于对蛋白质中的重原子(非氢原子)施加位置限制(position restraining)力. 这些原子不会移动, 除非增加非常大的能量. 位置限制的用途在于, 我们可以平衡蛋白质周围的溶剂分子, 而不引起蛋白质结构的变化. 平衡往往分两个阶段进行. 第一个阶段在NVT系综(粒子数, 体积和温度都是恒定的)下进行. 这个系综也被称为等温等容系综或正则系综. 这个过程的需要的时间与体系的构成有关, 但在NVT系综中, 体系的温度应达到预期值并基本保持不变. 如果温度仍然没有稳定, 那就需要更多的时间. 通常情况下, 50 ps到100 ps就足够了,为了节约时间，我们仅进行2ps的NVT。nvt.mdp的设置如下：123456789101112131415161718192021222324252627282930313233343536373839404142title = OPLS NVT equilibrationdefine = -DPOSRES ; position restrain the protein; Run parametersintegrator = md ; leap-frog integratornsteps = 1000 ; 2 * 1000 = 2 psdt = 0.002 ; 2 fs; Output controlnstxout = 500 ; save coordinates every 1.0 psnstvout = 500 ; save velocities every 1.0 psnstenergy = 500 ; save energies every 1.0 psnstlog = 500 ; update log file every 1.0 ps; Bond parameterscontinuation = no ; first dynamics runconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verletrcoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is offpcoupl = no ; no pressure coupling in NVT; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = yes ; assign velocities from Maxwell distributiongen_temp = 300 ; temperature for Maxwell distributiongen_seed = -1 ; generate a random seed 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#演示使用file=open('nvt.mdp','w')file.write(\"\"\"title = OPLS NVT equilibrationdefine = -DPOSRES ; position restrain the protein; Run parametersintegrator = md ; leap-frog integratornsteps = 1000 ; 2 * 1000 = 2 psdt = 0.002 ; 2 fs; Output controlnstxout = 500 ; save coordinates every 1.0 psnstvout = 500 ; save velocities every 1.0 psnstenergy = 500 ; save energies every 1.0 psnstlog = 500 ; update log file every 1.0 ps; Bond parameterscontinuation = no ; first dynamics runconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verletrcoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is offpcoupl = no ; no pressure coupling in NVT; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = yes ; assign velocities from Maxwell distributiongen_temp = 300 ; temperature for Maxwell distributiongen_seed = -1 ; generate a random seed\"\"\")file.close() 接下来与能量最小化情况类似 1out=!&#123;\"gmx grompp -f nvt.mdp -c em.gro -p topol.top -o nvt.tpr\"&#125; 1out=!&#123;\"gmx mdrun -v -deffnm nvt\"&#125; 由于模拟的时间比较短，我一会儿就模拟好了让我们来分析温度变化情况, 再次使用energy模块: 1out=!&#123;\"gmx energy -f nvt.edr -o nvt.xvg&lt;&lt;EOF\\n15\\n0\\nEOF\"&#125; 12345#演示使用fig,ax=plt.subplots()plotXVG(ax,\"nvt.xvg\")ppl.legend(ax)plt.show() 由于这里nstxout记录值过大所以只有两个点，应该把值设置更小，从而产生如下结果 前一步的NVT平衡稳定了体系的温度. 在采集数据之前, 我们还需要稳定体系的压力(因此还包括密度). 压力平衡是在NPT系综下进行的, 其中粒子数, 压力和温度都保持不变. 这个系综也被称为等温等压系综, 最接近实验条件.一般建议设置的模拟时长为1ns，但是由于时间关系，这里仅模拟10psnpt.mdp设置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445title = OPLS NPT equilibrationdefine = -DPOSRES ; position restrain the protein; Run parametersintegrator = md ; leap-frog integratornsteps = 5000 ; 2 * 5000 = 10 psdt = 0.002 ; 2 fs; Output controlnstxout = 50 ; save coordinates every 0.1 psnstvout = 50 ; save velocities every 0.1 psnstenergy = 50 ; save energies every 0.1 psnstlog = 500 ; update log file every 1.0 ps; Bond parameterscontinuation = yes ; Restarting after NVTconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verlet schemercoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is onpcoupl = Parrinello-Rahman ; Pressure coupling on in NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1refcoord_scaling = com; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; Velocity generation is off 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#演示使用file=open('npt.mdp','w')file.write(\"\"\"title = OPLS NPT equilibrationdefine = -DPOSRES ; position restrain the protein; Run parametersintegrator = md ; leap-frog integratornsteps = 5000 ; 2 * 5000 = 10 psdt = 0.002 ; 2 fs; Output controlnstxout = 50 ; save coordinates every 0.1 psnstvout = 50 ; save velocities every 0.1 psnstenergy = 50 ; save energies every 0.1 psnstlog = 500 ; update log file every 1.0 ps; Bond parameterscontinuation = yes ; Restarting after NVTconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verlet schemercoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is onpcoupl = Parrinello-Rahman ; Pressure coupling on in NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1refcoord_scaling = com; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; Velocity generation is off\"\"\")file.close() 1out=!&#123;\"gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -p topol.top -o npt.tpr\"&#125; 1out=!&#123;\"gmx mdrun -v -deffnm npt\"&#125; 我们可以通过压力和密度检测来看模拟是否平衡 1234#压力out=!&#123;\"gmx energy -f npt.edr -o pressure.xvg&lt;&lt;EOF\\n16\\n0\\nEOF\"&#125;#密度out=!&#123;\"gmx energy -f npt.edr -o density.xvg&lt;&lt;EOF\\n22\\n0\\nEOF\"&#125; 12345#演示使用fig,ax=plt.subplots()plotXVG(ax,\"pressure.xvg\")ppl.legend(ax)plt.show() output_43_0.png 12345#演示使用fig,ax=plt.subplots()plotXVG(ax,\"density.xvg\")ppl.legend(ax)plt.show() output_44_0.png 成品MD随着两个平衡阶段的完成, 体系已经在需要的温度和压强下平衡好了. 我们现在可以放开位置限制并进行成品MD以收集数据了. 这个过程跟前面的类似. 运行grompp时, 我们还要用到检查点文件(在这种情况下,其中包含了压力耦合信息). 我们要进行一个1 ns的MD模拟, 所用的参数文件如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546title = OPLS MD simulation; Run parametersintegrator = md ; leap-frog integratornsteps = 500000 ; 2 * 500000 = 1000 ps (1 ns)dt = 0.002 ; 2 fs; Output controlnstxout = 5000 ; save coordinates every 10.0 psnstvout = 5000 ; save velocities every 10.0 psnstenergy = 5000 ; save energies every 10.0 psnstlog = 5000 ; update log file every 10.0 psnstxout-compressed = 5000 ; save compressed coordinates every 10.0 ps ; nstxout-compressed replaces nstxtcoutcompressed-x-grps = System ; replaces xtc-grps; Bond parameterscontinuation = yes ; Restarting after NPTconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verlet schemercoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is onpcoupl = Parrinello-Rahman ; Pressure coupling on in NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; Velocity generation is off 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#演示使用file=open('md.mdp','w')file.write(\"\"\"title = OPLS Lysozyme MD simulation; Run parametersintegrator = md ; leap-frog integratornsteps = 500000 ; 2 * 500000 = 1000 ps (1 ns)dt = 0.002 ; 2 fs; Output controlnstxout = 5000 ; save coordinates every 10.0 psnstvout = 5000 ; save velocities every 10.0 psnstenergy = 5000 ; save energies every 10.0 psnstlog = 5000 ; update log file every 10.0 psnstxout-compressed = 5000 ; save compressed coordinates every 10.0 ps ; nstxout-compressed replaces nstxtcoutcompressed-x-grps = System ; replaces xtc-grps; Bond parameterscontinuation = yes ; Restarting after NPTconstraint_algorithm = lincs ; holonomic constraintsconstraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verlet schemercoulomb = 1.0 ; short-range electrostatic cutoff (in nm)rvdw = 1.0 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature coupling is ontcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein Non-Protein ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling is onpcoupl = Parrinello-Rahman ; Pressure coupling on in NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; Velocity generation is off\"\"\")file.close() 1out=!&#123;\"gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md_0_1.tpr\"&#125; 1!gmx mdrun -v -deffnm md_0_1 具体的分析方法与内容我们下次分享","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"非常有用的蛋白质科学工具与项目","slug":"非常有用的蛋白质科学工具与项目","date":"2017-06-21T11:49:23.000Z","updated":"2017-10-29T03:35:43.996Z","comments":true,"path":"665.html","link":"","permalink":"http://kangsgo.com/665.html","excerpt":"","text":"翻译自，github:(2015版) 蛋白配体对接与评价AutoDock 4.2License:free, open-source (GNU GPL) 一个使用相对廉价的”hybrid”力场的分子对接与得分工具，该力场为半经验的方法（molecular mechanics as well as empirical terms）.其预测的绝对结合自由能相较于更大的计算量项目可能精确度较低，但这种半经验方法对于相对得分(ranking)可能更加合适。 虽然AutoDock这种半经验力场被AutoDock Vina这个完整的基于知识的，统计得分函数的软件所替代。同时AutoDock Vina具有更精确和更快的速度。但是AutoDock 4.2 提供了更加详细的输出描述可能对某些应用具有其独有的优势。 网址:http://autodock.scripps.edu/downloads/autodock-registration/autodock-4-2-download-page/ Huey, Ruth, Garrett M. Morris, Arthur J. Olson, and David S. Goodsell. 2007. “A Semiempirical Free Energy Force Field with Charge-Based Desolvation.” Journal of Computational Chemistry 28 (6): 1145–52. doi:10.1002/jcc.20634. 输出例子:123456789101112131415Total Intermolecular Interaction Energy = -3.1862 kcal/molTotal Intermolecular vdW + Hbond + desolv Energy = -0.2499 kcal/molTotal Intermolecular Electrostatic Energy = -2.9362 kcal/molTotal Intermolecular + Intramolecular Energy = -5.6314 kcal/molepdb: USER Estimated Free Energy of Binding = -1.40 kcal/mol [=(1)+(2)+(3)-(4)]epdb: USER Estimated Inhibition Constant, Ki = 94.72 mM (millimolar) [Temperature = 298.15 K]epdb: USER epdb: USER (1) Final Intermolecular Energy = -3.19 kcal/molepdb: USER vdW + Hbond + desolv Energy = -0.25 kcal/molepdb: USER Electrostatic Energy = -2.94 kcal/molepdb: USER (2) Final Total Internal Energy = -2.45 kcal/molepdb: USER (3) Torsional Free Energy = +1.79 kcal/molepdb: USER (4) Unbound System's Energy [=(2)] = -2.45 kcal/mol 版本:1AutoDock 4.2 Release 4.2.5.1 AutoDock VinaLicense: free, open-source (Apache license) 其为AutoDock的蛋白对接与在得分的继承者，其可以评价结合能力以及一些独有的项目，例如疏水贡献以及氢键(PS:译者并未发现有这些功能····) 网站:http://vina.scripps.edu/ O. Trott, A. J. Olson, AutoDock Vina: improving the speed and accuracy of docking with a new scoring function, efficient optimization and multithreading, Journal of Computational Chemistry 31 (2010) 455-461 重新打分用法:1vina --config config.txt --score_only config.txt的例子如下:12345678receptor = protein.pdbqtligand = ligand.pdbqtcenter_x = -2.491 # Center of Grid points Xcenter_y = 30.038 # Center of Grid points Ycenter_z = -10.765 # Center of Grid points Zsize_x = 25 # Number of Grid points in X directionsize_y = 25 # Number of Grid points in Y Directionsize_z = 25 # Number of Grid points in Z Direction 版本:12vina --versionAutoDock Vina 1.1.2 (May 11, 2011) DrugScoreXLicense: free without any limitations (redistribution requires permission) DrugScoreX是一个较新的，对于蛋白配体打分具有比DrugScore更高精度的软件，其打分功能是基于统计势能？(statistical potentials) 网址:http://pc1664.pharmazie.uni-marburg.de/drugscore/ DSX: A Knowledge-Based Scoring Function for the Assessment of Protein–Ligand Complexes Gerd Neudert and Gerhard Klebe Journal of Chemical Information and Modeling 2011 51 (10), 2731-2745 用法:12345678910111213141516dsx_mac_64.mac -h...pro_file : A pdb or mol2 file of your protein. In pdb format metals in this file will be treated as part of the protein. =&gt; Be sure to delete metals in the pdb file if you want to supply some metals seperately (-M met_file)! All other HETATMs will be ignored! In mol2 format everything will be taken as part of the protein. =&gt; Be sure to delete molecules you want to supply seperately (-C, -W, -M) from the protein-mol2-file!lig_file : A mol2- or autodock dlg-file containing all molecules that should be scored. ... 译者注:其可以对金属离子进行打分 例子:译者注:个人觉得作者下载的是mac版本1dsx_mac_64.mac -P protein.pdb -L ligand.mol2 -D pdb_pot_0511 其中pdb_pot_0511在下载文件中:12345dsx/ ACC_DON_AnD_HYD_ARO_map.def mac64/ # directory that contains the binaries README.txt pdb_pot_0511/ # potentials LigScoreLicense: free, open-source (GNU GPL) 与DrugScore的算法类似,提供本地(IMP 工具包)以及在线服务。其得分功能具有两种”口味”,RankScore，推荐被用于不同配体在蛋白结合界面的评分(例如虚拟筛选);PoseScore，在设置的一系列配体叠代中寻找优化的结合构象(例如相同的具有不同方向或者构象的配体) 网址:http://salilab.org/imp/在线网址:http://modbase.compbio.ucsf.edu/ligscore/ Fan H, Schneidman-Duhovny D, Irwin J, Dong GQ, Shoichet B, Sali A. Statistical Potential for Modeling and Ranking of Protein-Ligand Interactions. J Chem Inf Model. 2011, 51:3078-92. 使用:12ligand_score -hUsage: ligand_score file.mol2 file.pdb [libfile] 其中protein_ligand_pose_score.lib 用来PoseScore打分，protein_ligand_rank_score.lib用来RankScore打分。 示例:1ligand_score my.mol2 my.pdb /usr/local/share/IMP/atom/protein_ligand_pose_score.lib DOCK 6 Amber ScoreLicense: Available free of charge for academic institutions, but there is a licensing fee for industrial organizations. DOCK 6 是一个对接工具提供了几种打分函数，其可以用来对已经对接的构象进行再打分。下面是一个如何在打分的例子:1234567891011121314dock6 -h--------------------------------------DOCK v6.7Released February 2015Copyright UCSF--------------------------------------Usage: dock6 -i filename.in [-o filename.out] [-v] 例子:Amber 打分对蛋白配体复合物进行最小化，分子动力学模拟，能量最小化，更详细的计算方法可以查看:http://dock.compbio.ucsf.edu/DOCK_6/tutorials/amber_score/amber_score.htm 下面这个例子，我们假设一次已经进行了蛋白配体处理，例如:我们在蛋白PDB文件中移除了配体，金属离子和水分子，并且将组氨酸残基进行了正确的质子化。1prepare_amber.pl lig.mol2 1a9x.pdb 接下来我们创建如下的dock.in文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445ligand_atom_file lig.amber_score.mol2limit_max_ligands noskip_molecule noread_mol_solvation nocalculate_rmsd nouse_database_filter noorient_ligand nouse_internal_energy noflexible_ligand nobump_filter noscore_molecules yescontact_score_primary nocontact_score_secondary nogrid_score_primary nogrid_score_secondary nomultigrid_score_primary nomultigrid_score_secondary nodock3.5_score_primary nodock3.5_score_secondary nocontinuous_score_primary nocontinuous_score_secondary nodescriptor_score_primary nodescriptor_score_secondary nogbsa_zou_score_primary nogbsa_zou_score_secondary nogbsa_hawkins_score_primary nogbsa_hawkins_score_secondary noSASA_descriptor_score_primary noSASA_descriptor_score_secondary noamber_score_primary yesamber_score_secondary noamber_score_receptor_file_prefix 1a9xamber_score_movable_region ligandamber_score_minimization_rmsgrad 0.01amber_score_before_md_minimization_cycles 100amber_score_md_steps 3000amber_score_after_md_minimization_cycles 100amber_score_gb_model 5amber_score_nonbonded_cutoff 18.0amber_score_temperature 300.0amber_score_abort_on_unprepped_ligand yesligand_outfile_prefix outputwrite_orientations nonum_scored_conformers 1rank_ligands no 最后步骤，我们执行dock6读取dock.in文件1dock6 -i dock.in &gt; dock.out 在dock.out文件，我们可以找到Amber 得分:1234567891011121314151617[...]Molecule: *****Elapsed time for docking: 34 secondsAnchors: 1Orientations: 1Conformations: 1Amber Score: -19.431744 complex: 50250.946122 receptor: -50307.949484 ligand: 37.5716191 Molecules ProcessedTotal elapsed time: 41 seconds 蛋白文件和结构处理OpenBabelLicense: free, open-source (GNU GPL) 一个格式转换工具，具有本地编译包和多种语言的API 网站:http://openbabel.org/ O’Boyle, Noel M., Michael Banck, Craig A. James, Chris Morley, Tim Vandermeersch, and Geoffrey R. Hutchison. “Open Babel: An Open Chemical Toolbox.” J Cheminf 3 (2011): 33. 使用:1234babel -HOpen Babel converts chemical structures from one file format to anotherUsage: babel &lt;input spec&gt; &lt;output spec&gt; [Options] 例子:1babel -i mol2 my.mol2 -o pdbqt my.pdbqt 版本:123babelNo output file or format spec!Open Babel 2.3.1 -- Oct 13 2011 -- 15:14:47 ReduceLicense: free, but no particular license provided 一个加氢删氢的命令行工具，仅支持PDB格式 网站:http://kinemage.biochem.duke.edu/software/reduce.php Word, et al.(1999) “Asparagine and glutamine: using hydrogen atom contacts in the choice of sidechain amide orientation” J. Mol. Biol. 285, 1735-1747. 使用:1234567891011121314151617181920212223~/Desktop &gt;./reduce -hreduce: version 3.23 05/21/2013, Copyright 1997-2013, J. Michael Wordreduce.3.23.130521arguments: [-flags] filename or -Suggested usage:reduce -FLIP myfile.pdb &gt; myfileFH.pdb (do NQH-flips)reduce -NOFLIP myfile.pdb &gt; myfileH.pdb (do NOT do NQH-flips)Flags:-FLIP add H and rotate and flip NQH groups-NOFLIP add H and rotate groups with no NQH flips-Trim remove (rather than add) hydrogens-NUClear use nuclear X-H distances rather than default electron cloud distances-NOOH remove hydrogens on OH and SH groups-OH add hydrogens on OH and SH groups (default)-HIS create NH hydrogens on HIS rings-FLIPs allow complete ASN, GLN and HIS sidechains to flip (usually used with -HIS)... 版本:12reduce -vreduce.3.23.130521 配体结构由于配体结构原文中主要是介绍的OpenEye，这个要求，所以就不 翻译了。 晶体结构分析PyWater一个寻找保守水分子的Pymol插件 文档与代码:https://github.com/hiteshpatel379/PyWATER 质谱?(Mass Spectrometry)ProteoWizard一个蛋白质组学分析的图形化和命令行分析工具网站:http://proteowizard.sourceforge.net/index.shtml OpenMS一个LC/MS数据管理和分析C++工具包网站:http://open-ms.sourceforge.net/Marc Sturm, Andreas Bertsch, Clemens Gröpl, Andreas Hildebrandt, Rene Hussong, Eva Lange, Nico Pfeifer, Ole Schulz-Trieglaff, Alexandra Zerck, Knut Reinert, and Oliver Kohlbacher, 2008. “OpenMS – an Open-Source Software Framework for Mass Spectrometry” BMC Bioinformatics 9: 163. doi:10.1186/1471-2105-9-163. （开发）库BiopythonLicense: free, open-source (very permissive custom license)一个Python工具包网站:http://biopython.org/wiki/Main_Page中文文档:http://biopython-cn.readthedocs.io/zh_CN/latest/ scikit-bioLicense: free, open-source (BSD)一个提供多种生物科学功能，数据结构和算法的Python包网站:http://scikit-bio.org/","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[]},{"title":"Rosetta从头结构预测","slug":"Rosetta从头结构预测","date":"2017-06-20T08:58:30.000Z","updated":"2017-10-28T03:43:34.266Z","comments":true,"path":"657.html","link":"","permalink":"http://kangsgo.com/657.html","excerpt":"","text":"此文档不完全翻译自官方从头预测文档当蛋白与已知解析蛋白结构为低相似性的时候从头预测变得非常有用。在从头预测算法中，蛋白序列在 n-mer 片段文库中进行phi/psi角采样来进行构象的扩展（extended conformation）和“折叠”。当整个蛋白质氨基酸残基数小于100以内时，其结果较为精确。 官方有Rosetta@home计划的在线服务器，可以直接提交序列，然后在线服务器进行计算，但每个帐号只能计算一条序列，且要注意的是不能进行已知序列或者高相似度序列的计算，否则会ban ip，删号。因为从头结构预测时间太久太长。官方地址如下：http://robetta.bakerlab.org/网站截图如下： 网站截图 该项目是伯克利分校搞的一个分布式系统项目BOINC，若你也想加入这个计算可以具体查看这一篇教程。想与各位探讨的是个人觉得若单独拿一段序列进行从头计算然后拼接进模型中是不准确的，更好的方法是进行loop环的补全（若缺失部分为loop环），或者进行分子动力学模拟来预测。官方的从头预测方法是采用的T4 溶菌酶（噬菌体中）的序列来进行的蛋白结构预测。并于解析了结构的蛋白PDB文件进行比较。 图文无关，纯粹好看 ###1.准备输入文件 需要： fasta格式的序列 9mer 片段文件 3mer 片段文件 已知的pdb文件 1.保存蛋白序列文件为FASTA格式例如： 12&gt;2LZMA ITKDEAEKLFNQDVDAAVRGILRNAKLKPVYDSLDAVRRCALINMVFQMGETGVAGFTNSLRMLQQKRWDEAAVNLAKSRWYNQTPNRAKRVITTFRTGTWDAYKNL 2.准备片段文件。这些片段文件包含短的骨架碎片，在模拟期间其将会随机插入在所有位置。教程中提供了一些片段文件：12input_files/aa2LZMA03_05.200_v1_3 (3mer fragments)input_files/aa2LZMA09_05.200_v1_3 (9mer fragments) 这个片段文件生成较为复杂，需要用perl脚本和库文件，安装许多包才能实现，我也还没有完全搞透，由于时间关系，搞透以后作为补充分享给大家。并且搞透的意义不大，毕竟也不是做这个的。建议大家还是用上面的网站的Fragment Libraries进行在线制作。 ####3.为了与已知文件进行比较分析结果准确度，所以插入已知文件,当然这个不是必须的。 1input_files/2LZMA.pdb 由于option文件设置较多，我们分开来讲解。首先是输入文件设置 123456-in-file-native input_files/2LZMA.pdb-fasta input_files/2LZMA.fasta-frag3 input_files/aa2LZMA03_05.200_v1_3-frag9 input_files/aa2LZMA09_05.200_v1_3 这个没有什么好说的，接下来是建模设置 123456-abinitio-relax-increase_cycles 10-rg_reweight 0.5-rsd_wt_helix 0.5-rsd_wt_loop 0.5 increase_cycles表示AbinitioRelax 循环的次数，若想快速完成可以设置为0.1,后面三个参数分别为回转半径，螺旋和环赋予的权重，没有深入了解一般默认即可然后是relax设置，若想快速完成该步可以不设置 12-relax-fast -fast设置表示在建模后对蛋白进行一个FastRelax，其同时兼容了准确性和速度。最后是输出 12345678-out-pdb-nstruct 1-file-scorefile score.sc-overwrite-nstruct 1 官方教程设置了两次-nstruct，原因待考。 2.运行Rosetta AbinitioRelax 应用1$&gt; ../../../main/source/bin/AbinitioRelax.default.linuxclangrelease @input_files/options 当然也可以在后台运行: 1$ nohup ../../../main/source/bin/ AbinitioRelax.default.linuxclangrelease @input_files/options &gt; log &amp; 每个结构约运行10-20分钟没有错误的话将会输出如下结果： S_00000001.pdb (生成的模型)score.sc (展示得分，Rosetta的得分算法将会在后期介绍)为了得到精确的结果，建议生成50,000到100,000个模型（官方教程中一说至少1,000） 3.分析结果3.1 绘制得分图和rmsd图你可以绘制得分最好的5%或10%的模型图。total_score和rms数据都在score文件中提供。你可以使用同源蛋白做参考（毕竟有pdb数据的话就不用从头建模了）如果连同源结构都没有的话一般考虑最低能量模型。可以用awk简单的提取数据 1$ sort -n -k2 score.sc | head -n 5000 | awk &apos;&#123;print $25 &quot;\\t&quot; $2&#125;&apos; &gt; score_rmsd.dat 然后可以对数据进行绘图，绘图的方法多种，也非常简单，后期会完整介绍。 左图可以发现rmsd与score成相关性并且收敛，而右侧没有收敛，说明右侧的结果并不那么可靠 3.2 提取模型获得的结果中有一个二进制silent file（此要在设置中设置，这样生成的模型都压缩在一个文件中，可以节省空间更加美观，其实也可以不对其进行这个操作，详见Rosetta silent file一章）我们可以从中提取pdb文件，例如我们想提取得分最好的5个文件。 1$ sort -n -k2 score.sc | head -l 5 将会获得模型的名称，将silent file对这些模型名称进行提取即可。 1$ ../../../main/source/bin/extract_pdbs.default.linuxgccrelease -in:file:silent_struct_type binary -in:file:silent AbRelax.out -in:file:tags 好的Rosetta得分并不代表结构就一定是好的，所以我们在进行任何分子模拟的时候一定要有许多辅助的实验验证，这样的结果才可是可靠的可信的。我们需要不断的提醒自己。结果可信吗！","categories":[{"name":"蛋白建模","slug":"蛋白建模","permalink":"http://kangsgo.com/categories/蛋白建模/"}],"tags":[{"name":"Rosetta","slug":"Rosetta","permalink":"http://kangsgo.com/tags/Rosetta/"}]},{"title":"Rosetta蛋白蛋白对接","slug":"Rosetta蛋白蛋白对接","date":"2017-06-13T03:08:23.000Z","updated":"2017-10-28T03:39:11.650Z","comments":true,"path":"647.html","link":"","permalink":"http://kangsgo.com/647.html","excerpt":"","text":"蛋白蛋白对接一直是分子模拟中非常重要同时非常难解决的话题，相较于小分子蛋白之间的联系，蛋白蛋白对接如今更加不成熟，在蛋白蛋白对接之前，最好能够搜集更多的文献进行支持，让模拟的结果不空洞，才能保证对接的准确性。 蛋白蛋白对接如今比较著名的软件有Hex Protein Docking，ZDock，rDock，以及Rosetta等等。其中Hex Protein Docking虽算法比较复杂，但没有评分功能（PS：可能是我没有找到···），ZDock一般作为前期的初对接，rDock为ZDock的升级算法，一般将ZDock对接后的前几个得分构象使用rDock进行进一步对接。但是这个三个算法的准确度本人均保持怀疑态度。今天想和大家分享的为Rosetta的蛋白蛋白对接模块，我对Baker课题组还是有非常盲目的崇拜的^_^本教程翻译不完全翻译自官方蛋白蛋白对接文档。 概括Rosetta可以从两个未结合蛋白开始来预测结合结构。Rosetta蛋白蛋白对接教程主要内容为: 怎样准备对接结构 怎样进行两个蛋白的局部对接 怎样优化已经对接的结构 怎样对接结合界面未知的两个蛋白质 怎样对接柔性蛋白 怎样将柔性肽对接到蛋白 Rosetta中进行对接Rosetta中进行对接包含两个步骤。第一步，进行积极（aggresive）采样，方法使用的质心模型。第二步采用全原子模型进行小范围的优化。（PS：质心模型相较于全原子模型保留蛋白主链原子，而侧链原子采用不同大小的单一赝原子表示，如图1） 它会在内部使用跳跃连接两个链的中心，沿着跳跃两条链被拉在了一起（滑动联系 slide into contact）。算法为折叠树算法，是一种优化移动的方法，Rosetta在能量最小化中也有使用。这里不作探讨，也不会影响使用。算法还是使用Baker课题组特别喜欢的Monte Carlo随机算法进行计算如下内容： 平移（x,y,z方向） 旋转（围绕x,y,z轴）默认情况下对接工具采用的为一个刚性骨架，仅能够旋转，平移和侧链packing（我理解为侧链优化，见侧链优化一章）,详细的描述可以查看Rosetta对接一章 演示导航演示可以在安装文件的$ROSETTA3/demos/tutorials/Protein-Protein-Docking中查看，ROSETTA3为安装路径更目录，具体可查看Rosetta安装一章。 对接前结构准备Rosetta给的例子为Colicin-D与其抑制剂IMM之间的对接。需要提供两个精炼的输入文件COL_D.pdb和IMM_D.pdb文件，以及1v74.pdb文件在input_files文件夹下准备的方法详细可以查看输入和输出一章的准备结构一节，为了连续性这里做简单介绍。若模型为同源建模等方法进行构建，可以首先进行一个结构的relax,当然也可以用其他软件进行制作。详细的relax方法我们后面详细分享。在此略过，若您的模型为同源建模等进行的，模型评价效果不理想可以采用GROMACS等软件进行能量最小化的工作。若模型质量佳或为解析结构，结构准备更多的是为了将输入结构转化为Rosetta的标准规范，官网给了一个简单的例子：path_to_Rosetta_directory&amp;gt;/demos/tutorials/input_and_output/flag_input_relax当然结构的准备是非常玄学的东西，最好能够系统的学习同时加上大量的文献阅读增加准确性。 1234567891011-nstruct 2-relax:constrain_relax_to_start_coords-relax:ramp_constraints false-ex1-ex2-use_input_sc-flip_HNQ-no_optH false 使用更多的nstruct可以提高模型结果的质量，如nstruct 10将会获得10个模型。constrain_relax_to_start_coords将会约束重原子，从而是的骨架较初始不会移动太多。ramp_constraints false表示不进行倾斜约束（PS：官方文档上有说明进行整体约束该选项需要设置为false）flip_HNQ在氢键原子位置优化期间考虑翻转HIS，ASN，GLN。no_optH表示是否在PDB加载期间进行氢原子位置优化.一般后面5个设置为基本设置，详见准备结构一章然后进行运行： 1$ROSETTA3/bin/relax.default.linuxgccrelease -in:file:s input_files/from_rcsb/1qys.pdb @flag_input_relax &nbsp; 当然可以附加ignore_unrecognized_res在设置中从而删除PDB中的水和配体（当然也可以手动删除） 局部对接Rosetta在局部对接中有更加精确的结果，顾名思义，局部对接就是假设已知两个蛋白的结合（口袋）区域。首先我们需要将两个蛋白结合口袋大致的对着对方约10埃的位置，如下图: 我们进行如下的设置： 12-partners A_B-dock_pert 3 8 以上这两个设置分别表示i):链B对接进入链A； ii）在开始单独的模拟之前随机的将配体（链B）进行一个3埃的平移和8度的旋转。若为对接的多链蛋白（如一个蛋白为链A和B，一个为链L和H）那么设置为-partners LH_AB即可。若我们同时想和1v74.pdb进行计算比较。完整的参数为： 1234567891011121314-in:file:s input_files/col_complex.pdb-in:file:native input_files/1v74.pdb-unboundrot input_files/col_complex.pdb-nstruct 1-partners A_B-dock_pert 3 8-ex1-ex2aro-out:path:all output_files-out:suffix _local_dock 然后我们进行对接： 1$ROSETTA3/main/source/bin/docking_protocol.linuxgccrelease @flag_local_docking 大约1min即可完成，请确保-nstruct 500或者更大的设置 局部优化对接结构一些小的冲突可能导致蛋白对接的得分非常高（越小越好），在Relax之前我们需要对界面处进行一定的修复。因为已经对接完成，我们需要避免大的蛋白移动。所以我们跳过之前的第一步（质心步骤）而仅进行第二部分计算。我们替换局部对接的flags: 12-docking_local_refine-use_input_sc 我们用此来完善1v74.pdb完整的设置为: 12345678910111213-in:file:s input_files/1v74.pdb-nstruct 1-docking_local_refine-use_input_sc-ex1-ex2aro-out:file:fullatom-out:path:all output_files-out:suffix _local_refine 对接命令 1$ROSETTA3/main/source/bin/docking_protocol.linuxgccrelease @flag_local_refine 然后可以对结构进行relax进一步优化，也可以用其他软件进行能量最小化，在此不进行进一步探讨了。 全局对接官方教程称之为Global Docking，有语言基础的对Global词的翻译应该非常熟悉，一般翻译为全局的意思。如果没有蛋白结合位点的信息的话只能使用全局对接，全局对接假设蛋白质为球型，而更小的蛋白质配体围绕蛋白质受体寻转，其原理个人理解与rDock双球对接类似。因为其随机起始位置，故输入的结构位置显得不是那么重要。 全局对接对小复合物相对较好（残基数小于450）在全局对接中我们添加以下设置 123-spin-randomize1-randomize2 整体的设置如下： 1234567891011121314151617-in:file:s input_files/col_complex.pdb-in:file:native input_files/1v74.pdb-unboundrot input_files/col_complex.pdb-nstruct 1-partners A_B-dock_pert 3 8-spin-randomize1-randomize2-ex1-ex2aro-out:path:all output_files-out:suffix _global_dock 我们同样采用的之前的复合物，然后使用命令进行对接: 1$ROSETTA3/main/source/bin/docking_protocol.linuxgccrelease @flag_global_docking 采样样本量更加大，故为了得到精确的结果，需要大量的运行，一般高达10,000-100,000次 另一种方法为使用ClusPro进行预对接确定结合口袋然后再运行局部对接。 柔性蛋白对接正如之前所提到的，Rosetta假设蛋白骨架为柔性的进行对接。其假设蛋白蛋白结合过程前后构象发生了较大的变化，我们对蛋白构象簇（ensembles ）进行对接。而不是像之前一般一个配体构象和一个受体构象。在蛋白对接第一步（质心步骤）我们在构象簇中不断的变化着来进行对接。这样可以相当于固定骨架与多个骨架之前进行采样。这个簇可以使用无约束的relax进行完成。对于这个教程我们使用小簇- 3 COL_D 和 3 IMM_D构象。在设置其为输入文件之前要确认链名和残基数量每个簇中都一样。簇的设置类似如下： 123input_files/COL_D_ensemble/COL_D_0001.pdbinput_files/COL_D_ensemble/COL_D_0002.pdbinput_files/COL_D_ensemble/COL_D_0003.pdb IMM_D_ensembel情况类似，然后将下列内容添加至之前的局部对接中 12-ensemble1 COL_D_ensemblelist-ensemble2 IMM_D_ensemblelist -ensemble必须包含蛋白质PDB列表。即使有一个蛋白只有一个构象，两个ensemble也都要申明。具体设置为： 1234567891011121314151617-in:file:s input_files/col_complex.pdb-in:file:native input_files/1v74.pdb-unboundrot input_files/col_complex.pdb-nstruct 1-partners A_B-dock_pert 3 8-ensemble1 COL_D_ensemblelist-ensemble2 IMM_D_ensemblelist-ex1-ex2aro-out:path:all output_files-out:suffix _ensemble_dock 在对接之前我们还要进行一步前处理（prepacking）。前处理可以消除由于构象异构体而产生的不同能量贡献，其设置与对接类似类似，仅仅删除-dock_pert设置.其大约运行30s，将会得到prepacked PDBs文件，以及规范化的质心得分和全原子得分，如下： 123456789input_files/COL_D_ensemble/COL_D_0001.pdb.ppkinput_files/COL_D_ensemble/COL_D_0002.pdb.ppkinput_files/COL_D_ensemble/COL_D_0003.pdb.ppk0.7705801.00377-93.3588-94.2715-93.9065 注意的是如果你需要进行再次的前处理，需要删除COL_D_ensemblelist和IMM_D_ensemblelist，否则可能会报错。前处理后再进行对接命令 1$ROSETTA3/main/source/bin/docking_protocol.linuxgccrelease @flag_ensemble_docking 官方文档建议使用较大的簇（25到100）个构象，-nstruc 5000或者更多。","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Rosetta","slug":"Rosetta","permalink":"http://kangsgo.com/tags/Rosetta/"}]},{"title":"原创蛋白配体分割工具","slug":"原创蛋白配体分割工具","date":"2017-06-01T10:26:33.000Z","updated":"2017-10-29T03:29:05.551Z","comments":true,"path":"639.html","link":"","permalink":"http://kangsgo.com/639.html","excerpt":"","text":"我们用Gooey制作了一个蛋白配体分割工具。用以切割Pymol中保存的Autodock Vina对接结果。 工具下载地址: https://pan.baidu.com/s/1jIzGh2A 密码: kwg2 我们用Pymol插件中的Autodock Vina对接,对接完后在Pymol中将蛋白配体结果全部保存，保存以后问题来了，我们如何进行分析和后续处理呢？比较简单的方法为进行手动切割，如图: 蛋白pdb中每一个配体均用TER\\s+\\d{3}\\s+\\W{3}\\s的方式进行切割，所以我们仅需把最前面的蛋白提取，然后依次提取一段以TER分割的配体进去，比较麻烦。 另外我们不仅仅只使用Autodock Vina进行对接，可能还用到iGEMDOK（将在后期介绍）等对接软件进行对接。但是Pymol保存的Autodock Vina对接的结果中配体并无标识，这不利于后续分析。同时并没有HET蛋白配体标识，导致iGEMDOCK在内的对接软件无法定位。 比较基础的方法既手动修改，比如第一行ATOM 3186 N7 0修改为:ATOM 3186 N7 LIG D 999,稍微高级一点可以使用正则进行匹配。这里不做详细介绍了。最近采用Python+Gooey快速制作了一个蛋白配体分割工具。界面如图： 使用方法非常简单简便，用管理员身份打开软件。filename输入需要切割的pdb文件，右侧标签输入配体需要标记的标签，默认为LIG，最好使用三字母以免出错。然后start，最后结果如下图: 结果会以数字.pdb编号在软件运行目录下。以下为完整教程: 非常简单方便","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/tags/Python/"},{"name":"iGEMDOCK","slug":"iGEMDOCK","permalink":"http://kangsgo.com/tags/iGEMDOCK/"}]},{"title":"分子对接软件iGEMDOCK简单介绍","slug":"分子对接软件iGEMDOCK简单介绍","date":"2017-06-01T10:18:46.000Z","updated":"2017-10-29T03:22:54.422Z","comments":true,"path":"625.html","link":"","permalink":"http://kangsgo.com/625.html","excerpt":"","text":"iGEMDOCK是一个台湾产的分子对接软件，其优势是简单易用，对接准确度较高，可以用于初筛和精度对接，也可用于金属对接（注：未试）。最后更新为2008年，但对接软件近几年发展缓慢，基本没有什么新的算法产生。其完整手册可从次下载：点我下载官方下载地址：点我进入 1.安装windows直接打开即可 linux赋权 1chmod 755 iGemdock/bin/* 执行脚本 12cd iGemdock/bin/.iGemdock.sh 2.界面简单介绍其界面主要有四个模块，如图 A为主界面，B为对接设置界面，C为界面简单分析界面，D为查看界面（PS：其自带的分析查看界面太丑了，建议用别的软件查看） 其主要对接流程图如下： 3.受体准备iGEMdock定义结合腔不怎么好定义，虽然提供了一个swiss-viewer方法但是个人觉得不好用。若你是AutoDock 转来的朋友，可以将之前的结果用之前文章使用的蛋白配体切割器进行切割优化。如果是复合物晶体结构也可以直接使用**。如果无法使用，可打开pdb文件，查找是否有HET标签，若没有加上HET+配体名字+链+编号（具体可查看蛋白配体切割器那一章）iGEMDOCK会读取ATOM标签和HETATM标签，所以重要的在活性腔中的水原子可以保留，使得对接结果可能更精确（注：个人觉得也不一定，水是动态的说，可能适得其反），如下是一个复杂受体例子： 为了区分一般原子和配体原子，需要在81位标记P作为一般特异性原子的标识。后打开Prepare Binding Site按钮 3. 配体准备支持PDB，MOL和MOL2三种格式。点击Prepare Compounds即可使用 4.运行iGEMDOCK主要设置对接的精确度和速度，如果做筛选就选快速对接，如果单个配体可以采用精确对接。 如上图最终会生成1个结构文件，而这个结构是70次GA计算后的结果。（？类似最陡梯度法？）对接完后结构文件都会在docked_pose文件夹，最好的在best_pose文件夹,fitness.txt为预测pose的能量清单 5.注意事项若需要进行用这个软件对接推荐还是完整的看一下文档内容。这里做一些注意事项iGEMdock自己不能进行自动的扭转键设置，设置主要来自于SINGLE标签标记，如下: 事项 对接后的结果标记氢键 (H), 电荷能 (E) 和范德瓦尔力 (V)，其余的可以查看原始参考文献Proteins, vol. 55, pp. 288-304, 2004其有一张图详细介绍了联系类型，我觉得解释的很棒很直观： 分析结果界面如下： 还有成簇分析等等功能，具体可以查看文档文件26页。","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"iGEMDOCK","slug":"iGEMDOCK","permalink":"http://kangsgo.com/tags/iGEMDOCK/"}]},{"title":"TDD 根据PDB寻找疾病，靶点，相应治疗药物网站","slug":"TDD 根据PDB寻找疾病，靶点，相应治疗药物网站","date":"2017-05-04T14:52:20.000Z","updated":"2017-11-12T07:39:06.939Z","comments":true,"path":"597.html","link":"","permalink":"http://kangsgo.com/597.html","excerpt":"","text":"为bioms群-汕大洪 提供 还没有细看，待研究 http://www.dddc.ac.cn/pdtd/index.php","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"药物数据库","slug":"药物数据库","permalink":"http://kangsgo.com/tags/药物数据库/"}]},{"title":"计算氨基酸残基保守性工具","slug":"计算氨基酸残基保守性工具","date":"2017-04-26T07:53:01.000Z","updated":"2017-10-29T02:49:53.260Z","comments":true,"path":"593.html","link":"","permalink":"http://kangsgo.com/593.html","excerpt":"","text":"这个是帮师妹写的一个用于处理clusta序列比对的处理脚本，对序列比对的结果进行处理，统计出所有位置上对应的氨基酸残基种类数目，从而得出哪些位置为保守的，哪些位置为不保守的（种类数目越多，认为是不保守位置） 使用方法如下: 123456789101112Usage: aln.py [options] argOptions: -h, --help show this help message and exit -n NUMPROTEIN, --num=NUMPROTEIN 设置序列比对中蛋白数量 -p PARAGRAPH, --paragraph=PARAGRAPH 设置一共有多少段内容 -f PATHFILE, --file=PATHFILE 设置读入文件路径 -s SAVEFILE, --save=SAVEFILE 设置保存文件名 例如: 1python .\\aln.py -n 100 -p 16 -f .\\seqdump.aln -s .\\save.csv 结果可用统计软件进行处理 脚本下载: aln","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"Gromacs CUDA版一键安装脚本","slug":"Gromacs CUDA版一键安装脚本","date":"2017-03-31T10:26:12.000Z","updated":"2017-10-28T15:02:00.799Z","comments":true,"path":"577.html","link":"","permalink":"http://kangsgo.com/577.html","excerpt":"","text":"最新版本:1.01beta 更新时间 2017/10/8 使用方法:将解压后的脚本放置于主文件夹（home主目录） 12chomd +x gromacs.sh./gromacs.sh 适用于系统:ubuntu 14.04和 16.04可选择安装的gmx版本: 1.gromacs2016版本 2.gromacs5.1.X版本 3.gromacs5.0.X版本 如有问题可以bioms群联系:西南交大-小康（可能改名为湖大-小康）或者邮箱:347657442#qq.com点我下载:gromacs","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"中医证型关联规则挖掘错误解决办法","slug":"中医证型关联规则挖掘错误解决办法","date":"2017-02-17T10:29:44.000Z","updated":"2017-10-29T03:14:07.092Z","comments":true,"path":"570.html","link":"","permalink":"http://kangsgo.com/570.html","excerpt":"","text":"最近在读Python数据分析与挖掘实战发现《中医证型关联规则挖掘》中Apriori关联规则 通过百度发现来自苏剑林《用Pandas实现高效的Apriori算法》一文，书中代码 123456789101112131415161718192021222324252627#-*- coding: utf-8 -*-from __future__ import print_functionimport pandas as pdfrom apriori import * #导入自行编写的apriori函数import time #导入时间库用来计算用时inputfile = '../data/apriori.txt' #输入事务集文件data = pd.read_csv(inputfile, header=None, dtype = object)start = time.clock() #计时开始print(u'\\n转换原始数据至0-1矩阵...')ct = lambda x : pd.Series(1, index = x) #转换0-1矩阵的过渡函数b = map(ct, data.as_matrix()) #用map方式执行data = pd.DataFrame(b).fillna(0) #实现矩阵转换，空值用0填充end = time.clock() #计时结束print(u'\\n转换完毕，用时：%0.2f秒' %(end-start))del b #删除中间变量b，节省内存support = 0.06 #最小支持度confidence = 0.75 #最小置信度ms = '---' #连接符，默认'--'，用来区分不同元素，如A--B。需要保证原始表格中不含有该字符start = time.clock() #计时开始print(u'\\n开始搜索关联规则...')find_rule(data, support, confidence, ms)end = time.clock() #计时结束print(u'\\n搜索完成，用时：%0.2f秒' %(end-start)) 其中data = pd.DataFrame(b).fillna(0)会出现无法迭代的错误出现，查看原文是map后需要list转换成列表模型，才可以迭代，故应该更正为data = pd.DataFrame(list(b)).fillna(0) 特别记录给后来人方便 开始以为本书是抄袭，后来发现博主就是作者之一，造成的负面影响非常抱歉","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://kangsgo.com/categories/数据挖掘/"}],"tags":[]},{"title":"Modeller同源建模简单教程","slug":"Modeller同源建模简单教程","date":"2017-02-14T13:31:34.000Z","updated":"2017-10-28T03:55:10.510Z","comments":true,"path":"566.html","link":"","permalink":"http://kangsgo.com/566.html","excerpt":"视频如下，同时也可以进入优酷查看 优酷地址：点我进入","text":"视频如下，同时也可以进入优酷查看 优酷地址：点我进入","categories":[{"name":"同源建模","slug":"同源建模","permalink":"http://kangsgo.com/categories/同源建模/"}],"tags":[{"name":"Modeller","slug":"Modeller","permalink":"http://kangsgo.com/tags/Modeller/"}]},{"title":"PharmMapper:一个药效团匹配与潜在识别靶标在线平台","slug":"PharmMapper统计学方法对潜在药效靶标鉴定","date":"2017-02-02T04:27:23.000Z","updated":"2017-12-02T06:16:56.781Z","comments":true,"path":"12.html","link":"","permalink":"http://kangsgo.com/12.html","excerpt":"","text":"Pharmmapper算是一个非常知名的由华东理工大学开发与维护的药效团匹配与潜在识别靶标平台，开始以为对自己的课题很有用，但是仔细研究发现可能自己的课题用不上，所以没有阅读其文献，在这里分享给大家可能算是一个初窥吧。 如果你需要经常使用这个在线服务，强烈建议通读原理和算法，这样计算的结果才更加真实更加正确！！！ 该服务的用途我理解为主要是通过已知的小分子化合物，去寻找其可能作用的靶点的过程。俗称钓靶。 药物靶点鉴定包括许多算法来寻找基因和蛋白质。当靶标的三维结构可以使用，寻靶的过程就变为在候选靶标和小分子之间的联系模式的寻找。其中一类以分子对接为代表，另外一类就是Pharmmapper这种空间特征排列搜寻，其本质上也是小分子和特异靶点受体之间的相互作用分析。PharmMapper来自TargetBank, DrugBank, BindingDB 和 PDTD这几个数据库，超过7000个受体基础的药效团模型。包含1627个药物信息和459个人类蛋白靶标。 详细信息可以从这里获取帮助。在这里简单介绍一下： 流程介绍1.提交提交的分子需要为MOL2格式或者SDF格式。如果不是三维构象的分子，那么服务会自动转化为三维构象。 2.基本设置Generate Conformers PharmMapper采用半经验药效团图谱工具，其需要生成多个分子构象，用户可以采用在线的方法生成或者自己准备（离线的方法）。在线方法PharmMapper采用的是MOEA基础的构象生成算法Cyndi，离线自己准备的话将所有的结果放入一个MOL2文件提交。 Maximum Generated Conformations Cyndi生成的最大构象 Number of Objectives used in MOEA 在Cyndi的多目标进化算法中使用的目标数目 Select Targets Set 主要包含2010和2017两个数据库集。 Perform GA Match使用遗传算法（AutoDock大家还有没有印象^_^）优化药效团图谱 Number of Reserved Matched Targets生成潜在靶标数量 结果介绍 图1 图1：PharmMapper交互界面(A).PharmMapper靶标数据集(B).命中靶标模型排序 图2 图2:Kanamycin对于 Aminoglycoside 2\u0003-phosphotransferase IVa (PDB ID: 3SG9)靶标(A).Kanamycin和其药效团(B).Kanamycin以及周围的药效团分子，在药效团中，紫色的球表示氢键受体中心，绿色的球表示氢键供体中心，淡蓝色的球表示疏水中心 参考文献: Xiaofeng Liu, Sisheng Ouyang, Biao Yu, Kai Huang, Yabo Liu, Jiayu Gong, Sisuan Zheng, Zhihua Li, Honglin Li, Hualiang Jiang. PharmMapper Server: a web server for potential drug target identification via pharmacophore mapping approach. Nucleic Acids Res., 2010, 38, W609-W614. Xia Wang, Chenxu Pan, Jiayu Gong, Xiaofeng Liu, Honglin Li. Enhancing the Enrichment of Pharmacophore-Based Target Prediction for the Polypharmacological Profiles of Drugs. J. Chem. Inf. Model., 2016, 56, 1175-1183. Xia Wang, Yihang Shen, Shiwei Wang, Shiliang Li, Weilin Zhang, Xiaofeng Liu, Luhua Lai, Jianfeng Pei, Honglin Li. PharmMapper 2017 update: a web server for potential drug target identification with a comprehensive target pharmacophore database. Nucleic Acids Res., 2017, 45, W356-W360.","categories":[{"name":"在线服务","slug":"在线服务","permalink":"http://kangsgo.com/categories/在线服务/"}],"tags":[]},{"title":"SwissSimilarity:基于配体的虚拟筛选在线服务器","slug":"SwissSimilarity基于小分子的虚拟筛选在线服务","date":"2017-02-01T09:27:23.000Z","updated":"2017-12-01T11:01:54.759Z","comments":true,"path":"11.html","link":"","permalink":"http://kangsgo.com/11.html","excerpt":"","text":"SwissSimilarity是Swiss系提供的一个基于配体的虚拟筛选在线服务器。 主要的用途我觉得包含几个方面，1)一个是比如有一个小分子，需要找寻它潜在的靶标位点，作为一个找靶。2)另外一个是你有一个已知的靶点小分子，但是它的性能可能不好，你需要对其母环改造，那么可以进行骨架跃迁。3)还有一个应用就是你有一系列已知作用靶标的化合物，想找类似物进行合成优化，那么也可以进行LBVS进行初筛。当然限于我的知识面的原因，可能还有其他许多应用欢迎小伙伴们提出。 虚拟筛选（Virtual screening, VS）一般可以分为受体基础（RBVS）和配体基础（LBVS）两种方法，其中RBVS又可以称做结构为基础的虚拟筛选（SBVS），通常是对目标大分子进行对接筛选。LBVS则是通过分子相似性来和已知活性化合物相互比较。 分子描述方法简介SwissSimilarity的工作则主要是基于LBVS方法，理论基础是相似性的分子拥有相似的生物活性，对于相似性的评判标准主要是通过分子描述，分子描述主要可以分为1维，2维或3维，三类（1D，2D,3D），下面主要介绍一下: 1D方法主要是1D-描述，如一些分子或者物理化学全局参数，例如分子体积，氢键供体/受体数量等等，其主要应用于数据库的清洗或者特别的项目标准（如：复合物可以跨越血脑屏障），SMINA教程以CDPK1为例中所提到的诱饵数据库Database of Useful Decoys：Enhanced（DUDE）也是使用该方法准备的（复合1D-描述，同时不符合2D-描述） 2D方法是用2维化学结构的性质来描述计算化学相似性，最有名的要数分子印迹（molecular fingerprints，FP），其将许多化学特征投射成简单的向量。FP2方法是一个典型的基于路径的FP方法，其分析给定数量键的分子结构所有片段的线性路径。FP之间的相似性的实际量化通常由Tanimoto系数给出，Tanimoto系数是两个字符串中常见正位的数量除以两个字符串之间的正位总数。 3D方法主要是考虑的分子的三维几何构象，包括药效团识别和形状相似性。一个3D优于2D方法的优势是可以用于骨架迁移的研究。由于3D方法计算时间较长，对于在线服务计算量大是不适宜这种在线网站做筛选的，所以SwissSimilarity对于3D方法选择的也是计算量比较小的一些方法，例如Spectrophores，其方法是把3D分子力场转换到1D描述。其包含48个向量，不仅包含形状的描述，同时也包含许多其他参数的描述。Electroshape-5D是采用的Gasteiger 部分电荷（在使用ucsf Dock时原始的电荷也是这个，小伙伴们有没有留意过呢）和原子分配系数（ALOGP）。当然这两种方法都不进行几何比对。3维的相似性量化最常用的方法为Tanimoto相关系数和Manhattan距离。 筛选数据库简介SwissSimilarity包含许多小分子数据库，以下:1)药物数据库，包含FDA批准的（1500），实验和在研的（4800，500），偏僻的（160），不正规的（illicit）（170）和营养品分子（78）2）生物活性分子数据库，包括PDB（19500），高亲和力ChEBI数据库(28 000),来自ChEMBL和GLASS的酶和GPCR抑制剂数据库（480 000），生物代谢数据库HMDB(39 000)3)ZINC 数据库 drug-like,lead-like 和 fragment-like （10 600 000, 4300 000,700 000）,可以在供应商买到的(9700 000)4)可合成的虚拟库（205万） 由于计算量的问题，有一些方法只适用于小的库，具体可以查看界面。 可用的筛选方法其实上面已经介绍了，这里初略说一下：1) 2D相似性，基于相似结构的FP2分子印迹2) 3D相似性 Electroshape-5D和Spectrophore（见上文） Shape-IT和Align-IT分别基于3D形状和药效团其中还有一个combined score，其英文的解释如下:123In additioni to the score of the above mentioned methods, it is possible to make a consensus 2D/3D screening using a score based on both FP2 Tanimoto coefficient (s1) and Electroshape-5D Manhattan distance (s2). This combined score f(s1,s2) was developed for reverse screening using our SwissTargetPrediction web interface.It was obtained by logistic regression using f(s1,s2)=(1+exp(-a0-a1s1-a2s2))-1, where a0, a1 and a2 are parameters learned by the model to predict possible protein targets for a small molecule based on molecular similarity to known bioactive compounds. f(s1,s2) ranges from 0 for totally dissimilar molecules to 1 for perfectly identical molecules. This combined score was found to perform significantly better for drug-like molecules than the similarity assessed by FP2 or Electroshape-5D separatly. 大致的意思是FP2和Electroshape-5D两种评分系统用逻辑回归拟合而成。 数据库使用数据库的使用方法非常傻瓜 仅仅需要绘画或者输入SMILE选择要测的数据库提交 得出的配体按照打分排列，值为1为最相似，同时还整合了新虚拟筛选，靶标预测，ADME预测和获取SMILES功能 参考资料: Zoete, V., Daina, A., Bovigny, C., &amp; Michielin, O. SwissSimilarity: A Web Tool for Low to Ultra High Throughput Ligand-Based Virtual Screening., J. Chem. Inf. Model., 2016, 56(8), 1399-1404.SwissSimilarity help","categories":[{"name":"在线服务","slug":"在线服务","permalink":"http://kangsgo.com/categories/在线服务/"}],"tags":[{"name":"swiss","slug":"swiss","permalink":"http://kangsgo.com/tags/swiss/"}]},{"title":"ANACONA Cloud使用","slug":"ANACONA Cloud使用","date":"2017-01-01T08:30:18.000Z","updated":"2017-10-29T03:01:09.029Z","comments":true,"path":"534.html","link":"","permalink":"http://kangsgo.com/534.html","excerpt":"Anaconda是著名的python科学管理包，具有linux和windows两个版本，用来写Markdown或者python文档非常好用。特别是ipython notebook(Jupyter notebook) 更是一绝。Anaconda包含一个could包，提供3G的空间用来存储云笔记，类似与github，但是差别是自己看的，比较合适保存自己的文档。","text":"Anaconda是著名的python科学管理包，具有linux和windows两个版本，用来写Markdown或者python文档非常好用。特别是ipython notebook(Jupyter notebook) 更是一绝。Anaconda包含一个could包，提供3G的空间用来存储云笔记，类似与github，但是差别是自己看的，比较合适保存自己的文档。 首先安装Anaconda客户端 1conda install anaconda-client 登录Anaconda Cloud账户 1anaconda login 分享自己的notebooks方法如下： 12345678910#上传notbookanaconda upload my-notebook.ipynb#阅读HTML版本http://notebooks.anaconda.org//my-notebook#下载下来你的notebookanaconda download username/my-notebook","categories":[{"name":"科研辅助","slug":"科研辅助","permalink":"http://kangsgo.com/categories/科研辅助/"}],"tags":[]},{"title":"Open Babel编译安装","slug":"OpenBabel编译安装","date":"2016-12-11T08:10:20.000Z","updated":"2017-10-28T03:52:56.237Z","comments":true,"path":"526.html","link":"","permalink":"http://kangsgo.com/526.html","excerpt":"Open Babel是一个非常优秀的支持多种分子格式的开源软件，同时可以进行2D 3D格式的转换，也可以编写脚本。编译安装方法如下：","text":"Open Babel是一个非常优秀的支持多种分子格式的开源软件，同时可以进行2D 3D格式的转换，也可以编写脚本。编译安装方法如下： 官方教程：点我查看 先下载最新的版本：点我下载 解压缩： 12$ tar zxf openbabel-2.3.2.tar.gz # (this creates openbabel-2.3.2)$ mkdir build cmake构建软件： 12$ cd build$ cmake ../openbabel-2.3.2 如果你需要特别的设置，则需要-D来进行设置，-DCMAKE_INSTALL_PREFIX=~/Tools -DCMAKE_BUILD_TYPE=DEBUG 两个设置一个设置目录，一个设置类型，自我感觉没有必要使用 12make /make -j ｛num｝ # ｛num｝表示要使用多少核，例如 make -j4 表示四核make install 在cmake时可以参与更多设置： 设置GUI： -DBUILD_GUI=ON linuxGUI是wxWidgets制作的，所以你的python必须安装了wxWidgets ，个人觉得linux你都回了就没有必要使用GUI了 语言编译： 例如python-DPYTHON_BINDINGS=ON 然后再设置python的环境变量：export PYTHONPATH=/usr/local/lib:$PYTHONPATH 其中PYTHON可以替换成你的语言类型：PYTHON, CSHARP, PERL, JAVA 或 RUBY，如果都想安装，可以将PYTHON 替换为ALL","categories":[{"name":"预处理","slug":"预处理","permalink":"http://kangsgo.com/categories/预处理/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"}]},{"title":"小分子质子化处理工具","slug":"小分子质子化处理工具","date":"2016-12-08T13:38:23.000Z","updated":"2017-11-12T07:40:26.451Z","comments":true,"path":"524.html","link":"","permalink":"http://kangsgo.com/524.html","excerpt":"","text":"acdlab和marvin &nbsp; 待研究，信息来源于华中师大-精灵","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[]},{"title":"两款非常有意思的javascript插件","slug":"两款非常有意思的javascript插件","date":"2016-12-04T02:55:56.000Z","updated":"2017-10-18T12:17:14.231Z","comments":true,"path":"521.html","link":"","permalink":"http://kangsgo.com/521.html","excerpt":"","text":"一个是科研绘图插件morris.js，但是设置功能较少，不能设置max x，y，这一点比较尴尬 另外一个是缩略图插件JQUERY LIGHTBOX，适合图片过大","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"[转载]Gromacs分析教程（一）","slug":"[转载]Gromacs分析教程（一）","date":"2016-11-26T08:23:05.000Z","updated":"2017-10-29T03:32:55.210Z","comments":true,"path":"514.html","link":"","permalink":"http://kangsgo.com/514.html","excerpt":"这个教程其实比较老了，但是分析比较初级和经典，每次都要百度，故转载过来自用： （备注：本教程原著为John E. Kerrigan童鞋，覆盖较全面，本人甚喜欢。此文为精简版。 ）分子动力学模拟计算的重点在于分析。产生分子动力学轨迹文件和能量文件，是分子动力学研究的开始。以下介绍的是一些有用的分析工具。","text":"这个教程其实比较老了，但是分析比较初级和经典，每次都要百度，故转载过来自用： （备注：本教程原著为John E. Kerrigan童鞋，覆盖较全面，本人甚喜欢。此文为精简版。 ）分子动力学模拟计算的重点在于分析。产生分子动力学轨迹文件和能量文件，是分子动力学研究的开始。以下介绍的是一些有用的分析工具。1.制作模拟电影a)使用VMDVMD的“extensions-&gt;Visualization-&gt;Movie Maker”可以直接制作小电影。制作电影时，注意使用VMD的“Trajectory Smoothing”, 将模拟轨迹的几个帧（5～10帧）平均。（具体请参考VMD教程）b)使用pymol先用_g_filter_平均轨迹：_gfilter –smd.tpr –f protein.xtc –ol movie.pdb –fit –nf 5参数：-ol，处理后电影文件，此处为PDB文件格式；-fit，将各帧进行结构平均；-nf，指定平均的相邻帧数。（PS:帧，即frame)。使用pymol打开电影文件：pymolmovie.pdb在pymol里面把分子结构设置成自己喜欢的表示方式，cartoon，surface等等，然后使用一下命令将轨迹的每一帧制作成图片：mpngframe.png_该命令会产生一系列以frame开头的，带数字序列号的PNG图片文件。最后使用Linux系统的convert命令，将这些文件连城电影文件即可：convert -delay15 -loop 0 frame.png movie.gif_以上命令行的最后文件，movie.gif，即为小电影文件。其中，-delay参数就是设定每一帧直接的时间间隔。2.重叠两个结构比较构象变化_gconfrms -f1_structure_1.gro-f2 structure_2.gro -o fit.pdb (-n1 index_1.ndx -n2 index2.ndx)参数：-f1，-f2，即需要进行比较的两个分子结构；-o，输出合并后分子结构，fit.pdb包含两个分子结构的文件；-n1，-n2，指定索引文件，可以选择那一部分分子进行重叠。PS: 也可以将两个结构使用editconf转换成PDB文件，两者都加载到pymol中，然后使用align命令将结构直接重叠。3.计算平均结构_a）gcovar -s_topol.tpr -f traj.xtc -b 500 -e 800 -av trajaveg.pdb_g_covar_主要用来计算结构协方差矩阵，也可以用来计算平均结构。以上命令可以得到模拟轨迹中500到800皮秒的分子平均结构，结果输出为_trajaveg.pdb。_b）grmsf -stopol.tpr-ftraj.xtc-b500-e800-ox_trajaveg.pdb_g_rmsf_用于计算分子结构均方根涨落，也可以求平均结构，以上命令功能与使用_gcovar相当。4.计算系统能量和相互作用能量_genergy -stopol.tpr-f traj.xtc -o energy.xvg该命令为交互方式，需要选择输出的能量，可以仔细阅读各个能量项，输出需要部分（参考软件手册）。输出文件为xmgrace的.xvg文件格式（个人最爱软件之一，理由：简单，强大，免费！！）5.计算蛋白回转半径何谓“回转半径”？就是大学物理第二册，第三百页左下角，第二十五行的后半部分。回转半径，可以大概描述分子结构有多紧密。_ggyrate -stopol.tpr -f traj.xtc -o rgyrate.xvg可以使用索引文件，指定特定部分分子。6.计算蛋白质结构变化a）均方根偏差（Root-Mean-Square-Deviation, RMSD） _grms -stopol.tpr -f traj.xtc -o rmsd.xvg这基本是模拟之后，分析第一步做的事情，主要用于查看模拟结构（特别是蛋白质）是否稳定。a）均方根涨落（Root-Mean-Square-Fluctuation, RMSD）_grmsf -stopol.tpr -f traj.xtc -o rmsf.xvg该命令可以得到每一个原子的结构位置涨落（也就是震动的构象变化）。_grmsf也可以计算平均结构：_g_rms -s topol.tpr -f traj.xtc -ox trajave.pdb -b 800 -e 1000以上既是求800ps到100ps的估计平均结构，可以与上文使用_g_covar_求平均结构进行比较。c）原子位置变化RMSD_grmsdist -s topol.tpr -f traj.xtc -o distrmsd.xvg该命令求得的是原子间距离变化的RMSD。也可以使用索引文件选择需要计算的原子。该命令还有很多奇妙输出，请使用_*g_rmsdist -h_查看一下。（1）选择体系的一部分，以便分析 . 采用make_ndx 命令。 make_ndx -f protein.pdb -o protein.mdx &gt; r 1 36 37 72 73 108 （按残基选择，还可按其他方式进行选择） &gt; name 15 Terminal （对选择的这部分残基命令） &gt; v （查看） &gt; q (退出）(2) 分析能量，采用g_energy命令。 g_energy –f md.edr –o potential.xvg 然后选择所有输出的能量部分的序号。(3) 分析原子的均方根偏差（RMSD），采用g_rms命令。 g_rms –s md.tpr –f md.trr –o rmsd.xvg(4) 分析蛋白质的回旋半径变化，采用g_gyrate命令。 蛋白质的回旋半径反应了蛋白质分子的体积和形状。同一体系的回旋半径越大，说明体系发生了膨胀。 g_gyrate –f md.trr –s md.tpr –o gyrate.xvg(5) 分析溶剂的可及表面积（SASA），采用g_sas命令。 它是描述蛋白质疏水性的重要手段，氨基酸残基的疏水性是影响蛋白质折叠的重要物理作用。 g_sas -f md.trr -s md.tpr -o area.xvg -or resarea.xvg -oa atomarea.xvg(6) 分析蛋白质的二级结构变化，采用do_dssp命令。 do_dssp –s md.tpr –f md.xtc –o ss.xpm分享：","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"将多个小分子mol合并为1个","slug":"将多个小分子mol合并为1个","date":"2016-10-11T07:10:41.000Z","updated":"2017-10-29T03:24:59.599Z","comments":true,"path":"504.html","link":"","permalink":"http://kangsgo.com/504.html","excerpt":"","text":"1cat *.mol2 &gt; total.mol2 来源:贵医-周","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"LigPlot+官方手册初译","slug":"LigPlot+官方手册初译","date":"2016-09-27T16:34:55.000Z","updated":"2017-10-28T04:03:58.677Z","comments":true,"path":"497.html","link":"","permalink":"http://kangsgo.com/497.html","excerpt":"","text":"由于自己想用LigPlot作图，但是做出来的图并不理想，有一些氨基酸残基并不能被绘制上去，所以想看以下有没有解决办法。（最后发现还是无法这么弄） LigPlot+是LIGPLOT和DIMPLOT项目的图形终端。绘图生成的项目可以交互式的在界面上编辑，然后写PostScript文件来绘图或者转换成其他的图像格式。除此之外，你可以叠加相关的LIGPLOTs 蛋白结合相似或者相同的配体，或者相同/相似的配体在不同的蛋白中。 LIGPLOT 自动生成缩略图在蛋白配体复合物PDB文件中蛋白配体的相互作用图 DIMPLOT 绘制选择的蛋白蛋白或者结构域结构域表面的相互联系 File-&gt;Open-&gt;PDB File 我们着重介绍LIGPLOT ligplot_tab 1.选择配体，你希望绘制的，在如上清单里 另一个方法就是你可以输入你在盒子里想要的残基范围。残基范围能够在如下中选择： 例子 18 20 A 残基范围：起始-结束残基，链ID，如果连ID为空则被忽略 NAG 18 MAN 20 A 残基名称和数量，增加连ID key 如上为图形的标志","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"LigPlot","slug":"LigPlot","permalink":"http://kangsgo.com/tags/LigPlot/"}]},{"title":"do_dssp 绘图记录","slug":"do_dssp 绘图记录","date":"2016-09-19T13:49:34.000Z","updated":"2017-10-29T03:11:23.256Z","comments":true,"path":"493.html","link":"","permalink":"http://kangsgo.com/493.html","excerpt":"个人觉得默认的do_dssp绘图出来的并不好看,还需要自行ps处理,查看了一下原来第二步xpm2ps的时候可以进行设置,具体可以看官方说明.自己捣鼓了一下发现m2p的输入文件如下设置比较美观:","text":"个人觉得默认的do_dssp绘图出来的并不好看,还需要自行ps处理,查看了一下原来第二步xpm2ps的时候可以进行设置,具体可以看官方说明.自己捣鼓了一下发现m2p的输入文件如下设置比较美观: m2p-m2p: 123456789101112131415161718192021222324252627282930313233343536; Command line options of xpm2ps override the parameters in this fileblack&amp;white = no ; Obsoletetitlefont = Times-Roman ; A PostScript Fonttitlefontsize = 42 ; Font size (pt)legend = yes ; Show the legendlegendfont = Times-Roman ; A PostScript Fontlegendlabel = ; Used when there is none in the .xpmlegend2label = ; Used when merging two xpm’slegendfontsize = 36 ; Font size (pt)xbox = 2.0 ; x-size of a matrix elementybox = 2.0 ; y-size of a matrix elementmatrixspacing = 2.0 ; Space between 2 matricesxoffset = 0.0 ; Between matrix and bounding boxyoffset = 0.0 ; Between matrix and bounding boxx-major = 20000 ; Major ticks on x axis every .. framesx-minor = 5 ; Id. Minor ticksx-firstmajor = 0 ; First frame for major tickx-majorat0 = no ; Major tick at first framex-majorticklen = 8.0 ; x-majorticklengthx-minorticklen = 4.0 ; x-minorticklengthx-label = ; Used when there is none in the .xpmx-fontsize = 36 ; Font size (pt)x-font = Times-Roman ; A PostScript Fontx-tickfontsize = 30 ; Font size (pt)x-tickfont = Helvetica ; A PostScript Fonty-major = 20y-minor = 5y-firstmajor = 0y-majorat0 = noy-majorticklen = 8.0y-minorticklen = 4.0y-label =y-fontsize = 36y-font = Times-Romany-tickfontsize = 30y-tickfont = Helvetica dssp-sh如下: 1234567891011121314#!/bin/bash# author:kangsgo# method:# loop 后面为文件夹变量,表示进入哪个文件夹# trj_125-150ns.xtc 轨迹变量for loop in achmd bnf318 qna tcdddoecho “开始运行”cp m2p.m2p /home/gromacs/shiyan/$loopcd /home/gromacs/shiyan/$loopdo_dssp -f md200skip.xtc -s npt.tpr -n index.ndx -o fwss.xpmxpm2ps -f fwss.xpm -o fwss.eps -by 2 -bx 1 -di m2p.m2pconvert fwss.eps $loop.bmpdone","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"ProDy笔记[未完成]","slug":"ProDy笔记[未完成]","date":"2016-09-18T16:45:37.000Z","updated":"2017-10-28T03:50:03.531Z","comments":true,"path":"489.html","link":"","permalink":"http://kangsgo.com/489.html","excerpt":"","text":"教程实例文件：ZIP &nbsp;","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/tags/Python/"}]},{"title":"[译]coMD项目简介","slug":"[译]coMD项目简介","date":"2016-09-18T06:27:29.000Z","updated":"2017-10-29T03:24:10.177Z","comments":true,"path":"484.html","link":"","permalink":"http://kangsgo.com/484.html","excerpt":"Collective MD (coMD)coMD是一个混合的方法，采用VMD插件设计，具有高效的构型改变。ENM模型选择通过 Monte Carlo/Metropolis算法用以加速MD轨迹（Gur et. al,2013）CoMD能够用以评价构象景观（Gur et.al,2015）","text":"Collective MD (coMD)coMD是一个混合的方法，采用VMD插件设计，具有高效的构型改变。ENM模型选择通过 Monte Carlo/Metropolis算法用以加速MD轨迹（Gur et. al,2013）CoMD能够用以评价构象景观（Gur et.al,2015） 功能 coMD能够被用来 采样构象空间接近自然状态和亚状态 在已知的构象之间生成迁移路径 获得信息在全局动力学层面上的原子分辨率 生成能量景观在主坐标的空间上 下载coMD插件文件能够被获得通过Geeing coMD 参考文献Gur M, Madura DJ, Bahar I Global Transitions of Proteins Explored by a Multiscale Hybrid Methodology: Application to Adenylate Kinase 2013 Biophys J 105(7):1643-1652.Gur M, Zomot E, Cheng MH, Bahar I. Energy Landscape of LeuT from Molecular Simulations. 2015 J Chem Phys 143(24):243134. &nbsp;","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[译]MechStiff项目简介","slug":"[译]MechStiff项目简介","date":"2016-09-18T05:27:22.000Z","updated":"2017-10-29T02:48:54.514Z","comments":true,"path":"482.html","link":"","permalink":"http://kangsgo.com/482.html","excerpt":"MechStiff对于机械刚度计算MechStiff计算机械阻力对于外力（单轴拉伸）应用在于氨基酸残基3D结构的特殊部分（自己也不是很了解这个，翻译质量较差，建议度原文）","text":"MechStiff对于机械刚度计算MechStiff计算机械阻力对于外力（单轴拉伸）应用在于氨基酸残基3D结构的特殊部分（自己也不是很了解这个，翻译质量较差，建议度原文） 功能MechStiff使用作为输入已知的结构模型ANM。其能够常常被计算机械刚度/强度图，作为残基的功能指标，和效率刚度（effective stiffness）（或力常量）for each residue averaged over all pairs it forms。分别绘制2D（map）或者1D（profile），残基的强度伴随ribbon的颜色编码来表示（TCL脚本直接通过VMD加载）。绘图和可视化可以用来： 鉴定结构外部扰动通过异向性响应 测定弱或强相互作用的双根据外力受到扰动(拉伸)的方向和位点 测定宏观的有效弹性系数，通过比较数据，这些数据来自Single Molecule Force Spectroscopy (SMFS) 或atomic force microscopy (AFM) 计算每个模型的贡献对于变形比对选择的变形 参考文献Eyal E, Bahar I Toward a Molecular Understanding of the Anisotropic Response of Proteins to External Forces: Insights from Elastic Network Models Biophys J 2008 94(9):3424-3435.","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[译]membrANM项目简介","slug":"[译]membrANM项目简介","date":"2016-09-18T05:06:27.000Z","updated":"2017-10-29T02:48:26.658Z","comments":true,"path":"479.html","link":"","permalink":"http://kangsgo.com/479.html","excerpt":"Membrane ANM (membrANM)membrANM 是一个工具套件对于研究转运蛋白或者其它膜蛋白的全局结构动力学","text":"Membrane ANM (membrANM)membrANM 是一个工具套件对于研究转运蛋白或者其它膜蛋白的全局结构动力学 功能membrANM可以被用作 计算膜蛋白的动力学，通过存在的双分子膜（bilayer），同样能够作为弹性网络模型，隐式的或者显式的。 在有或者无膜的情况下比较蛋白全局运动 了解蛋白膜的重塑或者耦合功能机制 下载membrANM资源文件能够通过Getting membrANM获得 参考文献Lezon TR, Bahar I Constraints Imposed by the Membrane Selectively Guide the Alternating Access Dynamics of the Glutamate Transporter GltPh 2012 Biophys J 102(6):1331-1340.","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[译]NMWiz项目简介","slug":"[译]NMWiz项目简介","date":"2016-09-18T03:54:51.000Z","updated":"2017-10-29T02:48:41.986Z","comments":true,"path":"477.html","link":"","permalink":"http://kangsgo.com/477.html","excerpt":"Normal Mode Wizard&nbsp; Normal Mode Wizard (NMWiz)是一个VMD插件用来设计作为可视化的比较分析正常模式的数据，例如:模型能够来源于主成分，本质动力学，正常模型分析或者描述任何分子的矢量运动","text":"Normal Mode Wizard&nbsp; Normal Mode Wizard (NMWiz)是一个VMD插件用来设计作为可视化的比较分析正常模式的数据，例如:模型能够来源于主成分，本质动力学，正常模型分析或者描述任何分子的矢量运动 功能 NMWiz被设计作为ProDy的界面，能够被使用作为： 执行ANM，GNM和PCA/EDA计算 绘制用户自定义的的豪猪图 制作动画效果（简单的构象） 制作相互作用平方米波动图 比较两个结构并且绘画箭头 下载NMWiz自VMD v1.91其被剥离。升级VMD到最新版即可使用.check out 获得NMWiz 参考文献：ProDy: Protein Dynamics Inferred from Theory and Experiments Bakan A, Meireles LM, Bahar I 2011 Bioinformatics 27(11):1575-1577","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[译]Evol项目简介","slug":"[译]Evol项目简介","date":"2016-09-18T03:41:46.000Z","updated":"2017-10-29T05:35:42.907Z","comments":true,"path":"475.html","link":"","permalink":"http://kangsgo.com/475.html","excerpt":"","text":"Evol对于协同进化分析Evol是一个强大且高效的API工具和应用对于分析序列的进化和比较蛋白质动力学功能/作用。 API功能确定保守的和共同进化的氨基酸残基 查询蛋白质家族数据库（Pfam）和索取MSA文件 极其快速的MSA IO 功能 非常灵活的MSA类型序列索引 应用Evol 应用能够允许你分析非常大的MSA文件，保存或者绘画数字结果而不需要编写任何代码。你能够读取输出文件和继续分析使用你喜欢的软件。 参考文献Sequence Evolution Correlates with Structural Dynamics Liu Y, Bahar I 2012 Mol Biol Evol 29(9):2253-2263Role of Hsp70 ATPase domain intrinsic dynamics and sequence evolution in enabling its functional interactions with NEFs Liu Y, Gierasch LM, Bahar 2010 PLoS Comput Biol 6(9)","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[译]ProDy项目简介","slug":"[译]ProDy项目简介","date":"2016-09-18T03:24:13.000Z","updated":"2017-10-29T02:50:13.416Z","comments":true,"path":"473.html","link":"","permalink":"http://kangsgo.com/473.html","excerpt":"ProDy项目ProDy是一个自由并且开源的python工具包，用来进行蛋白质结构模拟分析。其设计作为一个柔性的并且具有API的套件，可以交互式的使用及应用发展。","text":"ProDy项目ProDy是一个自由并且开源的python工具包，用来进行蛋白质结构模拟分析。其设计作为一个柔性的并且具有API的套件，可以交互式的使用及应用发展。 结构分析ProDy能够快速灵活的读取PDB和DCD文件，使用具有强大和可定义的原子选择性，快速执行的新方法。 动力学分析能够完成如下主成分分析： X-ray结构异构体（残基缺失，突变） Blast搜索混合物结构数据 NMR模型和MD快照（本质动力学分析）能够完成如下正常模型分析： 异向性网络模型（ANM） 高斯（Gaussian）网络模型（GNM） ANM/GNM通过取决于力函数的距离与性质动力学来自实验数据，理论模型和模拟使用NMWiz进行可视化 安装方法：安装ProDy和Evol可以使用pip,pip install -U ProDy，或者使用编译的方法 译着注：国外的python下载较慢，建议更换为豆瓣源或者阿里云源，点我查看如何更换 参考文献：Bakan A, Meireles LM, Bahar I ProDy: Protein Dynamics Inferred from Theory and Experiments 2011 Bioinformatics 27(11):1575-1577Bakan A, Dutta A, Mao W, Liu Y, Chennubhotla C, Lezon TR, Bahar I Evol and ProDy for Bridging Protein Sequence Evolution and Structural Dynamics 2014 Bioinformatics 30(18):2681-2683","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"利用pandas处理mdpout_descriptors文件","slug":"利用pandas处理mdpout_descriptors文件","date":"2016-09-17T16:06:57.000Z","updated":"2017-10-29T03:25:59.752Z","comments":true,"path":"471.html","link":"","permalink":"http://kangsgo.com/471.html","excerpt":"mdpout_descriptors文件项目过多，虽然可以直接用R进行作图，无奈我不会使用R，所以网上半摸索学习pandas写了一个简单的方法处理文本，如下：","text":"mdpout_descriptors文件项目过多，虽然可以直接用R进行作图，无奈我不会使用R，所以网上半摸索学习pandas写了一个简单的方法处理文本，如下： 12345678910111213#coding=utf-8# author:kangsgo# fepocket2 volume 拆分工具# ref:http://blog.sina.com.cn/s/blog_a73687bc0101eenc.htmlimport pandas as pdid = pd.read_table(\"mdpout_descriptors.txt\",sep=\" +\",engine='python')name2=id['snapshot']time=id['pock_volume']#method1pd.concat([name2,time],axis=1).to_csv('volume.txt',sep=\" \",index=False)#method2 先全读进来，然后 df.iloc[:,[:3]]#https://www.v2ex.com/t/306789#reply2","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"[自写]focket2 中md处理脚本","slug":"[自写]focket2 中md处理脚本","date":"2016-09-17T10:09:40.000Z","updated":"2017-10-29T03:30:53.666Z","comments":true,"path":"464.html","link":"","permalink":"http://kangsgo.com/464.html","excerpt":"","text":"保存为sh格式后缀，放入处理文件目录，会生成fopcket2文件夹，内包含所有内容 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# author:kangsgo# name: fpocket2 MD 前处理脚本# method:# 默认轨迹名称：mdwholeNOjump.xtc，默认tpr为md_0_1.tpr# 请根据需要修改如下参数# 总的轨迹数量(ps)# numtray=150000# 每多少间隔提取一次(约150frame)# dttray=1000#设置比对结构,选择蛋白echo -e \"1\\n1\\n\"|trjconv_mpi -f mdwholeNOjump.xtc -s md_0_1.tpr -fit rot+trans -o align.xtc#创建目录迁移mkdir fpocket2cp align.xtc fpocket2/align.xtccp md_0_1.tpr fpocket2/md_0_1.tprcd fpocket2#创建txt文件touch mdpocket_input.txt#总的轨迹数量(ps)numtray=150000#每多少间隔提取一次(约150frame)dttray=1000#轨迹变量numdttray=$[$numtray/$dttray]echo \"轨迹间隔$numdttray\"count=0num=0while [ $num -le $numtray ]do echo \"数值为$num\" echo \"count数值为$count\" count=$[ $count +1] num=$[$dttray*$count] #参数修改为ns，除以1000 ns=$[$num/1000] echo -e \"1\\n\"|trjconv_mpi -f align.xtc -s md_0_1.tpr -dump $num -o snap_$ns.pdb #写入文件 echo \"snap_$ns.pdb\\n\"&amp;gt;&amp;gt;mdpocket_input.txtdoneecho \"全部完成\" &nbsp;下载地址：fpocketpre-sh &nbsp;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"fpocket2探索","slug":"fpocket2探索","date":"2016-09-16T16:01:24.000Z","updated":"2017-10-29T03:41:18.722Z","comments":true,"path":"443.html","link":"","permalink":"http://kangsgo.com/443.html","excerpt":"安装教程之前了解了以下Epock，前一篇文章也使用了Epock做分析，最大的好处就是简便，但是其分析是建立与自己处理口袋上的，这样误差就非常的大，导致模拟往往开始的时候体积高，后期下滑的很厉害～看到一篇plos one 上使用了fpocket2，所以使用了解一下。fpocket2有一个好处是有在线服务:点我进去要求：基于可视化软件VMD和Pymol安装: 12345tar -xzf fpocket2.tar.gzcd fpocket2makemake testsudo make install 如果遇到错误，将makefile中部分内容进行替换： 123$(LINKER) $(LFLAGS) $^ -o $@by$(LINKER) $^ -o $@ $(LFLAGS) fpocket基本使用","text":"安装教程之前了解了以下Epock，前一篇文章也使用了Epock做分析，最大的好处就是简便，但是其分析是建立与自己处理口袋上的，这样误差就非常的大，导致模拟往往开始的时候体积高，后期下滑的很厉害～看到一篇plos one 上使用了fpocket2，所以使用了解一下。fpocket2有一个好处是有在线服务:点我进去要求：基于可视化软件VMD和Pymol安装: 12345tar -xzf fpocket2.tar.gzcd fpocket2makemake testsudo make install 如果遇到错误，将makefile中部分内容进行替换： 123$(LINKER) $(LFLAGS) $^ -o $@by$(LINKER) $^ -o $@ $(LFLAGS) fpocket基本使用 软件自带了一个sample的文件夹，里面有许多例子，我们可以使用一个最为简单的 fpocket -f sample/3LKF.pdb 终端会有如下： =========== Pocket hunting begins ===================== Pocket hunting ends ============ 表示已经使用运算完毕 会有一个3LKF_out的文件夹，可以使用3LKF_VMD.sh脚本快速查看 结果如下： [ 3lkf](http://kangsgo.com/wp-content/uploads/2016/09/3LKF-300x244.png) 修改球的大小颜色位于3LKF_out处的Graphical-&gt;Representations [ 1](http://kangsgo.com/wp-content/uploads/2016/09/1-300x187.png) 同样可以运行pymol脚本3LKF_PYMOL.sh 和手册上的图感觉不同，还需要进一步微调 [ 2](http://kangsgo.com/wp-content/uploads/2016/09/2-300x225.png) dpocket口袋特征提取dpocket的d一词为describing的意思，能够描述口袋的物理化学环境，并且能够分析多个结构。 例子： 数据要求设计一个text文件，该文件包含蛋白的pdb结构文件，以及配体的ID，教程上说位于sample/test_dpocket.txt上，但是我并未看见，而是有一个dpinput.txt文件，估计是1.0版本遗留下来的产物，我们重命名并且修改中间的内容变为如下：（！注意pdb与配体名称中间为制表符【table】，7TTA的结构文件可能需要自己下载！） 1233LKF.pdb pc11ATP.pdb atp7TAA.pdb abc dpocket -f sample/test_dpocket.txt 会得到3个文件： 123dpout_explicitp.txtdpout_fpocketnp.txtdpout_fpocketp.txt 可以使用-o 来修改输出文件前缀，如-o my_test则为my_test_explicitp.txt fpocketp.txt描述精确的口袋的相关描述 fpocketnp.txt为描述非精确的口袋 explicito.txt则为描述自定义参考残基与配体相互之间距离多少被纳入分析范围（默认4A） 得到的ASCII 文本文件可以用统计学软件例如R进行分析（自己待研究） tpocket评分功能相比fpoket与dpocket，其是成药性预测评分的进一步精细预测，T为Test的含义，测试你需要比对有无配体的结构在口袋上的空间对应关系。 例子：tpocket对于无配体结构 这个需要下载fpocket-1.0-date 需要有pp_apo-t.txt 和 pp_cplx-t.txt 两个文件。前者为无配体，后者为包含配体，pp_apo-t.txt 部分示例如下： 1234data/pp_data/unbound/1QIF-1ACJ.pdb data/pp_data/complex/1ACJ.pdb thadata/pp_data/unbound/3APP-1APU.pdb data/pp_data/complex/1APU.pdb ivadata/pp_data/unbound/1HSI-1IDA.pdb data/pp_data/complex/1IDA.pdb qnadata/pp_data/unbound/1PSN-1PSO.pdb data/pp_data/complex/1PSO.pdb iva 运行： 1tpocket -L data/pp_apo-t.txt 运行需要花费一些时间，最后可以得到两个文件，第一个为默认的stats_g.txt 他包含了fpocket所需要的所有的指标 123456789101112131415Ratio of good predictions (dist = 4A)——————————————Rank &lt;= 1 : 0.69Rank &lt;= 2 : 0.83Rank &lt;= 3 : 0.94Rank &lt;= 4 : 0.94Rank &lt;= 5 : 0.94Rank &lt;= 6 : 0.94Rank &lt;= 7 : 0.94Rank &lt;= 8 : 0.94Rank &lt;= 9 : 0.94Rank &lt;= 10 : 0.94————————————-Mean distance: 2.924573Mean relative overlap : 39.373226 此结果为48个蛋白的总计stats_p.txt为分开的信息 部分如下： 6 若为计算有配体的结构，则只需要把无配体结构也改为有配体即可如： 1data/pp_data/complex/1acj.pdb data/pp_data/complex/1acj.pdb tha mdpocket MD轨迹中的口袋检测mdpocket主要有如下功能： 1.MD轨迹中的口袋检测 2.口袋瞬时可视化 3.MD轨迹中口袋描述的提取 4.MD轨迹中获取口袋事件的静态图像 使用的格式为pdb格式 例子： 非常重要的是首先需要align所有的snapshots 以Amber为例: 1.创建ptraj输入文件，包含以下内容 12345678trajin ../md_1.x.gz 1 250 10trajin ../md_2.x.gz 1 250 10trajin ../md_3.x.gz 1 250 10reference ../reference.pdbstrip !:1-208rms reference :25-88,120-196@CA,C,N,Otrajout snapshots/snap.pdb pdbgo 2.运行ptraj使用如下命令 1ptraj your_topology.top &lt; ptraj_input_file.ptr 主要方法内容为切割为3个文件，每个为250 snaphots，取第10个计算。设置参考的PDB结构进行校准。strip用来丢弃除去蛋白的一切东西，如溶剂，离子等（注：因为这个蛋白只有208位，所以1-208，貌似只会获取残基，未考）接下来，我们比对每个snapshot和参考结构，仅使用重原子残基 25-88和120-196.输出到snapshots/snap.pdb，名称为snap.pdb.#，你需要重命名你的pdb文件成为例如snap_#.pdb。可以使用如下shell命令： 1ls | cut -f3 -d”.” | awk ‘&#123;print “mv snap.pdb.”$0″ snap_”$0″.pdb”&#125;’ | sh 最后你需要对你的snapshots文件进行排序，可以使用scripts目录中的createMDPocketInputFile.py,命令如下： 1python createMDPocketInputFile.py /home/peter/snapshots mdpocket_input.txt 将会输出一个mdpocket_input.txt文件 1mdpocket -L mdpocket_input.txt 最后会获得如下文件: mdpout_dens_grid.dx 其会显示体积坐标，设置和最终效果图如下： vmdscene &nbsp; &nbsp; vmdscene2 &nbsp; mdpout_freq_grid.dx 这个文件和前者非常类似，但是这个网格只包含在MD轨迹中开放频率的量度 mdpout_dens_iso_8.pdb 这个文件包含在8A^3大于3或者更大的Voronoi Vertices, Pymol可以选择并存储你感兴趣的格点，一般情况下蛋白结合口袋或者蛋白蛋白作用口袋选择isovalue高的，例如5.若是研究构象的改变例如开关闭合，则选择2或者3这种isovalue较低的。可以参考高级功能参看如何提取。 mdpout_freq_iso_0_5.pdb 与前者相似，只是cut -off 为0.5 这样即可使用自己选择的结合口袋进行计算： 1mdpocket -L mdpocket_input.txt -f my_pocket.pdb -v 10000 -v 是一个可选选项，用以控制合理的计算时间（我认为是，若没有计算完，也会停止？）将会获得如下文件： mdpout_mdpocket.pdb 所选择的口袋区域，仅可使用PyMOL读取。 mdpout_mdpocket_atoms.pdb 相互作用原子 mdpout_descritpors.txt 体积等信息 可以使用R等作图 123456r=read.table(“mdpout_descriptors.txt”,h=T)ylim=c(400,1200)plot(r[,”pock_volume”],ty=’l’,ylim=ylim,main=””,xlab=””,ylab=””)par(new=T)plot(smooth.spline(r[,”pock_volume”],df=40),col=”red”,lwd=3,ylim=ylim,ty=”l”,xlab=”snapshot”,ylab=”volume”) 如下： 1 参考文献：Error Installing fpocket fpocket官网","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"自用脚本分享","slug":"自用脚本分享","date":"2016-09-16T08:05:29.000Z","updated":"2017-10-29T03:31:50.582Z","comments":true,"path":"440.html","link":"","permalink":"http://kangsgo.com/440.html","excerpt":"计算G_mmpbsa1234567891011121314151617#!/bin/bash# author:kangsgo# method:# loop 后面为文件夹变量,表示进入哪个文件夹# trj_125-150ns.xtc 轨迹变量for loop in achmd bnf318 qna tcdddoecho \"开始执行!\";echo \"进入第一个目录:$loop!\";cd /home/gromacs/shiyan/$loopecho \"进行一步计算\"echo -e \"1\\n13\\n\"|g_mmpbsa -f trj_125-150ns.xtc -s npt.tpr -n index.ndx -i canshu/pbsa.mdp -pdie 2 -pbsa -decompecho \"开始能量拆分\"python3 MmPbSaStat.py -m energy_MM.xvg -p polar.xvg -a apolar.xvgpython3 MmPbSaDecomp.py -bs -nbs 2000 -m contrib_MM.dat -p contrib_pol.dat -a contrib_apol.datecho \"完成\"done &nbsp; 计算rmsf，并且处理轨迹","text":"计算G_mmpbsa1234567891011121314151617#!/bin/bash# author:kangsgo# method:# loop 后面为文件夹变量,表示进入哪个文件夹# trj_125-150ns.xtc 轨迹变量for loop in achmd bnf318 qna tcdddoecho \"开始执行!\";echo \"进入第一个目录:$loop!\";cd /home/gromacs/shiyan/$loopecho \"进行一步计算\"echo -e \"1\\n13\\n\"|g_mmpbsa -f trj_125-150ns.xtc -s npt.tpr -n index.ndx -i canshu/pbsa.mdp -pdie 2 -pbsa -decompecho \"开始能量拆分\"python3 MmPbSaStat.py -m energy_MM.xvg -p polar.xvg -a apolar.xvgpython3 MmPbSaDecomp.py -bs -nbs 2000 -m contrib_MM.dat -p contrib_pol.dat -a contrib_apol.datecho \"完成\"done &nbsp; 计算rmsf，并且处理轨迹 1234567891011121314151617181920212223#!/bin/bash# author:kangsgo# name: rmsf处理脚本# method:# loop 后面为文件夹变量,表示进入哪个文件夹# trj_120-150ns.xtc 轨迹变量for loop in bnf bnf318 ch qna tcdddoecho &quot;开始执行&quot;;echo &quot;进入第一个目录$loop&quot;;cd /home/kangsgo/shiyan/chuli/$loopecho &quot;转换轨迹&quot;;trjconv_mpi -f mdwholeNOjump.xtc -o trj_120-150ns -b 120000 -e 150000echo &quot;转换完成,开始转换500个单位轨迹&quot;;trjconv_mpi -f mdwholeNOjump.xtc -o md200skip -dt 200echo &quot;转换完成,开始转换100个单位轨迹&quot;;trjconv_mpi -f mdwholeNOjump.xtc -o md1000skip -dt 1000echo &quot;rmsf计算&quot;echo -e &quot;3\\n&quot;|gmx_mpi rmsf -s md_0_1.tpr -f trj_120-150ns.xtc -o rmsf.xvg -oq rmsf.pdb -resdoneecho &quot;全部完成&quot; &nbsp;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Django SHOP文档浅尝","slug":"Django SHOP文档浅尝","date":"2016-05-25T02:27:44.000Z","updated":"2017-10-29T03:08:49.513Z","comments":true,"path":"415.html","link":"","permalink":"http://kangsgo.com/415.html","excerpt":"","text":"Django SHOP是Django web里面最出名的shop类软件了，查到其有开发文档，所以研究学习一下文档。 文档地址：http://django-shop.readthedocs.io/en/stable/","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://kangsgo.com/tags/Django/"}]},{"title":"Flask-Python Web 开发","slug":"Flask-Python Web 开发","date":"2016-05-22T16:28:23.000Z","updated":"2017-10-18T12:17:14.231Z","comments":true,"path":"410.html","link":"","permalink":"http://kangsgo.com/410.html","excerpt":"","text":"这个是我参照的Flask官网的一个例子~demo.tar Django笔记：https://www.gitbook.com/search?q=Django+","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"[转载]常用分子力学与力场的参考文献","slug":"[转载]常用分子力学与力场的参考文献","date":"2016-05-19T02:10:59.000Z","updated":"2017-10-29T02:50:32.595Z","comments":true,"path":"408.html","link":"","permalink":"http://kangsgo.com/408.html","excerpt":"Molecular Mechanics and Force Field References AMBER, Assisted Model Building and Energy Refinement AMBER/OPLS, The AMBER force field with Jorgensen’s OPLS parameters CHARMM, Chemistry at HARvard Macromolecular Mechanics DISCOVER, force fields of the Insight/Discover package ECEPP/2, a pairwise potential for proteins and peptides GROMOS, GROningen MOlecular Simulation package MM2, the class 1 Allinger molecular mechanics program MM3, the class 2 Allinger molecular mechanics program MM4, the class 3 Allinger molecular mechanics program MMFF94, the Merck Molecular Force Field Tripos, the force field of the Sybyl molecular modeling program Comparisons and Evaluations of Force Fields","text":"Molecular Mechanics and Force Field References AMBER, Assisted Model Building and Energy Refinement AMBER/OPLS, The AMBER force field with Jorgensen’s OPLS parameters CHARMM, Chemistry at HARvard Macromolecular Mechanics DISCOVER, force fields of the Insight/Discover package ECEPP/2, a pairwise potential for proteins and peptides GROMOS, GROningen MOlecular Simulation package MM2, the class 1 Allinger molecular mechanics program MM3, the class 2 Allinger molecular mechanics program MM4, the class 3 Allinger molecular mechanics program MMFF94, the Merck Molecular Force Field Tripos, the force field of the Sybyl molecular modeling program Comparisons and Evaluations of Force Fields AMBER:Cornell, W. D., Cieplak, P., Bayly, C. I., Gould, I. R., Merz, K. M. Jr., Ferguson, D. M. Spellmeyer, D. C., Fox, T.,Caldwell, J. W., and Kollman, P. A. (1995) A second generation force field for the simulation of proteins, nucleicacids and organic molecules, J. Am. Chem. Soc. 117, 5179-5197.Pearlman, D. A., Case, D. A., Caldwell, J. C., Seibel, G. L., Singh, U. C., Weiner, P., &amp; Kollman, P. A., (1991)AMBER 4.0, University of California, San Francisco. Weiner, P. K., &amp; Kollman, P. A., (1981) AMBER: Assisted Model Building with Energy Refinement. A GeneralProgram for Modeling Molecules and Their Interactions, J. Comp. Chem. 2, 287-303. Weiner, S.J., Kollman, P.A., Case, D.A., Singh, U.C., Ghio, C., Alagona, G., Profeta, S., Jr., Weiner, P.K. (1984)A new force field for molecular mechanical simulation of nucleic acids and proteins. J. Am. Chem. Soc. 106, 765-784. Weiner, S. J., Kollman, P. A., Nguyen, D. T., and Case, D. A., (1986) “An All Atom Force Field for Simulations ofProteins and Nucleic Acids,” J. Comp. Chem. 7, 230-252. AMBER/OPLS:Damm, W., A. Frontera, J. Tirado-Rives and W. L. Jorgensen (1997) “OPLS All-Atom Force Field for Carbohydrates,”J. Comp. Chem. 18, 1955-1970.Jorgensen, W. L.; Maxwell, D. S. and Tirado-Rives, J. (1996) “Development and Testing of the OPLS All-Atom ForceField on Conformational Energetics and Properties of Organic Liquids” J. Am. Chem. Soc., 118, 11225-11236. Jorgensen, W. L., &amp; Tirado-Rives, J.,(1988) The OPLS Potential Functions for Proteins. Energy Minimizationfor Crystals of Cyclic Peptides and Crambin, J. Am. Chem. Soc. 110, 1657-1666. Kaminski, G., Duffy, E. M. Matsui, T., and Jorgensen, W. L. (1994) J. Phys. Chem. 98, 13077-13082. CHARMM:Brooks, B.R., Bruccoleri, R.E., Olafson, B.D., States, D.J., Swaminathan, S., Karplus, M. (1983) CHARMM:A program for macromolecular energy, minmimization, and dynamics calculations. J. Comp. Chem. 4, 187-217.Feller et al.,(1997) Molecular Dynamics Simulation of Unsaturated Lipids at Low Hydration: Parameterizationand Comparison with Diffraction Studies. Biophys. J. 73, 2269-2279 MacKerell, A D Bashford, D; Bellott, M; Dunbrack, R L; Eva seck, J D; Field, M J; Fischer, S; Gao, J; Guo, H;Ha, S; JosephMcCarthy, D; Kuc nir, L; Kuczera, K; Lau, F T K; Mattos, C; Michnick, S; Ngo, T; Nguyen, D T;Pro hom, B; Reiher, W E; Roux, B; Schlenkrich, M; Smith, J C; Stote, R; Straub, J; W tanabe, M; WiorkiewiczKuczera, J; Yin, D; Karplus, M (1998) All-atom empirical potential for molecular modeling and dynamics studiesof proteins. J. Phys. Chem., B 102, 3586-3617 Mackerell A D Wiorkiewiczkuczera J; Karplus, M (1995) An all-atom empirical energy function for thesimulation of nucleic acids. J. Amer. Chem. Soc.117, 11946-11975 Momany, F. A., &amp; Rone, R., (1992) Validation of the General Purpose QUANTA 3.2/CHARMm ForceField, J. Comp. Chem.13, 888-900. Pavelites, J. J., J. Gao, P.A. Bash and A. D. Mackerell, Jr. (1997) “A Molecular Mechanics ForceField for NAD+, NADH, and the Pyrophosphate Groups of Nucleotides,” J. Comp. Chem. 18, 221-239. Schlenkrich et al. (1996), Empirical Potential Energy Function for Phospholipids: Criteria for ParameterOptimization and Applications in “Biological Membranes: A Molecular Perspective from Computationand Experiment,” K.M. Merz and B. Roux, Eds. Birkhauser,Boston, pp 31-81, 1996 Discover:cvff-Dauber-Osguthorpe, P.; Roberts, V. A.; Osguthorpe, D. J.; Wolff, J.; Genest, M.; Hagler, A. T. (1988)“Structure and energetics of ligand binding to proteins: E. coli dihydrofolate reductase- trimethoprim,a drug-receptor system”, Proteins: Structure, Function and Genetics, 4, 31-47. cff-Hagler, A. T.; Ewig, C. S. “On the use of quantum energy su**ces in the derivation of molecularforce fields”, Comp. Phys. Comm.,84, 131-155 (1994). Hwang, M.-J.; Stockfisch, T. P.; Hagler, A. T. “Derivation of Class II force fields. 2. Derivation andcharacterization of a Class II force field, CFF93, for the alkyl functional group and alkane molecules”,J. Amer. Chem. Soc., 116, 2515-2525 (1994). Maple, J. R.; Hwang, M.-J.; Stockfisch, T. P.; Dinur, U.; Waldman, M.; Ewig, C. S; Hagler, A. T. “Derivation of Class II force fields. 1. Methodology andquantum force field for the alkyl functional group and alkane molecules”, J. Comput. Chem., 15, 162-182 (1994a). Maple, J. R.; Hwang, M.-J.; Stockfisch, T. P.; Hagler, A. T. “Derivation of Class II force fields. 3.Characterization of a quantum force field for the alkanes”, Israel J. Chem., 34, 195 -231 (1994b). ECEPP/2:Momany, F. A., McGuire, R. F., Burgess, A. W., &amp; Scheraga, H. A., (1975) Energy Parameters in PolypeptidesVII, Geometric Parameters, Partial Charges, Non-bonded Interactions, Hydrogen Bond Interactions and IntrensicTorsional Potentials for Naturally Ocurring Amino Acids, J. Phys. Chem. 79, 2361-2381.Nemethy, G., Pottle, M. S., &amp; Scheraga, H. A., (1983) Energy Paramters in Polypeptides, 9. Updating of GeometricalParameters, Non-bonding Interactions and Hydrogen Bonding Interactions for Naturally Occuring Amino Acids,J. PHys. Chem. 87, 1883-1887. Sippl, M. J., Nemethy, G., &amp; Scheraga, H. A., (1984) Intermolecular Potentials for Crystal Data 6. Determinationof Empirical Potentials for 0-H—O=C Hydrogen Bonds for Packing Configurations, J. Phys. Chem. 88, 6231-6633. GROMOS:Hermans, J., Berendsen, H. J. C., van Gunsteren, W. F., &amp; Postma, J. P. M., (1984) “A Consistent Empirical Potentialfor Water-Protein Interactions,” Biopolymers 23, 1Ott, K-H., B. Meyer (1996) “Parametrization of GROMOS force field for oligosaccharides and assessment ofefficiency of molecular dynamics simulations,” J Comp Chem 17, 1068-1084&gt; van Gunsteren, W. F., X. Daura and A.E. Mark (1997) “The GROMOS force field” in Encyclopaedia ofComputational Chemistry () MM2:Allinger, N. L. (1977) Conformational Analysis 130. MM2. A Hydrocarbon Force Field Utilizing V1 and V2 TorsionalTerms, J. Am. Chem.Soc. 99, 8127-8134.Allinger, N. L., Kok, R. A., and Imam, M. R. (1988) Hydrogen Bonding in MM2, J. Comp. Chem. 9, 591-595. Lii, J-H., Gallion,S., Bender,C., Wikstrom, H., Allinger, N. L., Flurchick, K. M., and Teeter, M. M.,(1989) MolecularMechanics (MM2) “Calculations on Peptides and on the Protein Crambin Using the Cyber 205” J. Comp. Chem. 10,503-513. MM3:NOTE: In some **s of this series, the MM3 stretch potential is written incorrectly. The proper potential is E= ….(7/12) (2.55(l-lo))2] (J-H. Lii, personal communication).Allinger, N. L., Yuh, Y. H., &amp; Lii, J-H. (1989) Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 1. J.Am. Chem. Soc. 111, 8551-8565. Hay, B. P., Yang, L., Lii, J-H., and Allinger, N. L. (1998) An extended MM3(96) force field for complexes of the group1A and 2A cations with ligands bearing conjugated ether donor groups, Theochem: J. Molecular Structure 428, 203-219 Lii, J-H., &amp; Allinger, N. L. (1989a) Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 2. VibrationalFrequencies and Thermodynamics, J. Am. Chem. Soc. 111, 8566-8575. Lii, J-H., &amp; Allinger, N. L. (1989b) Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 3. The van der WaalsPotentials and Crystal data for Aliphatic and Aromatic Hydrocarbons, J. Am. Chem. Soc. 111, 8576-8582. Lii, J-H., &amp; Allinger, N. L. (1991) The MM3 Force Field for Amides, Polypeptides and Proteins, J. Comp. Chem.12, 186-199. Lii, J-H., &amp; Allinger, N. L. (1998) Directional Hydrogen Bonding in the MM3 Force Field. II. J. Comp. Chem. 19,1001-1016. MM4:Allinger, N. L., K. Chen, and J-H Lii (1996) “An Improved Force Field (MM4) for Saturated Hydrocarbons,”J. Comp.Chem. 17, 642-668.Allinger, N. L., K. Chen, J. A. Katzenellenbogen, S. R. Wilson and G. M. Anstead (1996) “Hyperconjugative Effects onCarbon-Carbon BondLengths in Molecular Mechanics (MM4)” J. Comp. Chem. 17, 747-755. Allinger, N. L., and Y. Fan (1997) “Molecular Mechanics Studies (MM4) of Sulfides and Mercaptans,” J.Comp. Chem.18, 1827-1847. Nevens, N., K. Chen and N. L. Allinger (1996) “Molecular Mechanics (MM4) Calculations on Alkenes,” J. Comp. Chem.17, 669-694. Nevins, N., J-H. Lii and N.L. Allinger (1996) “Molecular Mechanics (MM4) Calculations on Conjugated Hydrocarbons,”J. Comp. Chem. 17, 695-729. Nevins, N., and N. L. Allinger (1996) “Molecular Mechanics (MM4) Vibrational Frequency Calculations for Alkenes anConjugated Hydrocarbons,” J. Comp. Chem. 17, 730-746. MMFF94:Halgren, T. A. (1992) J. Am. Chem. Soc. 114, 7827-7843.Halgren, T. A. (1996) “Merck Molecular Force Field. I. Basis, Form, Scope, Parameterization andPerformance of MMFF94,” J. Comp. Chem 17, 490-519. Halgren, T. A. (1996) “Merck Molecular Force Field. II. MMFF94 van der Waals and Electrostatic Parametersfor Intermolecular Interactions,” J. Comp. Chem. 17, 520-552. Halgren, T. A. (1996) “Merck Molecular Force Field. III. Molecular Geometrics and Vibrational Frequenciesfor MMFF94,” J. Comp. Chem. 17, 553-586. Halgren, T. A., and Nachbar, R. B. (1996) “Merck Molecular Force Field. IV. Conformational Energiesand Geometries,” J. Comp. Chem. 17, 587-615. Halgren, T. A. (1996) “Merck Molecular Force Field. V. Extension of MMFF94 using Experimental Data, AdditionalComputational Data and Empirical Rules,” J. Comp. Chem. 17, 616-641. Tripos:Clark, M., Cramer III, R. D., van Opdenhosch, N., (1989) Validation of the General Purpose Tripose 5.2 Force Field, J.Comp. Chem. 10, 982-1012. Comparisons and Evaluations:Engler, E. M., J. D. Andose and P. v. R. Schleyer (1973) “Critical Evaluation of Molecular Mechanics,” J. Am. Chem.Soc. 95, 8005-8025.Gundertofte, K., J. Palm, I. Pettersson and A. Stamvik (1991) “A Comparison of Conformational Energies Calculatedby Molecular Mechanics (MM2(85), Sybyl 5.1, Sybyl 5.21, ChemX) and Semiempirical (AM1 and PM3) Methods,” J.Comp. Chem. 12, 200-208. Gundertofte, K., T. Liljefors, P-O Norrby, I. Pattesson (1996) “Comparison of Conformational Energies Calculated bySeveral Molecular Mechanics Methods,” J. Comp. Chem. 17, 429-449 (1996). Hall, D., and N. Pavitt (1984) “A Appraisal of Molecular Force Fields for the Representation of Polypeptides,” J. Comp.Chem. 5, 441-450. Hobza, P., M. Kabelac, J. Sponer, P. Mejzlik and J. Vondrasek (1997) “Performance of Empirical Potentials (AMBER,CFF95, CVFF, CHARMM, OPS, POLTEV), Semiemprical Quantum Chemical Methods (AM1, MNDO/M, PM3) andab initio Hartree-Fock Method for Interaction of DNA Bases: Comparison of Nonempirical Beyond Hartree-Fock Results,”J. Comp. Chem. 18, 1136-1150. Kini, R. M., and H. J. Evans (1992) “Comparison of Protein Models Minimized by the All-Atom and United Atom Modelsin the AMBER force Field,” J. Biomol. Structure and Dynamics 10, 265-279. Roterman, I. K., Gibson, K. D., and Scheraga, H. A. (1989) “A Comparison of the CHARMM, AMBER, and ECEPP/2Potential for Peptides I.” J. Biomol. Struct. and Dynamics 7, 391-419. Roterman, I. K., Lambert, M. H., Gibson, K. D., and Scheraga, H. A. (1989) “A Comparison of the CHARMM, AMBER,and ECEPP/2 Potential for Peptides II.” J. Biomol. Struct. and Dynamics 7, 421-452. Whitlow, M., and M. M. Teeter (1986) “A Empirical Examination of Potential Energy Minimization using the Well-DeterminedStructure of the Protein Crambin,” J. Am. Chem. Soc. 108, 7163-7172. 转载自：资源信息科技","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"Lennard-Jones势的截断半径的选取有什么有什么要求？都和那些因素有关呢？","slug":"Lennard-Jones势的截断半径的选取有什么有什么要求？都和那些因素有关呢","date":"2016-05-19T02:08:11.000Z","updated":"2017-10-29T05:35:10.794Z","comments":true,"path":"406.html","link":"","permalink":"http://kangsgo.com/406.html","excerpt":"","text":"全原子模拟中通常情况选择1.0nm左右 选的越大越精确，计算越耗时，gromos力场常常是选择1.4nm。你有没比较这两个截断半径对结果的影响，如果显著，你可以讨论修改的原因，原则上截断半径应该是无限大才是真实情况，但是那样计算量会很大。 参考：康文斌@南京","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"NetCDF安装","slug":"NetCDF安装","date":"2016-05-11T08:16:30.000Z","updated":"2017-10-28T03:53:05.952Z","comments":true,"path":"403.html","link":"","permalink":"http://kangsgo.com/403.html","excerpt":"","text":"http://blog.sciencenet.cn/blog-653020-549872.html 留作备用","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"}]},{"title":"mdtraj安装","slug":"mdtraj安装","date":"2016-05-11T05:29:43.000Z","updated":"2017-10-28T03:56:32.622Z","comments":true,"path":"400.html","link":"","permalink":"http://kangsgo.com/400.html","excerpt":"","text":"mdtraj安装有两种方式，一种是用conda，比较方便省事，先安装conda123# 下载时要看清楚 Anaconda3 还是 2，对应的是 Python 3.5 和 2.7wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/Anaconda3-2.5.0-Linux-x86_64.shbash Anaconda3-2.5.0-Linux-x86_64.sh 设置安装目录以及添加环境变量到bashrc 若使用的为zshrc的话自己需要改一下，修改办法可以查阅我之前的博文 然后： 1conda install -c omnia mdtraj 另外一个办法就是用pip安装，我选用的这个方法： 1pip install numpy cython 因为我直接安装报错，提示以上两个版本不够，所以先安装numpy和cython 1pip install mdtraj -i https://pypi.douban.com/simple 选用的是豆瓣源，因为官方老是下载不下来```` 镜像可以参考： http://pypi.douban.com/ 豆瓣 http://pypi.hustunique.com/ 华中理工大学 http://pypi.sdutlinux.org/ 山东理工大学 http://pypi.mirrors.ustc.edu.cn/ 中国科学技术大学","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"},{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"}]},{"title":"mdtraj牛逼的轨迹转化软件！","slug":"mdtraj牛逼的轨迹转化软件","date":"2016-05-11T03:35:55.000Z","updated":"2017-10-28T03:55:36.770Z","comments":true,"path":"398.html","link":"","permalink":"http://kangsgo.com/398.html","excerpt":"","text":"感谢 康文斌@南京 提供这么好的工具信息 玩了bio3d的同学相比也发现了，其并不支持xtc的轨迹，而是只支持dcd的轨迹，这就麻烦了，众所周知很难兼容，这里再次感谢康文斌@南京提供的这么有用的轨迹转化信息！ http://mdtraj.org/development/mdconvert.html 待会儿马上就试","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"}]},{"title":"MDAnalysis","slug":"mdanalysis","date":"2016-05-11T03:10:20.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"396.html","link":"","permalink":"http://kangsgo.com/396.html","excerpt":"","text":"https://code.google.com/p/mdanalysis/ &nbsp; 参考文献：支持多种动力学软件轨迹文件的后处理分析：MDAnalysis","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"装机推荐","slug":"装机推荐","date":"2016-05-11T01:41:37.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"393.html","link":"","permalink":"http://kangsgo.com/393.html","excerpt":"","text":"留有备用 http://bbs.ngacn.cc/read.php?tid=8192610","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"Bio3D安装","slug":"bio3d","date":"2016-05-10T14:13:38.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"386.html","link":"","permalink":"http://kangsgo.com/386.html","excerpt":"","text":"感谢厦大-Ares 提供这么好的工具信息 官方安装地址：点我查看 可以看出ubuntu的安装最简单的方式如下： apt-get install r-base-core netcdf-bin libnetcdf-dev libxml2-dev \\ libcurl3-dev seaview muscle pymol但是ubuntu的R编译包为3.0.2，bio3D要求为3.1+ 所以R需要自己编译 R语言包在这里下载点我下载 R语言安装方法： tar xzf R-3.2.5.tar.gz cd R-3.2.5 mkdir -p /home/kangsgo/mdinstall/R ./configure –prefix=/home/kangsgo/mdinstall/R –enable-R-shlib make make check make install具体的官方安装方法可以：点我查看 环境变量设置： vim ~/.bash_profile #添加到PATH中： PATH=/home/work/R/bin:$PATH source ~/.bash_profile #直接运行R命令（大写）bio3D 安装办法：进入R：install.packages(“bio3d”, dependencies=TRUE)q() 参考文献：[R]Linux下R语言安装R语言官网Bio3D官网","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"[转载]linux screen 命令详解","slug":"[转载]linux screen 命令详解","date":"2016-05-10T04:08:36.000Z","updated":"2017-10-29T02:52:56.853Z","comments":true,"path":"376.html","link":"","permalink":"http://kangsgo.com/376.html","excerpt":"","text":"由于做MD,近期搞了一个linux的小型服务器，用来协助跑MD,但是关闭putty之后相当于终端关闭了，以前用过screen，所以现在重新了解一下：Tang的博文非常不错，所以转载给自己留着备用 一、背景系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。 二、简介GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。 GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。 会话恢复只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。 多窗口在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。会话共享Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。GNU’s Screen 官方站点：http://www.gnu.org/software/screen/ 三、语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明 -A 将所有的视窗都调整为目前终端机的大小。-d &lt;作业名称&gt; 将指定的screen作业离线。-h &lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r &lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S &lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 四、常用screen参数screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -d -r yourname -&gt; 结束当前session并回到yourname这个session 在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。C-a ? -&gt; 显示所有键绑定信息C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口C-a n -&gt; Next，切换到下一个 windowC-a p -&gt; Previous，切换到前一个 windowC-a 0..9 -&gt; 切换到第 0..9 个 windowCtrl+a [Space] -&gt; 由视窗0循序切换到视窗9C-a C-a -&gt; 在两个最近使用的 window 间切换C-a x -&gt; 锁住当前的 window，需用用户密码解锁C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。C-a w -&gt; 显示所有窗口列表C-a t -&gt; Time，显示当前时间，和系统的 loadC-a k -&gt; kill window，强行关闭当前的 windowC-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样C-b Backward，PageUpC-f Forward，PageDownH(大写) High，将光标移至左上角L Low，将光标移至左下角0 移到行首$ 行末w forward one word，以字为单位往前移b backward one word，以字为单位往后移Space 第一次按为标记区起点，第二次按为终点Esc 结束 copy modeC-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上 五、使用 screen5.1 安装screen流行的Linux发行版（例如Red Hat Enterprise Linux）通常会自带screen实用程序，如果没有的话，可以从GNU screen的官方网站下载。 [root@TS-DEV ~]# yum install screen[root@TS-DEV ~]# rpm -qa|grep screenscreen-4.0.3-4.el5[root@TS-DEV ~]# 5.2 创建一个新的窗口安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨： [root@TS-DEV ~]# screen -S davidscreen启动后，会创建第一个窗口，也就是窗口No. 0，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如： [root@TS-DEV ~]# screen vi david.txtscreen创建一个执行vi david.txt的单窗口会话，退出vi 将退出该窗口/会话。 5.3 查看窗口和窗口名称打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样： 0$ bash 1-$ bash 2$ bash这个例子中我开启了三个窗口，其中号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。 Screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键C-a A来为当前窗口重命名，按下快捷键后，Screen会允许你为当前窗口输入新的名字，回车确认。 5.4 会话分离与恢复你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/david.txt文件： [root@TS-DEV ~]# screen vi /tmp/david.txt之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示： 暂时中断会话 29144351-ff7e78c079a44f51ae44d48b6942b87f 半个小时之后回来了，找到该screen会话： [root@TS-DEV ~]# screen -ls 29144759-7cea9fc3f5f4481ab21df8bd017c88ef 重新连接会话：[root@TS-DEV ~]# screen -r 12865一切都在。 当然，如果你在另一台机器上没有分离一个Screen会话，就无从恢复会话了。 这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来： 3 5.5 清除dead 会话如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话： 4 5.6 关闭或杀死窗口正常情况下，当你退出一个窗口中最后一个程序（通常是bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用C-a k，这个快捷键杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。 如果一个Screen会话中最后一个窗口被关闭了，那么整个Screen会话也就退出了，screen进程会被终止。 除了依次退出/杀死当前Screen会话中所有窗口这种方法之外，还可以使用快捷键C-a :，然后输入quit命令退出Screen会话。需要注意的是，这样退出会杀死所有窗口并退出其中运行的所有程序。其实C-a :这个快捷键允许用户直接输入的命令有很多，包括分屏可以输入split等，这也是实现Screen功能的一个途径，不过个人认为还是快捷键比较方便些。 六、screen 高级应用6.1 会话共享还有一种比较好玩的会话恢复，可以实现会话共享。假设你在和朋友在不同地点以相同用户登录一台机器，然后你创建一个screen会话，你朋友可以在他的终端上命令： [root@TS-DEV ~]# screen -x这个命令会将你朋友的终端Attach到你的Screen会话上，并且你的终端不会被Detach。这样你就可以和朋友共享同一个会话了，如果你们当前又处于同一个窗口，那就相当于坐在同一个显示器前面，你的操作会同步演示给你朋友，你朋友的操作也会同步演示给你。当然，如果你们切换到这个会话的不同窗口中去，那还是可以分别进行不同的操作的。 6.2 会话锁定与解锁Screen允许使用快捷键C-a s锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被Screen中的进程接收到。快捷键C-a q可以解锁一个会话。 也可以使用C-a x锁定会话，不同的是这样锁定之后，会话会被Screen所属用户的密码保护，需要输入密码才能继续访问这个会话。 6.3 发送命令到screen会话在Screen会话之外，可以通过screen命令操作一个Screen会话，这也为使用Screen作为脚本程序增加了便利。关于Screen在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对Screen的操作： [root@TS-DEV ~]# screen -S sandy -X screen ping www.baidu.com这个命令在一个叫做sandy的screen会话中创建一个新窗口，并在其中运行ping命令。 6.4 屏幕分割现在显示器那么大，将一个屏幕分割成不同区域显示不同的Screen窗口显然是个很酷的事情。可以使用快捷键C-a S将显示器水平分割，Screen 4.00.03版本以后，也支持垂直分屏，快捷键是C-a |。分屏以后，可以使用C-a 在各个区块间切换，每一区块上都可以创建窗口并在其中运行进程。 可以用C-a X快捷键关闭当前焦点所在的屏幕区块，也可以用C-a Q关闭除当前区块之外其他的所有区块。关闭的区块中的窗口并不会关闭，还可以通过窗口切换找到它。 5 6.5 C/P模式和操作screen的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。使用快捷键C-a 或者C-a [可以进入copy/paste模式，这个模式下可以像在vi中一样移动光标，并可以使用空格键设置标记。其实在这个模式下有很多类似vi的操作，譬如使用/进行搜索，使用y快速标记一行，使用w快速标记一个单词等。关于C/P模式下的高级操作，其文档的这一部分有比较详细的说明。 一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在copy/paste buffer中，并退出copy/paste模式。在正常模式下，可以使用快捷键C-a ]将储存在buffer中的内容粘贴到当前窗口。 6 6.6 更多screen功能同大多数UNIX程序一样，GNU Screen提供了丰富强大的定制功能。你可以在Screen的默认两级配置文件/etc/screenrc和$HOME/.screenrc中指定更多，例如设定screen选项，定制绑定键，设定screen会话自启动窗口，启用多用户模式，定制用户访问权限控制等等。如果你愿意的话，也可以自己指定screen配置文件。 以多用户功能为例，screen默认是以单用户模式运行的，你需要在配置文件中指定multiuser on 来打开多用户模式，通过acl*（acladd,acldel,aclchg…）命令，你可以灵活配置其他用户访问你的screen会话。更多配置文件内容请参考screen的man页。 转载自：Tang的linux screen 命令详解","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"gromacs DPPC膜初体验","slug":"gromacs DPPC膜初体验","date":"2016-04-28T14:23:09.000Z","updated":"2017-10-28T15:00:42.311Z","comments":true,"path":"363.html","link":"","permalink":"http://kangsgo.com/363.html","excerpt":"","text":"最近一直在忙着我的论文修改，现在总算要告一段落了，马上要开启新的篇章，其中一个部分就是膜的体验，先准备学习以下gromacs李继存老师翻译的教程，这里记录一下学习的过程： DPPC膜中的KALP15： 教程使用的文章是06年的一篇3.9分的文章，准备学习完以后参考一下他的分析步骤：文献查看 第一步：准备拓扑 多肽如何准备的参考资料并未详细给出，由于我也是第一次学，自己也先跳过，你可以在文章底部中文教程下载也可以KALP-15_princ.pdb 1.pdb进行处理 1gmx pdb2gmx -f KALP-15_princ.pdb -o KALP-15_processed.gro -ignh -ter -water spc ignh选项指示gmx pdb2gmx忽略输出中的H原子. 默认情况下, xLeap会给出全原子结构(由于AMBER力场使用显式的氢). 在AMBER的命名约定中, 这些H原子的命名可能与GROMOS96力场中的不同. 如果让gmx pdb2gmx忽略输入的所有H原子, 它只会添加需要的那些.所以如果在蛋白配体复合物模拟中选用amber的话那么也不应该加-ignh选项，否则可能会干掉一些氢 选择13：GROMOS96 53A6力场两端不需要封端，所以均选择：None 2.修改拓扑 下载膜：连接地址 dppc128.pdb - 含128个DPPC脂分子的双脂膜dppc.itp - DPPC的分子类型定义lipid.itp - Berger脂分子参数 你也可以在我这里dppc下载好了的 将gromos53a6.ff目录中文件复制出来，也可以在我这里下载已经打包好了的，gromos53a6_lipid.ff 接下来, 将lipid.itp中的[ atomtypes ], [ nonbond_params ]和[ pairtypes ]部分复制粘贴到ffnonbonded.itp中相应的行. 你可以发现lipid.itp中的[ atomtypes ]节缺少原子编号(at.num列), 因此添加上编号. 修改后的行应该是: 123456789101112LO 8 15.9994 0.000 A 2.36400e-03 1.59000e-06 ;carbonyl O, OPLSLOM 8 15.9994 0.000 A 2.36400e-03 1.59000e-06 ;carboxyl O, OPLSLNL 7 14.0067 0.000 A 3.35300e-03 3.95100e-06 ;Nitrogen, OPLS LC 6 12.0110 0.000 A 4.88800e-03 1.35900e-05 ;Carbonyl C, OPLSLH1 6 13.0190 0.000 A 4.03100e-03 1.21400e-05 ;CH1, OPLSLH2 6 14.0270 0.000 A 7.00200e-03 2.48300e-05 ;CH2, OPLS LP 15 30.9738 0.000 A 9.16000e-03 2.50700e-05 ;phosphor, OPLSLOS 8 15.9994 0.000 A 2.56300e-03 1.86800e-06 ;ester oxygen, OPLSLP2 6 14.0270 0.000 A 5.87400e-03 2.26500e-05 ;RB CH2, Bergers LJLP3 6 15.0350 0.000 A 8.77700e-03 3.38500e-05 ;RB CH3, Bergers LJLC3 6 15.0350 0.000 A 9.35700e-03 3.60900e-05 ;CH3, OPLSLC2 6 14.0270 0.000 A 5.94700e-03 1.79000e-05 ;CH2, OPLS 在[ nonbond_params ]节中, 你可以看到一行;; parameters for lipid-GROMOS interactions., 删除这一行以及所有后续行, 因为这些非键组合特定地用于已经废弃的ffgmx力场. 移除这些行后, 会根据GROMOS96 53A6力场的标准组合规则生成蛋白质和脂分子之间的相互作用参数. 文件中也有涉及HW原子类型的非键相互作用, 由于它们都是零, 你也可以删除这些行, 否则请将HW重命名为H, 以便与GROMOS96 53A6的命名约定兼容. 如果你不进行重命名或移除这些行, 后面执行gmx grompp时会导致致命错误. 追加[ dihedraltypes ]的内容到ffbonded.itp中相应的节. 这些行看起来差异很大, 但无关紧要. 它们是Ryckaert-Bellemans二面角, 与默认GROMOS96 53A6力场中使用的标准周期性二面角形式不同. 最后, 将topol.top文件中的#include语句由 1#include &quot;gromos53a6.ff/forcefield.itp&quot; 修改为 1#include &quot;gromos53a6_lipid.ff/forcefield.itp&quot; 最后, 我们需要包含DPPC分子的特定参数. 做法非常简单. 在你的topol.top文件中添加一行#include “dppc.itp”即可, 放在蛋白质位置限制部分的后面, 位置限制部分是蛋白质[ moleculetype ]定义的结束. 这些做法与在拓扑文件中添加任何其他小分子或溶剂类似. 在本节及整个教程中, 绿色文本表示你要添加的行, 其他文本(黑色)表示修改前拓扑中已有的内容. 12345678910; Include Position restraint file#ifdef POSRES#include &quot;posre.itp&quot;#endif; Include DPPC chain topology#include &quot;dppc.itp&quot;; Include water topology#include &quot;gromos53a6_lipid.ff/spc.itp&quot; 如果你正确地遵循了上面的所有步骤, 你就会得到一个全功能的力场, 可与gmx pdb2gmx一起用于处理其他膜蛋白. 这样做不必手动修改topol.top. 将新的gromos53a6_lipid.ff目录放于$GMXLIB下就可以在整个系统中使用这个力场了. 3.定义单位晶胞并添加溶剂 比起水中的蛋白质来, 为膜蛋白定义单位晶胞更复杂一些. 构建单位晶胞时有几个关键步骤: 在相同的坐标系中对蛋白和膜进行取向在蛋白周围堆积脂分子使用水进行溶剂化 1.蛋白质和膜的取向(1) 使用gmx grompp对仅含有DPPC的体系生成.tpr文件. 你可以使用任何有效的.mdp文件, 相应于纯DPPC的拓扑文件. 这里是一个示例.mdp文件, 以及一个拓扑文件. 注意拓扑文件非常简单, 仅包含了dppc.itp和spc.itp, 用以读入DPPC和水的参数. 就这么简单! 运行gmx grompp: 这里教程没有写命令，我暂时这么写： 1editconf_mpi -f dppc128-q.pdb -o dppc128.gro -princ 选择2 DPP 正确与否待考 1gmx grompp -f minim.mdp -c dppc128.gro -p topol_dppc.top -o em.tpr 你可能会得到一个致命错误, 像这样, 但在这种情况下对上面的命令可以安全地使用-maxwarn 1选项来忽略错误. 可以这样做的原因见这里. 请注意 这一步是使用topol_dppc.top的唯一一步, 此文件不能用于任何其他目的, 你不应该将它用于本教程中的 任何 剩余步骤 对复杂的分子, 去除周期性的子程序可能会崩溃, 在这种情况下你可以使用gmx trjconv.但是后面教程里做了 1gmx grompp -f minim.mdp -c dppc128.gro -p topol_dppc.top -o em.tpr (2) 使用gmx trjconv移除周期性 1gmx trjconv -s em.tpr -f dppc128.gro -o dppc128_whole.gro -pbc mol -ur compact 这一步产生的结构有一定的飞线，原因待考 vmdscene 现在查看下这个.gro文件的最后一行, 它对应于DPPC单位晶胞的x/y/z盒向量. 我们需要在相同的坐标系内调整KALP多肽的取向, 并将多肽的质心置于盒子的中心: 1gmx editconf -f KALP-15_processed.gro -o KALP_newbox.gro -c -box 6.41840 6.44350 6.59650 2. 在蛋白四周堆积脂分子 目前我发现, 围绕嵌入蛋白质堆积脂分子的最简单方法是InflateGRO方法(参考文献), 你可以在这里inflategro. 请注意, 我发布的代码是我自己保存的InflateGRO原始版本的副本, 而 不是 来自作者的InflateGRO2. 下载上面链接中的文件, 将其重命名为inflategro.pl再继续. 首先, 整合蛋白质和双脂层的结构文件: 1cat KALP_newbox.gro dppc128_whole.gro &gt; system.gro 移除不需要的行(来自KALP结构的盒向量, 来自DPPC结构的标题信息), 并相应地更新坐标文件的第二行(总原子数). InflateGRO脚本的作者建议对蛋白质的重原子使用非常强的位置限制力, 以保证在EM过程中蛋白质的位置不发生改变. 在拓扑中添加新的#ifdef语句, 调用特殊的位置限制, 这样你的拓扑现在就包含类似下面的部分: 123456789101112131415; Include Position restraint file#ifdef POSRES#include \"posre.itp\"#endif; Strong position restraints for InflateGRO#ifdef STRONG_POSRES#include \"strong_posre.itp\"#endif; Include DPPC chain topology#include \"dppc.itp\"; Include water topology#include \"gromos53a6_lipid.ff/spc.itp\" 现在就可以使用gmx genrestr生成新的位置限制文件: 1gmx genrestr -f KALP_newbox.gro -o strong_posre.itp -fc 100000 100000 100000 在用于能量最小化的.mdp文件中, 添加一行define = -DSTRONG_POSRES以保证使用这些新的位置限制. 然后, 简单地按照InflateGRO的指示(包含在脚本自身中)做, 过程很简单. 对脂分子的位置使用因子4进行缩放: perl inflategro.pl system.gro 4 DPPC 14 system_inflated.gro 5 area.dat由于InflateGRO脚本对命令行变量顺序的要求非常严格, 这里需要给出一个简略的说明: system.gro - 将要施加缩放的输入坐标文件的名称4 - 施加的缩放因子, 值&gt;1表示扩增, 值&lt;1表示收缩/压缩DPPC - 施加缩放的脂分子的残基名称14 - 搜索脂分子的截断半径(单位为Å), 处于此半径内的脂分子会被删除system_inflated.gro - 输出文件的名称5 - 计算每个脂分子面积时所用的格点间距(单位为Å)area.dat - 输出文件, 包含每个脂分子的面积信息, 对确定结构是否合适很有帮助 记下删除了多少脂分子, 并相应地更新拓扑文件中[ molecules ]部分的内容. There are 1 lipids within cut-off range…1 will be removed from the upper leaflet…0 will be removed from the lower leaflet… 貌似我的是1个运行能量最小化. 然后, 使用因子0.95收缩脂分子(假定你使用了默认的名称, 能量最小化的结果文件为confout.gro): perl inflategro.pl confout.gro 0.95 DPPC 0 system_shrink1.gro 5 area_shrink1.dat 在网上找到一个脚本，脚本如下： 1234567891011121314151617perl inflategro.pl minimizedZ.gro 0.95 DPPC 0 shrinked1.gro 5 area_shrink1.datgrompp -f minim.mdp -c shrinked1.gro -p topol.top -o minimizedZ2.tprmdrun -v -deffnm minimizedZ2for i in $(seq 1 20)doperl inflategro.pl minimizedZ2.gro 0.95 DPPC 0 shrinked2.gro 5 area_shrink1.dat $igrompp -f minim.mdp -c shrinked2.gro -p topol.top -o minimizedZ2.tpr $imdrun -v -deffnm minimizedZ2 $idone","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"去除膜蛋白内的水分子脚本","slug":"去除膜蛋白内的水分子脚本","date":"2016-04-27T04:33:53.000Z","updated":"2017-10-28T15:09:14.347Z","comments":true,"path":"360.html","link":"","permalink":"http://kangsgo.com/360.html","excerpt":"","text":"1234567891011121314151617181920212223set lipid [atomselect top &quot;resname $lipres&quot;];set lipidbox [measure minmax $lipid];set xmin [lindex [lindex $lipidbox 0] 0];set xmax [lindex [lindex $lipidbox 1] 0];set ymin [lindex [lindex $lipidbox 0] 1];set ymax [lindex [lindex $lipidbox 1] 1];set zmin [lindex [lindex $lipidbox 0] 2];set zmax [lindex [lindex $lipidbox 1] 2];set selA [atomselect top &quot;same residue as water and z&gt;$zmin and z&lt;$zmax&quot;] set selB [atomselect top &quot;all not &#123;same residue as water and z&gt;$zmin and z&lt;$zmax&#125;&quot;] puts &quot;all not &#123;same residue as water and z&gt;$zmin and z&lt;$zmax&#125;&quot;set rmwatlen [llength [$selA get resid]];set rmwatnum [expr $rmwatlen/3];puts &quot;remove water atom is $rmwatlen, and molecular is $rmwatnum&quot;$selB writepdb rmfinal.pdbset all [atomselect top water]set allwat [expr [llength [$all get resid]]/3];set rmwatnum [expr $allwat-$rmwatnum];puts &quot;Original water molecules number is $allwat&quot;puts &quot;Water molecules left $rmwatnum&quot;;$lipres替换成你要的磷脂resname 第一个脚本是可以单独抽取出来命名成你自己的脚本，比如test.tcl，然后在工作目录下直接source test.tcl就好，直接生成删除水后的pdb，注意修改里面lipids的resname，比如POPC、POPE等第二个是加了命名空间的，调用需要加命名空间加函数名的 第二个的可以新建一个文件夹，然后把sysTool.tcl和index的那个tcl放到一起，一个文件夹中，然后在vmd的安装目录下，有个vmd.rc的文件打开，在末尾加入source d:/WorkSpace/MD/VMDScript/SysTool/sysTool.tclsource d:/WorkSpace/MD/VMDScript/SysTool/sysTool.tcl注意source后直接写你的新建的那个文件夹名称windows下注意斜杠和反斜杠的区别 来源：刘胜堂@苏州 如有侵权，请与博主联系","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"蛋白质中那些氨基酸或基团可以结合金属离子","slug":"蛋白质中那些氨基酸或基团可以结合金属离子","date":"2016-04-26T15:12:45.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"358.html","link":"","permalink":"http://kangsgo.com/358.html","excerpt":"","text":"蛋白质中那些氨基酸或基团可以结合金属离子哪些氨基酸的侧链可与金属离子结合，这些配体属于软碱还是硬碱？ &nbsp; A：蛋白质中最容易结合金属离子的大概是巯基（-SH）。这个也是很多金属离子毒性的来源。巯基在蛋白质中存在于半胱氨酸中。有时两个半胱氨酸通过脱氢形成二硫键（-S-S-）而使不同肽链连接起来。二硫键仍然具有结合金属离子的能力。 氨基、羟基等一切可提供孤对电子的均有可能与金属离子结合. 参考文献：百度作业帮&nbsp;","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"[读书笔记]高分分子模拟文章","slug":"[读书笔记]高分分子模拟文章","date":"2016-04-19T08:28:36.000Z","updated":"2017-10-29T02:50:58.342Z","comments":true,"path":"352.html","link":"","permalink":"http://kangsgo.com/352.html","excerpt":"","text":"标题：Molecular Dynamics and QM/MM Calculations predict the Substrate-Induced Gating of Cytochrome P450 BM3 and the Regio and Stereo-selctivity of Fatty Acid Hydroxylation 摘要：通过scratch理论预测酶的活性。我们发现MD模拟和QM/MM计算脂肪酸羟化酶P450-BM3，预测脂肪酸激酶结合机制，其enantio/regio-selective 羟化反应通过激活种属酶？？，复合物Ⅰ.MD模拟展示底物进入设计氢键联系（Pro25，Glu43和Leu188），其诱导一个非常大的构象重排，通过拖拽A螺旋，β1折叠和F/G 环关闭底层通道.接下来，在底层通道的底部，残基Phe87控制位置选择通过限制底层链的卷缩（curl up）和并排复合物Ⅰ的CH2位置ω-1/ω-2/ω-3，同时阻止进入最末位置，ω-CH3. Phe87 控制构象选择性通过对映选择阻碍pro-S C-H 键，因此偏爱R-羟化作用。实际上，MD模拟突变Phe87Ala提示显著的ω-强化作用。研究发现，这远远超过了x-ray 结构的数据，阐述理论预测能力和其洞察力，能够潜在的使用作为实验的一部分对于P450-BM3最终位点选择C-H功能化能力。 |翻译的很差····主要是给自己看的|","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"蛋白为什么在低温下也会变性","slug":"蛋白为什么在低温下也会变性","date":"2016-04-11T16:35:47.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"347.html","link":"","permalink":"http://kangsgo.com/347.html","excerpt":"","text":"&nbsp; W：In cold water, the protein is surrounded by ordered water molecules in the hydration shell.Molecules in the shell are highly ordered and have low energy.Folding of a protein is (largely) driven by the entropic penalty of ordered water at room temperature (called the hydrophobic effect), whereas the low enthalpic contribution of these ordered water molecules is what drives cold denaturation.It is due to this that during cold denaturation, there is release of heat, whereas heat is absorbed in heat denaturation. &nbsp; 参考文献：点我查看 Bioms QQ群","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"Smartdraw 绘图软件学习","slug":"Smartdraw 绘图软件学习","date":"2016-04-08T03:39:41.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"345.html","link":"","permalink":"http://kangsgo.com/345.html","excerpt":"","text":"SmartDraw是世界上最流行的商业绘图软件。2006 年获美国政府司法部 (U.S. Department of Justice) 专用软件，2007获美国政府商务部 (US Department of Commence)选用。 ——摘自百度百科，软件待研究","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[]},{"title":"[转载]利用PubReMiner进行科研初步选题","slug":"[转载]利用PubReMiner进行科研初步选题","date":"2016-03-28T10:03:53.000Z","updated":"2017-10-29T03:32:25.040Z","comments":true,"path":"333.html","link":"","permalink":"http://kangsgo.com/333.html","excerpt":"","text":"今天在科研动力看到一篇关于初步选题的文章，正好最近在找选题思路，所以就理一理，把内容结合自己的实际情况来做一遍，有兴趣的同学可以看文章原文： 主要讲的内容为如何利用 PubReMiner 进行科研选题。 粗略搜索 首先要根据导师的意愿在 PubMed 中进行粗略的搜索。 我的导师主要是想要我做分子模拟和实验相结合的内容，由于师兄主要从事芳香烃受体方面，分子模拟主要能够做突变以及和配体结合性的分析，所以自己先找的两个关键词是分子模拟（molecular simulation）与突变（Mutagenesis）因此，要先在 PubMed 中进行一下粗略的搜索，看看当前有多少研究，并且可以把检索式保存下来，这样可以将来在 PubReMiner 中进行分析。 好了，那就去 PubMed 吧，打开网址 http://www.ncbi.nlm.nih.gov/pubmed，记住不要一般搜索，要进行高级搜索。如果一般搜索的话，出来的文献太多。选择「Advaced」打开高级搜索选项。 QQ截图20160328182105 只搜到两篇····· 大家先看原文吧https://www.howsci.com/3039.html 这里编辑代写","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"输出trr精度文章/制定帧数","slug":"输出trr精度文章制定帧数","date":"2016-03-25T09:33:56.000Z","updated":"2017-10-29T03:34:24.619Z","comments":true,"path":"329.html","link":"","permalink":"http://kangsgo.com/329.html","excerpt":"","text":"nstxout = 0 ; save coordinates every 2 psnstvout = 0 ; save velocities every 2 ps4.6.x 使用-b -e -dt 来控制指定帧数 例：1trjconv_mpi -f mdwholeNOjump.xtc -s 1stframe.pdb -b 49000 -e 50000 -dt 100 -n index.ndx -o lastwt.pdb","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"[读书笔记]生物信息学分析鸟类AhR和二恶英对于解密亚型，配体和物种特应性激活之间的联系","slug":"[读书笔记]生物信息学分析鸟类AhR和二恶英对于解密亚型，配体和物种特应性激活之间的联系","date":"2016-03-22T04:27:25.000Z","updated":"2017-11-12T07:40:11.301Z","comments":true,"path":"322.html","link":"","permalink":"http://kangsgo.com/322.html","excerpt":"","text":"原文标题：In Silico Analysis of the Interaction of Avian Aryl Hydrocarbon Receptors and Dioxins to Decipher Isoform‑, Ligand‑, and Species-Specific Activations 影响因子：5.4 摘要：AhR调节有毒的TCDD和其他的二恶英类似物（DLCs）的应答。鸟类物种拥有多种AhR的亚型（AHR1，AHR1β和AHR2），其显示出物种特异行和亚型特异性对于配体的应答。依据鸟类AHRs的结构功能来解释配体的偏爱性，我们生成同源模型基于含有配体的人源HIF-2α（PDB 3H7W）。分子对接使用ASEDock对TCDD和其它的DLCs使用AHR1s和AHR2s表明用同类卤元素代替氯原子随着数量增加而结合能增加。可能的相互作用对于AHR的内源性配体，FICZ对于AHRs的相互作用能在鸟类AHRs中低于TCDD。分子动力学揭露mean square displacements在Ile324和Ser380对于在鸡中的TCDD结合的AHR1，对于TCDD最为敏感的物种，会更小对于其它的鸟类AHR1s，提示动力学稳定性对于这些氨基酸残基贡献对于TCDD具有偏爱性。对于AHR2，相应的残基( (Val/Ser or Val/Ala type))对于不同的TCDD敏感性没有可靠数据。利用立体的参考联系位点模型显示TCDD结合对于鸟类AHRs稳定性可能归功于溶剂化效应依赖于对应的两个氨基酸残基Ile324和Ser380在鸡的AHR1中特点不同。这次研究阐明在生物信息模拟中AHRs和配体们可以被用来预测亚型，配体和物种特异性之间的联系。 简单介绍：在卵内和体外实验显示鸡对于DLCs物质为最敏感物种，黑脚信天翁和环颈雉为中度敏感，普通的鸬鹚和普通的燕鸥是最低敏感性物种。这些机理并不清楚。 另外需要思考的有两点： 第一点：it is not clear why the two amino acid residues in the LBD are critical for the interaction of TCDD−AHR1 and not for TCDD−AHR2. 第二点：it is unknown why the Ile−Ser type of AHR1 is more sensitive to TCDD than other types of AHR1s. 方法： 数据和模板准备 同源建模 分子对接 报告基因 分子动力学/分子模拟 &nbsp;","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"在pubmed中设定影响因子筛选","slug":"在pubmed中设定影响因子筛选","date":"2016-03-22T03:37:57.000Z","updated":"2017-10-29T03:23:49.799Z","comments":true,"path":"310.html","link":"","permalink":"http://kangsgo.com/310.html","excerpt":"","text":"首先下载2015年的sci的Excel，IF-2015 打开后选择影响因子大于你想要的影响因子（这里我们选择的大于5）的标题，如下图： 捕获 选择性粘贴进入word中 捕获3 按Ctrl+H切换到替换模式，在替换中输入换行符“^p”，替换为”[journal] or “ 注意引号也要输入进入 删除最后一个or “在第一个添加” 进入ncbi的pumbed，点击mange Filters 捕获2 创建顾客自定义Filters 捕获 拷贝一下，完成！ 捕获 搜索的时候选择一下即可 参考文献：生物信息学日课","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"[原创]Epock官方手册翻译与理解","slug":"[原创]Epock官方手册翻译与理解","date":"2016-03-09T09:55:52.000Z","updated":"2017-10-28T15:17:37.560Z","comments":true,"path":"306.html","link":"","permalink":"http://kangsgo.com/306.html","excerpt":"","text":"Epock是一个可以动态计算结合腔大小的一个软件，由于有VMD的可视化软件，所以非常的容易上手，简单~ 官网地址：点我查看 翻译文档：点我下载","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"VMD操作笔记","slug":"vmd操作笔记","date":"2016-03-08T05:42:19.000Z","updated":"2017-10-28T03:26:46.619Z","comments":true,"path":"303.html","link":"","permalink":"http://kangsgo.com/303.html","excerpt":"","text":"1.保存图片： File-&gt;;Render-&gt;;Start Rendering","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"VMD","slug":"VMD","permalink":"http://kangsgo.com/tags/VMD/"}]},{"title":"gromacs续跑问题","slug":"gromacs续跑问题","date":"2016-03-03T15:28:45.000Z","updated":"2017-10-28T04:08:21.020Z","comments":true,"path":"165.html","link":"","permalink":"http://kangsgo.com/165.html","excerpt":"","text":"由于我EVO跑了50ns并未平衡，所以还需要继续加跑时间查看，在网上查了一些续跑的资料，现在续跑分享给大家～ 1.重启模拟（未测试） 适用范围，突然停机等等，有检查点生成的 1mdrun -s md_0_1.tpr -cpi state.cpt –append _(不能改变核数) 以上 state.cpt 文件为最新生产的断点文件（ mdrun 会保存另外一个断点文件：_stateprev.cpt，为上一个时刻保存的断点文件，双保险。）使用 “-append “ 的作用是将模拟输出添加到已有文件中，包括轨迹文件，记录文件，能量文件等，相同帧的信息将被后生产的信息覆盖。 2.续跑！ 续跑50ns命令1gmx convert-tpr -s md_0_1.tpr -f md_0_1.cpt -e md_0_1.edr -extend 50000 -o md_0_2.tpr 其中”-extend 1000”表示延长5000ps的模拟时间。 原因和方法可以看这里：gmx mdrun 我写的如下： 1[完整] mdrun -s next.tpr -cpi previous.cpt //参考：嘉晔老师 看看续跑第0步的温度是不是和以前最后一步的温度一样, 一样的话, 说明使用了以前的速度, 否则的话, 是重新产生的速度, 你需要重新平衡, 失去了续跑的意义. 我每次都是使用保有速度的gro, mdp中gen_vel=no 重新创建tpr, 再mdrun, 麻烦点. 但不会出现问题 //参考:李继存老师 [简写] gmx mdrun -deffnm md_0_2.tpr -o 输出全精度轨迹，默认为traj.trr待考 3.轨迹整合123_trjcat -f traj1.trr traj2.trr.... __-o traj_all.trreneconv -f ener1.edr ener2.edr... __-o ener_all.edr_","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"gromacs","slug":"gromacs","permalink":"http://kangsgo.com/tags/gromacs/"}]},{"title":"GMXPBSAtool安装与使用经验教程","slug":"GMXPBSAtool安装与使用经验教程","date":"2016-03-01T04:03:05.000Z","updated":"2017-10-18T12:17:14.230Z","comments":true,"path":"295.html","link":"","permalink":"http://kangsgo.com/295.html","excerpt":"","text":"由于自己在使用G_mmbps时发现并不是那么准确,反复计算均未得到自己想要的结果,所以想试一下GMXPBSAtool得到的结果,但是安装和调试bug就花费了我一上午的时间,为了帮助大家更加快速的使用,我在这里总结一下经验分享给大家~ 1.Gromacs安装略应该这个不可以使用mpi版本,自己测试也无法完成,若需要用mpi版本应该需要改bash脚本,至少将gromacs命令相应更改(PS:我使用的版本为5.0.2/5.0.6)个人觉得应该可以安装一个版本不设置环境变量[!未测试!] 2.APBS安装APBS下载点击此处查看下载编译好的以及未编译的均可,若只是用于GMXPBSAtool可以不需要设置环境变量我下载的1.3版本命令如下: tar zxvf apbs-1.3-source.tar.gz cd apbs-1.3-source/ ./configure –prefix=/home/gromacs/md/apbs make make install 3.GMXPBSAtoolGMXPBSAtool下载 解压,在bash/zsh中设置: export GMXPBSAHOME=/home/gromacs/md/GMXPBSAtool 4.input参数配置我配置的如下: #GENERAL root 289 multitrj nroot_multitrj run 1 #options: integer RecoverJobs y #options: y,n Cpath /home/gromacs/md/apbs/share/tools/manipApath /home/gromacs/md/apbs/binGpath /home/gromacs/md/gromacs/bin #FFIELD use_topology y #options: y,n itp_receptor receptor.itp itp_ligand TCD.itpuse_nonstd_ff n #options: y,nffield 5 #GROMACS VARIABLE complex protein_TCDreceptor proteinligand TCD skip 1 #options: integermin n #options: y,n double_p n #options: y,n #APBS VARIABLE coulomb coul #options: coul,gmx linearized n #options: y,nprecF 1 #options: integer 1,2,3(..)temp 300bcfl sdh #options: sdh,mdh,focuspdie 2 #options: integer, usually between 1 and 20 #QUEQUE VARIABLE cluster n #options: y,nQ … #necessary only if cluster=”y”!! mnp 1 #options: integer #OUTPUT VARIABLE pdf n #options: y,n # ALANINE SCANNING cas n #options: y,n 主要修改的地方有以下这么几点: 1).路径: Cpath /home/gromacs/md/apbs/share/tools/manip ;apbs的coulumb工具 Apath /home/gromacs/md/apbs/bin ;apbs目录 Gpath /home/gromacs/md/gromacs/bin ;gromacs目录 2).力场文件 use_topology y #options: y,n itp_receptor receptor.itp itp_ligand TCD.itp use_nonstd_ff n #options: y,n ffield 5由于我是做的受体配体,gromacs pdb2gmx不可以读小分子配体(无力场),所以use_topology,应该也可以改力场文件,加原子类型与电荷,但是自己修改不成功.注意需要放置topol.top文件,将topol.top中的蛋白数据提取出来,新建一个receptor.itp 否则会在后面报错.ffield我选的amber5力场 3).Gromacs变量 complex protein_TCD receptor protein ligand TCD在index.ndx中删除一个TCD,否则会报错 5.运行将轨迹文件处理后命名为npt.xtc tpr文件命名为npt.tpr 放入289文件夹下(可以修改) 1. cd EXAMPLE1 2. $GMXPBSAHOME/gmxpbsa0.sh and wait few seconds to finish the calculations 3. when the step 2. is done, type $GMXPBSAHOME/gmxpbsa1.sh and have a cup of coffe :) 4. when the step 3. is done, type $GMXPBSAHOME/gmxpbsa2.sh and wait few seconds to finish the calculations参考文献:GMXPBSATool","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"Modeller多模版-基于配体-Loop环优化[简略教程]","slug":"Modeller多模版-基于配体-Loop环优化[简略教程]","date":"2016-02-27T05:26:29.000Z","updated":"2017-10-28T03:54:32.764Z","comments":true,"path":"280.html","link":"","permalink":"http://kangsgo.com/280.html","excerpt":"","text":"1.先多模版比对123456789101112131415161718192021222324252627282930313233343536373839# Illustrates the SALIGN multiple structure/sequence alignmentfrom modeller import *log.verbose()env = environ()env.io.atom_files_directory = './:../atom_files/'aln = alignment(env)for (code, chain) in (('3F1O', 'A'), ('3H7W', 'A'), ('3H82', 'A')): mdl = model(env, file=code, model_segment=('FIRST:'+chain, 'LAST:'+chain)) aln.append_model(mdl, atom_files=code, align_codes=code+chain)for (weights, write_fit, whole) in (((1., 0., 0., 0., 1., 0.), False, True), ((1., 0.5, 1., 1., 1., 0.), False, True), ((1., 1., 1., 1., 1., 0.), True, False)): aln.salign(rms_cutoff=3.5, normalize_pp_scores=False, rr_file='$(LIB)/as1.sim.mat', overhang=30, gap_penalties_1d=(-450, -50), gap_penalties_3d=(0, 3), gap_gap_score=0, gap_residue_score=0, dendrogram_file='fm00495.tree', alignment_type='tree', # If 'progresive', the tree is not # computed and all structues will be # aligned sequentially to the first feature_weights=weights, # For a multiple sequence alignment only # the first feature needs to be non-zero improve_alignment=True, fit=True, write_fit=write_fit, write_whole_pdb=whole, output='ALIGNMENT QUALITY')aln.write(file='fm00495.pap', alignment_format='PAP')aln.write(file='fm00495.ali', alignment_format='PIR')aln.salign(rms_cutoff=1.0, normalize_pp_scores=False, rr_file='$(LIB)/as1.sim.mat', overhang=30, gap_penalties_1d=(-450, -50), gap_penalties_3d=(0, 3), gap_gap_score=0, gap_residue_score=0, dendrogram_file='1is3A.tree', alignment_type='progressive', feature_weights=[0]*6, improve_alignment=False, fit=False, write_fit=True, write_whole_pdb=False, output='QUALITY') File :salign.py 结果如下:1234567891011 _aln.pos 10 20 30 40 50 603F1OA -FKGLDSKTFLSEHSMDMKFTYCDDRITELIGYHPEELLGRSAYEFYHALDSENMTKSHQNLCTKGQV 3H7WA -FKGLDSKTFLSEHSMDMKFTYCDDRITELIGYHPEELLGRSAYEFYHALDSENMTKSHQNLCTKGQV 3H82A EFKGLDSKTFLSEHSMDMKFTYCDDRITELIGYHPEELLGRSAYEFYHALDSENMTKSHQNLCTKGQV _consrvd ******************************************************************* _aln.p 70 80 90 100 1103F1OA VSGQYRMLAKHGGYVWLETQGTVIYN-----PQCIMCVNYVLSEIEK 3H7WA VSGQYRMLAKHGGYVWLETQGTVIY------PQCIMCVNYVLSEIEK 3H82A VSGQYRMLAKHGGYVWLETQGTVIYNPRNLQPQCIMCVNYVLSEIEK _consrvd ************************* **************** File :fm00495.pap 模版开搞：1234567891011121314151617181920212223242526from modeller import *log.verbose()env = environ()env.libs.topology.read(file='$(LIB)/top_heav.lib')# Read aligned structure(s):aln = alignment(env)aln.append(file='fm00495.ali', align_codes='all')aln_block = len(aln)# Read aligned sequence(s):aln.append(file='musahr.ali', align_codes='musahr')# Structure sensitive variable gap penalty sequence-sequence alignment:aln.salign(output='', max_gap_length=20, gap_function=True, # to use structure-dependent gap penalty alignment_type='PAIRWISE', align_block=aln_block, feature_weights=(1., 0., 0., 0., 0., 0.), overhang=0, gap_penalties_1d=(-450, 0), gap_penalties_2d=(0.35, 1.2, 0.9, 1.2, 0.6, 8.6, 1.2, 0., 0.), similarity_flag=True)aln.write(file='TvLDH-mult.ali', alignment_format='PIR')aln.write(file='TvLDH-mult.pap', alignment_format='PAP') File: align2d_mult.py 注意序列尾巴标* 123456789from modeller import *from modeller.automodel import *env = environ()a = automodel(env, alnfile='TvLDH-mult.ali', knowns=('3F1OA','3H7WA','3H82A'), sequence='mahr')a.starting_model = 1a.ending_model = 5a.make() File: model.py loop优化：1234567891011121314151617181920212223242526272829# Loop refinement of an existing modelfrom modeller import *from modeller.automodel import *log.verbose()env = environ()# directories for input atom filesenv.io.atom_files_directory = './:../atom_files'# Create a new class based on 'loopmodel' so that we can redefine# select_loop_atoms (necessary)class MyLoop(loopmodel): # This routine picks the residues to be refined by loop modeling def select_loop_atoms(self): # 10 residue insertion return selection(self.residue_range('70', '80'))m = MyLoop(env, inimodel='musahr1.pdb', # initial model of the target sequence='mahr') # code of the targetm.loop.starting_model= 10 # index of the first loop model m.loop.ending_model = 15 # index of the last loop modelm.loop.md_level = refine.very_fast # loop refinement method; this yields # models quickly but of low quality; # use refine.slow for better modelsm.make() 增加配体12345678910from modeller import *from modeller.automodel import *env = environ()env.io.hetatm = Truea = automodel(env, alnfile='TvLDH-1emd_bs.ali', knowns=('3F1OA','3H7WA','3H82A'), sequence='mahr')a.starting_model = 20a.ending_model = 30a.make() 参考文献：官方教程多模版建模参考文献:Modeller 学习记录（四）","categories":[{"name":"同源建模","slug":"同源建模","permalink":"http://kangsgo.com/categories/同源建模/"}],"tags":[{"name":"Modeller","slug":"Modeller","permalink":"http://kangsgo.com/tags/Modeller/"}]},{"title":"使用VMD绘画豪猪图","slug":"使用VMD绘画豪猪图","date":"2016-02-25T10:15:40.000Z","updated":"2017-10-29T03:19:48.642Z","comments":true,"path":"260.html","link":"","permalink":"http://kangsgo.com/260.html","excerpt":"","text":"文件下载地址：PorcupinePlot &nbsp; Step 1:获得 extreme1.pdb 使用如下命令 1g_anaeig -s protein_CAlpha.pdb -f combinedItajectory.xtc -extr extreme1.pdb -first 1 -last 1 -nframes 50 Step2:使用文本编辑器，从extreme1.pdb保存第一个frame 改成”first_frame.pdb”相似的把最后一个frame改为 “last_frame.pdb” Step3:打开VMD, Load first_frame.pdb in New Molecule.相似的load, last frame 作为 a newmolecule. Step4:打开 Tcl/Tk Console Step5:输入”play Porcupine.tcl“ 并回车 Step6:然后在 VMD（主界面） Main, 点击 first_frame 并且在 console 中输入: atomselect top “name CA” step7:Then in VMD Main, click on last_frame and type in console: atomselect top “name CA” Step8:然后输入 1porcupineplot::Diff atomselect1 atomselect0 最后的输入结果类似如下： 123456-----------------------&gt;Main&lt; (ras-raf) 17 % atomselect top &quot;name CA&quot; atomselect0 &gt;Main&lt; (ras-raf) 20 % atomselect top &quot;name CA&quot; atomselect1 &gt;Main&lt; (ras-raf) 21 % porcupineplot::Diff atomselect1 atomselect0running through 242 residuesdrawing arrows for distances between 0.14418759278366697 and 5.825031451230942 (colors from scheme BGR)drawing color scale bardone 在VMD中最终效果如下： Demo_ras-raf 注意：在 g_covar 和 g_anaeig 命令中选择protein而非Ca 感谢GROMACS小组-李辉指正","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"VMD","slug":"VMD","permalink":"http://kangsgo.com/tags/VMD/"}]},{"title":"使用Pymol的Modevectors脚本绘画豪猪图","slug":"使用Pymol的Modevectors脚本绘画豪猪图","date":"2016-02-25T09:55:49.000Z","updated":"2017-10-29T03:17:50.405Z","comments":true,"path":"243.html","link":"","permalink":"http://kangsgo.com/243.html","excerpt":"","text":"原文地址：点我查看 英文好的建议看原文，我的英文不是很好，以免有翻译错误或者翻译不准确的地方 脚本下载地址：modevectors 使用： 加载脚本使用run命令 123modevectors first_obj_frame, last_obj_frame [,first_state=1 [,last_state=1 [,outname=modevectors \\ [,head=1.0 [,tail=0.3 \\[,head_length=1.5 [,headrgb=(1.0,1.0,1.0) [,tailrgb=(1.0,1.0,1.0) [,cutoff=4.0 [,skip=0 [,cut=0.5 [,atom=CA [,stat=show [,factor=1.0 [,notail=0]]]]]]]]]]]]]] 更多类型可以看pdf底部 当脚本完成object会显示”modevectors” 可以通过 outname=modevectors 修改 例子： 123modevectors 1E3M, 1W7Amodevectors 1E3M, 1W7A, outname=\"arrows\"modevectors 1E3M, 1W7A, atom=\"P\" 复制/粘贴 如下代码查看modevectors。此使用多个蛋白且箭头联系首尾 1234567891011121314import modevectors# fetch the PDBs from pdb.orgfetch 1c3y, finish=1, multiplex=0, async=0# separate the first and last states of the NMR ensemble to individual objectssplit_states 1c3y, 1, 1split_states 1c3y, 23, 23hide# run the modevectors codemodevectors 1c3y_0001, 1c3y_0023# just setup a nice representationas cartoon, 1c3y_0001 or 1c3y_0023show cgo, modevectorscolor marine, 1c3y_0001color purpleblue, 1c3y_0023 附样式图片（编号1-13）： Mv_default Mv_fig3 Mv_fig4 Mv_fig5 Mv_fig6 Mv_fig7 Mv_fig8 Mv_fig9 Mv_fig10 Mv_fig11 Mv_fig12 Mv_fig13 图片代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162reinitializeimport modevectorsfetch 1c3y, async=0split_states 1c3y, 1, 1split_states 1c3y, 23, 23hide #This is the default setting (Fig.1)modevectors 1c3y_0001, 1c3y_0023 #This is shows that the direction of the arrows is drawn from the 1c3y_0001 towards 1c3y_0023 (Fig.2)show cartoon, 1c3y_0023color red, 1c3y_0023 #This controls the base radius of the cone/arrow head in angstroms (Fig.3)modevectors 1c3y_0001, 1c3y_0023, head=2.5 #This controls the radius of the cylinders/arrow tails in angstroms (Fig.4)modevectors 1c3y_0001, 1c3y_0023, tail=0.75 #This controls the length of the cone/arrow head in angstroms (Fig.5)#Note that this option does NOT increase the vector length but simply changes the tail lengthmodevectors 1c3y_0001, 1c3y_0023, head_length=3.0 #This controls the colour of the cone/arrow head using RGB values (Fig.6)modevectors 1c3y_0001, 1c3y_0023, headrgb=(1.0,0.0,0.0) #This controls the colour of the cylinder/arrow tails using RGB values (Fig.7)modevectors 1c3y_0001, 1c3y_0023, tailrgb=(1.0,0.0,0.0) #This controls the which vectors to show based on a specific cutoff value in angstroms. Vector lengths that are less #than the cutoff value will not be displayed (Fig.8)modevectors 1c3y_0001, 1c3y_0023, cutoff=30.0 #This controls how many vectors to skip (integer value) and is useful when there are too many vectors showing. #Skip=1 will show every other arrow (Fig.9)modevectors 1c3y_0001, 1c3y_0023, skip=1 #This controls how much to cut from each vector (in angstroms). Note that arrows will point in the opposite directions #when too much is cutoff (resulting in a negative vector length) (Fig.10) and should be used with caution!modevectors 1c3y_0001, 1c3y_0023, cut=15.0 #This controls which atom to draw a vector from (Fig.11). Note that this is case-sensitive and is really only useful #when atom=CA or when atom=P (for DNA backbones)modevectors 1c3y_0001, 1c3y_0023, atom=CB #This controls how much to multiple the length of each vector by (percentage increase/decrease) (Fig.12)#This example halves the length of each vector (50%)modevectors 1c3y_0001, 1c3y_0023, factor=0.5 #This hides the statistics which count atoms skipped, atoms counted (number of arrows showing), and number of atoms #that did not meet the cutoff and are not shownmodevectors 1c3y_0001, 1c3y_0023, stat=hide #This example shows multiple options being used (Fig.13)modevectors 1c3y_0001, 1c3y_0023, head=2.0, tail=1.0, head_length=2.0, headrgb=(1.0,0.0,0.0), tailrgb=(0.0,0.0,1.0),cutoff=0.0,skip=0,cut=0,atom=CA,factor=0.8 #Finally, this example hides all arrow tails and only uses arrow heads via the notail option(No Figure)modevectors 1c3y_0001, 1c3y_0023, head=2.0, cutoff=0.0,skip=0,cut=0,atom=CA,factor=0.8, notail=1","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"制作VMD动画（中文版）/Pymol 动画","slug":"制作VMD动画（中文版）Pymol 动画","date":"2016-02-25T07:21:14.000Z","updated":"2017-10-29T03:05:39.028Z","comments":true,"path":"239.html","link":"","permalink":"http://kangsgo.com/239.html","excerpt":"","text":"原文连接失效了，此为PDF版本：VMD-animations VMD版本 第一步： 提取轨迹。 往往轨迹文件很大，建议先提取其中的一段，或者把步长放大，提取完整的也行。利用指令：trjconv -f nvt.trr -b 0 -e 500 -o nvt_500.trr可以获得轨迹文件中从0到500 ps的轨迹。 第二步：导入轨迹 安装VMD，然后先导入十进制文件，再导入二进制轨迹文件（这些简单操作就带过了）。然后你就能看到轨迹了。要将轨迹做得美观点，一般有这样几个建议：1. 不要把VMD全屏，否则你会后悔的；2. 背景色相应进行调整；3. DisplayàAxesàoff去掉坐标系。接下来选择Extension à Visualization à Movie Maker，然后就会跳出一个VMD Movie Generator的小窗口。 第三步：设置参数 建议在空间大的盘里建立一个临时文件夹，路径名最好都是英文或者拉丁字符的，汉字VMD不认的。然后把working directory改成你刚刚新建的临时文件夹目录。Renderer选择Snapshot，Movie Setting改成Trajectory，format改成MPEG-1或者AVI（如果你有足够空间和时间的话）。其他参数按照自己的需求修改。此时点击Make Movie，整个过程就开始了。这里有个非常重要的东西要提醒：VMD是将视频一帧一桢形成图片格式输出，然后再在另一个软件中组成一个动画，因此图片就是你一会做动画的来源，既然图片选择snapshot（快照），那也就是说你必须将动画置于窗口，而不能最小化，否则相当于无法截屏了。 VMD中 1trjconv -f mdwholeNOjump.xtc -s md_0_1.tpr -fit rot+trans -o mdahrfitNojump.xtc 选择蛋白文件不动，这样做出来的结果就是稳定的 另外一种方法为： 选mouse-move-molecule，然后按住shift拖动分子调整分子与坐标轴的相对朝向，以使得绕着坐标轴的某个轴转动时可以把感兴趣的区域显示出来。然后extension-analysis-RMSD trajectory tool，直接点Align，这样后续的帧中的结构就都向着最初帧的分子朝向对齐了。 在Pymol模式下可以这样子： 1intra_fit protein and (name c,n,ca) Pymol版本制作电影： 12345viewport 640,480set ray_trace_frames,1mpng frame_.png 具体Pymol方法可以看这里（5-6页）：Gromacs教程II-MD结果分析 参考文献：如何用VMD将轨迹文件制作动画 参考文献：怎样用VMD软件画出一条MD轨迹中所有构象 参考文献：显示粒子运动轨迹的VMD脚本","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"},{"name":"VMD","slug":"VMD","permalink":"http://kangsgo.com/tags/VMD/"}]},{"title":"两个PCA分析工具","slug":"两个PCA分析工具","date":"2016-02-24T15:28:54.000Z","updated":"2017-10-29T03:12:21.449Z","comments":true,"path":"230.html","link":"","permalink":"http://kangsgo.com/230.html","excerpt":"","text":"待编辑： http://www.ks.uiuc.edu/Research/vmd/mailing_list/vmd-l/att-15365/PorcupinePlot.tcl http://www.ks.uiuc.edu/Research/vmd/mailing_list/vmd-l/9391.html &nbsp; http://www.ks.uiuc.edu/Research/vmd/plugins/nmwiz/ &nbsp; https://www.researchgate.net/post/How_to_use_PorcupinePlottcl_in_VMD2 &nbsp; http://wenku.baidu.com/link?url=dgbJ_MFW3qQRiWrlt_kWdhtlofbcIp_8GI-cSUKfiSW2vtIdyeGyknJR4LT2P315sO7iFKMPpW75N-3ciSEUHDhaQNuFMthcO99rjGPb-ti &nbsp; &nbsp;","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Groamcs","slug":"Groamcs","permalink":"http://kangsgo.com/tags/Groamcs/"}]},{"title":"Ubuntu 15.10 Gromacs GPU加速错误解决办法","slug":"Ubuntu 15.10 Gromacs GPU加速错误解决办法","date":"2016-02-24T14:48:51.000Z","updated":"2017-10-28T03:30:58.300Z","comments":true,"path":"226.html","link":"","permalink":"http://kangsgo.com/226.html","excerpt":"","text":"今天把新电脑装了Ubuntu15.10，装GPU加速版本，但是在gromacs安装的时候出现了问题，在cmake那一步就出错，make时也报错，make check直接显示找不到文件。 看错误日志发现CUDA的字眼，猜测是CUDA驱动版本是15.04的缘故，在网上搜，发现了相关教程。贴图如下： 按照先前安装教程安装 1.终端输入如下：1**nvcc -V**(注意大写V) 应该有类似输出：1234nvcc: NVIDIA(R) Cuda compiler drivercopyright (c) 2005-2015 NVIDIA CorporationBuilt on ………………Cuda compilation tools, release 7.5, V7.5.17 2.使用自带的samples进行GPU运算测试。 进入到cuda-7.5的samples目录，一般都是cd /usr/local/cuda-7.5/samples，然后会有一个Makefile文件，执行命令sudo make，不出意外地话，会出现带有红颜色的error错误，大概是这样的：unsupported GNU version! gcc versions later than 4.9 are not supported! 意思也很明显了，就是gcc的版本高于4.9，Cuda不支持。解释一下：ubuntu15.10自带的gcc是5.2.1，可以通过gcc –version（两个-）查看，但是cuda不支持超过4.9.0的gcc编译器。要么安装一个低版本的编译器，要么把cuda的这个限制给去掉。我选择的是后者，而且尚未出现其他问题。 3.解决方案如下： 1234sudo cd /usr/local/cuda/include/ #进入到头文件目录cuda(而不是cuda-7.5)；sudo cp host_config.h host_config.h.bak #备份原头文件；sudo gedit host_config.h #编辑头文件；ctrl+F查找4.9出现的地方，大约位于115行，在第113行处应该显示if _GNUC_&gt;4 || (_GNUC_ == 4 &amp;&amp; _GNUC_MINOR_ &gt; 9)，因为我们的是5.2.1，因此，把上面的2个4都改成5就ok了，保存退出。 自此解决，若还不放心，可以从新运行第2步的sudo make（注意目录同第二步） 参考文献：Ubuntu15.10_64位安装Theano+cuda7.5详细笔记","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"[读书笔记]Plos One 上一篇突变的文章分析模式学习（简）","slug":"[读书笔记]Plos One 上一篇突变的文章分析模式学习（简）","date":"2016-02-24T12:23:14.000Z","updated":"2017-10-18T12:17:14.228Z","comments":true,"path":"221.html","link":"","permalink":"http://kangsgo.com/221.html","excerpt":"","text":"标题：Molecular Dynamics Analysis Reveals Structural Insights into Mechanism of Nicotine N -Demethylation Catalyzed by Tobacco Cytochrome P450 Mono-Oxygenase 杂志：Plos One 年份: 2011 影响因子：3.24 文章下载：参考文献pone 方法： 1.结构准备：建模 SWISS-MODEL ，评价 TM-score 分子对接：AUTODOCK 分子动力学： GROMACS 4.5.3 力场：GROMOS96 53a6 force field 小分子力场：Dundee PRODRG Server MD：30ns 2.分析：RMSD, RMSF, Helix, and Channel analysisRMSDs 骨架原子 C-alpha RMSFs g_helix program 观察突变螺旋卷曲 Specifically, the helical rise per residue isplotted as the difference in Z-coordinate between Ca atoms 通道：CAVER主成分分析和协方差分析：PCA（Principal component analysis）分析：脚本 另外蒲中机同学分享了一个脚本，生成豪猪图的~在这里分享给大家~版权归蒲中机所有~vmdtcl会自动生成豪猪图","categories":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/categories/Gromacs/"}],"tags":[]},{"title":"自动的Gromacs拓扑生成工具和比较不同力场的溶剂化自由能","slug":"自动的Gromacs拓扑生成工具和比较不同力场的溶剂化自由能","date":"2016-02-14T12:21:53.000Z","updated":"2017-10-29T03:25:27.721Z","comments":true,"path":"214.html","link":"","permalink":"http://kangsgo.com/214.html","excerpt":"","text":"原文名称：Automatic GROMACS Topology Generation and Comparisons of Force Fields for Solvation Free Energy Calculations 接受日期：2014年10月26日 影响因子:3.32 文章下载：本地下载 摘要：现在我们提供一个新的框架，这个框架能够全自动的生成GROMACS拓扑文件对于许多（any of these force fields）力场，并且自动进行并行优化设置的高通量（high-throughput）自由能计算。 使用方法：git clone https://gerrit.gromacs.org/STaGE ！–未测试–！ 太长了，而且没有说明书···烂尾了········","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"[读书笔记]NEDD-8活化酶的低敏感性突变与癌症药物MLN4924抑制剂的分子动力学研究","slug":"[读书笔记]NEDD-8活化酶的低敏感性突变与癌症药物MLN4924抑制剂的分子动力学研究","date":"2016-02-07T04:21:27.000Z","updated":"2017-10-29T02:47:47.490Z","comments":true,"path":"194.html","link":"","permalink":"http://kangsgo.com/194.html","excerpt":"","text":"杂志：Am J Cancer Res 影响因子：3.98 接收：2015年8月 发表：2015年11月 一篇伊朗的研究论文 题目：Molecular dynamics simulation on the low sensitivity ofmutants of NEDD-8 activating enzyme forMLN4924 inhibitor as a cancer drug 全文下载：点我下载 摘要：MLN4924是NEDD8活化酶（NAE）抑制剂，而NAE是结合在culin蛋白上的库林环连接酶（CRLs）。如图： nrm1547-f5 这个共价修饰招募E2泛素化调控原件，导致下游蛋白泛素化以及蛋白酶的降解。MLN4924为共价抑制剂！使得CLRs失活（而CLRs会导致DNA的复制以及抑制NF-κB信号通路）从而导致癌细胞的死亡。 突变可以减少酶对MLN4924的敏感性：Verma et al等人在2013年分子动力学研究发现A171T减少MLN4924和DNA结合位点作用酶（ DNA Binding site of enzyme as a result of reductionof enzyme affinity to ATP）的相互作用，减少酶和ATP的亲和力。 一年后Wei Xu et al.发现Y352H和I310N的突变导致酶阻碍MLN4924的抑制作用。有趣的是报道称增加酶和ATP的亲和力。其并未做分子动力学研究。 本文采用Gromacs 4.5.6版本 介绍：癌细胞介导细胞信号不仅位于细胞循环。而且阻止细胞凋亡。细胞凋亡要求特别的调节蛋白例如扁在蛋白酶系统（ubiquitin-proteasome system UPS）作为监测点，UPS包括E3遍在蛋白酶联体称之为CUllin-RING Ligases（CRLs），其核心为NEDD8（ubiquitin-like protein ；ULP）。 NEDD8修饰能够介入细胞循环和细胞骨架的调节。 1 E1（NEDD8激活酶NAE）催化带有NEDD8的cullin的初始化。NAE与其他蛋白的联系阐述如图1.NAE的抑制剂MLN4924被揭露其阻止NAE的激活以及随后的cullins表达。被认为是一个潜在的抗癌药物，表达临床效用在一些固体肿瘤和血液病和近期发现淋巴瘤和多发性骨癌。 方法： 预测NAE可能的相互作用伙伴 使用STRING数据库（http://string-db.org/）。这个相互作用包括直接（物理）和间接（功能性）联系。 MLN4924属性计算和化学结构 通过Pfam database (www.http://pfam.xfam.org/)，我们计算Molecular Weight,Molecular Formula, XLogP3, Hydrogen Bond Donor Count, Hydrogen Bond Acceptor Count,Rotatable Bond Count and etc。以及化学结构 分子动力学和分子结构最小化 使用之前教程方法，突变使用Modeller 9.13项目，mutant Y352H and I310N，MD 20ns，抑制剂和蛋白均为晶体结构 2 &nbsp; 结果与讨论 蛋白联系预测 计算参数结果和化学构象 其说对于MD非常有用，个人觉得没什么用 分子动力学 RMSD分析用来查看动力学稳定性（原文In MD analysis, Root Mean Square Deviation (RSMD) of simulated structure upon time is an appropriated and common criterion to verify Molecular dynamics stimulation stability.） 3 此外，蛋白结构域和形状可以被通过Gyration Radius计算修饰。这个参数提供了关于蛋白总体积分配，换而言之，其表明了紧密的分子形状？（tensed molecular shape） 4 RMSF 一些结构的柔性改变和改变的模式对于正常的与突变的不同的模式能够从此图中比较出来 5","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"},{"name":"文献","slug":"文献","permalink":"http://kangsgo.com/tags/文献/"}]},{"title":"分析待整理","slug":"分析待整理","date":"2016-01-18T17:59:12.000Z","updated":"2017-10-18T12:17:14.228Z","comments":true,"path":"190.html","link":"","permalink":"http://kangsgo.com/190.html","excerpt":"","text":"王新宇@天津&lt;wangdephor@qq.com&gt; 9:07:29@吴萌@上海 ,取残基中两个特定原子间的距离可以吗，比如alpha碳，如果是残基质心的话，我觉得需要自己动手写脚本吴萌@上海(2425896046) 9:10:25我想分析的是两个residue间的距离随时间的变化情况王新宇@天津&lt;wangdephor@qq.com&gt; 9:11:53每个残基好多原子，怎么定义残基距离呢赵红霞@南京(763348803) 9:12:19先分别找到两个residue的质心，再测量两个质心的距离随模拟时间的变化。王新宇@天津&lt;wangdephor@qq.com&gt; 9:12:58这个测量有现成选项吗赵红霞@南京(763348803) 9:13:14原理是这样，具体操作就不会了王新宇@天津&lt;wangdephor@qq.com&gt; 9:13:49最好有现成脚本，吴萌@上海(2425896046) 9:14:10我昨天用了distance，我引用了ndx，然后选择了分组，就是选好了要测的氨基酸，但选好后停那了，没有得到我想输出的文件蒲中机@大连(1530547071) 9:14:20gmx distance 可以蒲中机@大连(1530547071) 9:14:35肯定能完成的王新宇@天津&lt;wangdephor@qq.com&gt; 9:15:14好，去试试张鲁格@济宁(374248600) 9:15:14对赵红霞@南京(763348803) 9:15:28应该有一个选质心的过程吧吴萌@上海(2425896046) 9:15:29@赵红霞@南京 怎么找质心赵红霞@南京(763348803) 9:16:06我先前在MS里是这么做的，gromacs还刚刚摸索呢阮洋@南京(1532014681) 9:23:05或者是g_dist，用质心，输出的结果，编程处理一下康文斌@南京(407747533) 9:23:38求残基距离有很多的方法：1、可以参考US例子中的方法2、你可以定义bond康文斌@南京(407747533) 9:24:51gmx distance -s pull.tpr -f conf${i}.gro -n index.ndx -select ‘com of group 19 plus com of group 20’ -oav dist${i}.xvg&amp;&gt;/dev/null康文斌@南京(407747533) 9:25:05改改这个是一种方法康文斌@南京(407747533) 9:27:23选择你关心的原子做为两个组康文斌@南京(407747533) 9:28:53还有一个大家可以关心PLUMED，这个可以做的事更多。其中有些工具可以实现你想计算的物理量。 &nbsp; &nbsp; &nbsp; 祝新哲@北京(979434812) 21:17:32请问求两个分子质心随时间变化是gmx distance -f md1.trr -s md.tpr -n index.ndx -selrpos res_cog -oall dis_BCD1-BCD2.xvg，这样有问题吗阮洋@南京(1532014681) 21:19:27-pbc com","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"[转]pymol小技巧-选择配体周围氨基酸残基","slug":"[转]pymol小技巧-选择配体周围氨基酸残基","date":"2016-01-17T15:50:27.000Z","updated":"2017-10-29T03:33:52.583Z","comments":true,"path":"181.html","link":"","permalink":"http://kangsgo.com/181.html","excerpt":"","text":"我们常常遇到想要选取配体周围几埃范围内的氨基酸，这样更有利于我们分析配体和周围氨基酸的作用。首先我们可以通过命令 12345678#ligand为选择配体的名字select ligand，resn x#设置为红色color red， ligand#配体5埃范围内的残基select 5A， byres ligand around 5show sticks, 5Acolor yellow, 5A 转载自：pymol使用小技巧8-选取配体周围氨基酸","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"g_mmpbsa 安装与使用笔记","slug":"g_mmpbsa 安装与使用笔记","date":"2016-01-16T15:38:55.000Z","updated":"2017-10-29T03:45:27.661Z","comments":true,"path":"170.html","link":"","permalink":"http://kangsgo.com/170.html","excerpt":"","text":"g_mmpbsa现在可以不编译直接用，非常的方便，现在提供了4.5.x，4.6.x和5.0.x三个版本，暂时不支持5.1以上版本。 1.安装教程 先从这里下载预编译版本 1234tar -zxvf g_mmpbsa.tar.gzcd binsudo cp g_mmpbsa /usr/local/bin/.sudo cp energy2bfac /usr/local/bin/. 也可以设置环境变量： 1export PATH=$&#123;PATH&#125;:/path/to/g_mmpbsa/bin 2.使用 2.1 轨迹处理 由于在计算能量过程中，是按照每ps来计算，特别费时，所以需要用trjconv把轨迹文件，通过-skip参数设置每隔多长时间读取一次轨迹，如： 1gmx trjconv -f md_0_1.xtc -o trj_20-50ns -b 20000 -e 50000 -dt 100 我这里总共获得了300个frame 现在g_mmpbs提供了3步计算和1步计算两种方法 2.2 三步计算（由于我是使用的一步计算法，所以这里是直接复制） (a) Calculation of potential energy in Vacuum 1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -pdie 2 -decomp (b) Calculation of polar solvation energy 1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../polar.mdp -nomme -pbsa -decomp (c) Calculation of non-polar solvation energy For SASA-only model: 1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sasa.mdp -nomme -pbsa -decomp -apol sasa.xvg -apcon sasa_contrib.dat For SAV-only model: 1g_mmpbsa -f 1EBZ.xtc -s 1EBZ.tpr -n 1EBZ.ndx -i ../apolar_sav.mdp -nomme -pbsa -decomp -apol sav.xvg -apcon sav_contrib.dat 2.3 一步计算 1g_mmpbsa -f trj20-50ns.xtc -s npt.tpr -n index.ndx -i canshu/pbsa.mdp -pdie 2 -pbsa -decomp 使用的是三步计算的SASA模型 注意：一般跑100个frame就可以了，我就是红色部分打错了，结果非常悲剧的跑了一天还没跑完12使用的mdp文件来自于官方教程，我打包上传在[这里](/images/2016/01/canshu.zip)，具体的相关含义[官方](http://rashmikumari.github.io/g_mmpbsa/Parameters.html)有详细解释，我并未研究。 选择1|13 蛋白质和配体1234567891011跑完以后应该会得到如下文件：![1](/images/2016/01/1.png)3.平均结合能计算3.1 安装numby```bashsudo apt-get install python3-numpy 提示建议安装 1sudo apt-get install python-numpy-doc python3-dev python3-nose python3-numpy-dbg 但是我没有安装 3.2 下载脚本自实验目录 下载官方的脚本。只需要下载两个，但是官方提供了4个，另外两个有待研究 点击这里下载我下载好的脚本：jiaoben 脚本参数使用可以看这里：官方参数使用 3.3 计算 1python3 MmPbSaStat.py -m energy_MM.xvg -p polar.xvg -a apolar.xvg (or sasa.xvg) 其中括号以内取决于你的模型，若是一步法则为apolar.xvg 我的到的结果如下： 2 得到的文件主要是两个date 4.能量拆分 1python3 MmPbSaDecomp.py -bs -nbs 2000 -m contrib_MM.dat -p contrib_pol.dat -a contrib_apol.dat 其中-nbs 2000 的解释为： Number of boot strap steps for average energy and standard error calculation. 但是具体含义不清楚 我得到的能量拆分图： energyMapIn 建议复制文本用excel做，好看一些 &nbsp; 参考文献：GROMACS 中 g_mmpbsa 工具使用详解 g_mmpbsa官方教程 &nbsp; &nbsp;","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"带帐号离线下载办法","slug":"带帐号离线下载办法","date":"2016-01-08T17:53:06.000Z","updated":"2017-10-18T12:17:14.228Z","comments":true,"path":"161.html","link":"","permalink":"http://kangsgo.com/161.html","excerpt":"","text":"这个主要是rostta下载的时候没有速度，所以想拖到vps上然后下载。 方法为在hostloc的朋友告知 wget http://user:passwd@url.com/xxx.files.tar.gz","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[]},{"title":"gromacs下蛋白配体复合物分析","slug":"gromacs下蛋白配体复合物分析","date":"2016-01-05T15:46:44.000Z","updated":"2017-10-28T14:55:55.807Z","comments":true,"path":"156.html","link":"","permalink":"http://kangsgo.com/156.html","excerpt":"","text":"此是记录的按照前面做了以后 废话不多说，先调整周期性1trjconv_mpi -s md_0_1.tpr -f md_0_1.xtc -o md_0_1_noPBC.xtc -pbc mol -ur compact 全部选择 0(“System”) 老规矩，作图 1gmx rms -s md_0_1.tpr -f md_0_1_noPBC.xtc -o rmsd.xvg -tu ns 全部选择碳链骨架 4(“Backbone”) xmgrace作图以后，让人紧张的情绪膨胀 也不知道后面是不是真的是稳定了的说12345678910111213在VMD中发现蒲中机-大连教我了另外一种方法能够使分子更加稳定PBC运动的方法，方法如下（注意代码每个人有差异）：#### 1.轨迹处理：```bashtrjconv_mpi -f md_0_1.xtc -s md_0_1.tpr -pbc whole -ur compact -o mdwhole.xtctrjconv_mpi -f mdwhole.xtc -s md_0_1.tpr -dump 0 -o 1stframe.pdbtrjconv_mpi -f mdwhole.xtc -s 1stframe.pdb -pbc nojump -o mdwholeNOjump.xtc全部选择0 system 2.rmsd123gmx_mpi rms -s md_0_1.tpr -f mdwholeNOjump.xtc -o rmsd.xvg -tu ns选择骨架4（Backbone） 3.rmsf123gmx_mpi rmsf -s md_0_1.tpr -f mdwholeNOjump.xtc -o rmsf.xvg -oq rmsf.pdb -res -b 15000选择 3 ( C-alpha) 如图： rmsf 可以发现越是突变位点越发稳定 4.g_confrms比较结构差异123gmx g_confrms -f1 mAhR.pdb -f2 md_0_1.gro -o fit.pdb#两次都选择骨架4（Backbone） 但是不知道为何生成的fit.pdb文件出来有一点问题，所以想尝试第二种方案 123editconf_mpi -f md_0_1.gro -o md_0_1.pdbeditconf_mpi -f complex.gro -o mAhRaddh.pdb 在pymol中打开md_0_1.pdb， 123输出select SOL,CL ;delete selealign structure2(md_0_1), structure1(mAhRaddh) 得到的结果图用cartoon作图结果如下： tcdd-old-mdnew 可以看出结构垭口和loop环的差别还是很大的，TCDD有一个翻转并且进一步深入口袋 5.豪猪图采用Pymol画豪猪图，方法如前文 关键命令如下 1modevectors pymolprotein1,pymolprotein2 ,cutoff=1.5,head_length=1.5,factor=2 结果如下： arraow 可以看出50ns AhR蛋白beta折叠和α螺旋并未进行剧烈的变动，仅仅为loop环结构使得接合口袋进一步的收缩，轻微的构象改变更好的说明同源建模过程中构象的准确性。 6.查看小分子的运动轨迹 vmdscene2 小圆点代表的为tcdd分子中每个原子1ns行走的位置，可以发现tcdd在接合口袋相当稳定，在一定波动范围波动，稍稍深入蛋白腔内部。 7.回旋半径的计算蛋白质的回旋半径反应了蛋白质分子的体积和形状。同一体系的回旋半径越大，说明体系发生了膨胀。 gyrate 发现体系的回旋半径很稳定。 123g_gyrate_mpi -f mdwholeNOjump.xtc -s md_0_1.tpr -o fws_gyrate.xvg#选1 蛋白 8.dssp二级结构 fws_ss 可以看出蛋白结构还是比较稳定，具体需要进一步研究 1234do_dssp -f md_0_1_noPBC.xtc -s npt.tpr -n index.ndx -o fwss.xpm -dt 100xpm2ps -f fwss.xpm -o fwss.epsconvert fwss.eps fwss.bmp 9.计算最大螺旋性质 g_helix_mpi -s md_0_1.tpr -n index.ndx -f mdwholeNOjump.xtc -dt 100gmx helix计算各种类型螺旋的性质. 程序首先会检查多肽段, 找到最长的螺旋部分, 这由氢键和φ/ψ角度确定的. 再将其拟合成一个绕z轴的理想螺旋, 以原点居中. 然后计算以下性质: 螺旋半径(radius.xvg输出文件). 这仅仅是二维平面内所有C~α~原子的RMS偏差, 计算方法sqrt((sum_i (x\\^2(i)+y\\^2(i)))/N), 其中N为骨干原子数. 理想螺旋的半径为0.23 nm.扭转(twist.xvg输出文件). 计算每个残基的平均螺旋角. 对α螺旋此值为100度, 对3-10螺旋值会更小, 5-螺旋的值更大.每个残基的上升量(rise.xvg输出文件). 每个残基的螺旋上升量以C~α~原子z坐标的差值表示. 对于理想螺旋此值为0.15 nm总螺旋长度(len-ahx.xvg输出文件). 以nm为单位的总螺旋长度. 其值简单由平均上升量(见上文)乘上螺旋残基数(见下文)计算.螺旋偶极. 只计算骨干原子的(dip-ahx.xvg输出文件).与理想螺旋的RMS偏差, 仅根据C~α~原子计算(rms-ahx.xvg输出文件).平均C~α~-C~α~二面角(phi-ahx.xvg输出文件)平均φ和ψ角度(phipsi.xvg输出文件).根据Hirst和Brooks方法计算的222 nm处的椭圆度 10.矩阵分析（PCA）1g_covar_mpi -s npt.gro -f mdwholeNOjump.xtc -o eigenvalues.xvg -xpma covapic.xpm 待编辑 参考文献：水中的溶菌酶教程 参考文献：漏斗网蜘蛛毒素肽的溶剂化研究: Amber99SB-ILDN力场 参考文献：dssp二级结构 参考文献：gromacs中的do_dssp的使用","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"python学习-随笔记","slug":"python学习-随笔记","date":"2016-01-02T20:53:21.000Z","updated":"2017-10-18T12:17:14.228Z","comments":true,"path":"150.html","link":"","permalink":"http://kangsgo.com/150.html","excerpt":"","text":"自己之前稍微学习过一点PHP和Python的书籍，但是两个都学的不是很精，应该是项目做少了，还有就是前面学的非常不扎实，所以要从头学，找了这么多资料，个人感觉老齐的《从零开始学Python》非常不错，推荐给大家！ &nbsp; 还发现一个国外特别经典但是国内翻译了的《笨方法学python》，推荐给大家～挺经典的","categories":[{"name":"Python","slug":"Python","permalink":"http://kangsgo.com/categories/Python/"}],"tags":[]},{"title":"autodock vina官方教程视频","slug":"autodock vina官方教程视频","date":"2016-01-02T08:10:50.000Z","updated":"2017-10-29T03:02:36.036Z","comments":true,"path":"135.html","link":"","permalink":"http://kangsgo.com/135.html","excerpt":"","text":"个人还是比较喜欢用pymol插件做的，仁者见仁智者见智吧~ [video width=”800” height=”600” wmv=”http://kangsgo.com/wp-content/uploads/2016/01/vina_tutorial.wmv&quot;][/video]","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Autodock","slug":"Autodock","permalink":"http://kangsgo.com/tags/Autodock/"}]},{"title":"gromacs mdp文件参数","slug":"gromacsmdp文件参数","date":"2015-12-31T14:40:31.000Z","updated":"2017-10-18T12:17:14.228Z","comments":true,"path":"121.html","link":"","permalink":"http://kangsgo.com/121.html","excerpt":"","text":"参数具体用法可以查看：官方文本 有空再翻译 ; ; File 'mdout.mdp' was generated ; By user: kangsgo (1000) ; On host: kangsgo-pc ; At date: Thu Dec 31 22:38:07 2015 ; 5.02参数所有备注 ; ; VARIOUS PREPROCESSING OPTIONS ; Preprocessor information: use cpp syntax. ; e.g.: -I/home/joe/doe -I/home/mary/roe include = -I../top ; e.g.: -DPOSRES -DFLEXIBLE (note these variable names are case sensitive) define = ; RUN CONTROL PARAMETERS integrator = md ; Start time and timestep in ps tinit = 0 dt = 0.002 nsteps = 500000 ; For exact run continuation or redoing part of a run init-step = 0 ; Part index is updated automatically on checkpointing (keeps files separate) simulation-part = 1 ; mode for center of mass motion removal comm-mode = Linear ; number of steps for center of mass motion removal nstcomm = 1 ; group(s) for center of mass motion removal comm-grps = ; LANGEVIN DYNAMICS OPTIONS ; Friction coefficient (amu/ps) and random seed bd-fric = 0 ld-seed = 1993 ; ENERGY MINIMIZATION OPTIONS ; Force tolerance and initial step-size emtol = 100 emstep = 0.01 ; Max number of iterations in relax-shells niter = 20 ; Step size (ps^2) for minimization of flexible constraints fcstep = 0 ; Frequency of steepest descents steps when doing CG nstcgsteep = 1000 nbfgscorr = 10 ; TEST PARTICLE INSERTION OPTIONS rtpi = 0.05 ; OUTPUT CONTROL OPTIONS ; Output frequency for coords (x), velocities (v) and forces (f) nstxout = 5000 nstvout = 5000 nstfout = 0 ; Output frequency for energies to log file and energy file nstlog = 5000 nstcalcenergy = 100 nstenergy = 250 ; Output frequency and precision for .xtc file nstxout-compressed = 250 compressed-x-precision = 1000 ; This selects the subset of atoms for the compressed ; trajectory file. You can select multiple groups. By ; default, all atoms will be written. compressed-x-grps = Protein ; Selection of energy groups energygrps = Protein SOL ; NEIGHBORSEARCHING PARAMETERS ; cut-off scheme (Verlet: particle based cut-offs, group: using charge groups) cutoff-scheme = Verlet ; nblist update frequency nstlist = 10 ; ns algorithm (simple or grid) ns-type = grid ; Periodic boundary conditions: xyz, no, xy pbc = xyz periodic-molecules = no ; Allowed energy error due to the Verlet buffer in kJ/mol/ps per atom, ; a value of -1 means: use rlist verlet-buffer-tolerance = 0.005 ; nblist cut-off rlist = 0.8 ; long-range cut-off for switched potentials rlistlong = -1 nstcalclr = -1 ; OPTIONS FOR ELECTROSTATICS AND VDW ; Method for doing electrostatics coulombtype = cut-off coulomb-modifier = Potential-shift-Verlet rcoulomb-switch = 0 rcoulomb = 1.4 ; Relative dielectric constant for the medium and the reaction field epsilon-r = 1 epsilon-rf = 0 ; Method for doing Van der Waals vdw-type = Cut-off vdw-modifier = Potential-shift-Verlet ; cut-off lengths rvdw-switch = 0 rvdw = 0.8 ; Apply long range dispersion corrections for Energy and Pressure DispCorr = No ; Extension of the potential lookup tables beyond the cut-off table-extension = 1 ; Separate tables between energy group pairs energygrp-table = ; Spacing for the PME/PPPM FFT grid fourierspacing = 0.12 ; FFT grid size, when a value is 0 fourierspacing will be used fourier-nx = 0 fourier-ny = 0 fourier-nz = 0 ; EWALD/PME/PPPM parameters pme-order = 4 ewald-rtol = 1e-05 ewald-rtol-lj = 0.001 lj-pme-comb-rule = Geometric ewald-geometry = 3d epsilon-surface = 0 ; IMPLICIT SOLVENT ALGORITHM implicit-solvent = No ; GENERALIZED BORN ELECTROSTATICS ; Algorithm for calculating Born radii gb-algorithm = Still ; Frequency of calculating the Born radii inside rlist nstgbradii = 1 ; Cutoff for Born radii calculation; the contribution from atoms ; between rlist and rgbradii is updated every nstlist steps rgbradii = 1 ; Dielectric coefficient of the implicit solvent gb-epsilon-solvent = 80 ; Salt concentration in M for Generalized Born models gb-saltconc = 0 ; Scaling factors used in the OBC GB model. Default values are OBC(II) gb-obc-alpha = 1 gb-obc-beta = 0.8 gb-obc-gamma = 4.85 gb-dielectric-offset = 0.009 sa-algorithm = Ace-approximation ; Surface tension (kJ/mol/nm^2) for the SA (nonpolar surface) part of GBSA ; The value -1 will set default value for Still/HCT/OBC GB-models. sa-surface-tension = -1 ; OPTIONS FOR WEAK COUPLING ALGORITHMS ; Temperature coupling tcoupl = Berendsen nsttcouple = -1 nh-chain-length = 10 print-nose-hoover-chain-variables = no ; Groups to couple separately tc-grps = Protein SOL ; Time constant (ps) and reference temperature (K) tau-t = 0.1 0.1 ref-t = 300 300 ; pressure coupling Pcoupl = Berendsen Pcoupltype = Isotropic nstpcouple = -1 ; Time constant (ps), compressibility (1/bar) and reference P (bar) tau-p = 1.0 compressibility = 4.5e-5 ref-p = 1.0 ; Scaling of reference coordinates, No, All or COM refcoord-scaling = No ; OPTIONS FOR QMMM calculations QMMM = no ; Groups treated Quantum Mechanically QMMM-grps = ; QM method QMmethod = ; QMMM scheme QMMMscheme = normal ; QM basisset QMbasis = ; QM charge QMcharge = ; QM multiplicity QMmult = ; Surface Hopping SH = ; CAS space options CASorbitals = CASelectrons = SAon = SAoff = SAsteps = ; Scale factor for MM charges MMChargeScaleFactor = 1 ; Optimization of QM subsystem bOPT = bTS = ; SIMULATED ANNEALING ; Type of annealing for each temperature group (no/single/periodic) annealing = no ; Number of time points to use for specifying annealing in each group annealing-npoints = ; List of times at the annealing points for each group annealing-time = ; Temp. at each annealing point, for each group. annealing-temp = ; GENERATE VELOCITIES FOR STARTUP RUN gen-vel = yes gen-temp = 300 gen-seed = 173529 ; OPTIONS FOR BONDS constraints = all-bonds ; Type of constraint algorithm constraint-algorithm = Lincs ; Do not constrain the start configuration continuation = no ; Use successive overrelaxation to reduce the number of shake iterations Shake-SOR = no ; Relative tolerance of shake shake-tol = 0.0001 ; Highest order in the expansion of the constraint coupling matrix lincs-order = 4 ; Number of iterations in the final step of LINCS. 1 is fine for ; normal simulations, but use 2 to conserve energy in NVE runs. ; For energy minimization with constraints it should be 4 to 8. lincs-iter = 1 ; Lincs will write a warning to the stderr if in one step a bond ; rotates over more degrees than lincs-warnangle = 30 ; Convert harmonic bonds to morse potentials morse = no ; ENERGY GROUP EXCLUSIONS ; Pairs of energy groups for which all non-bonded interactions are excluded energygrp-excl = ; WALLS ; Number of walls, type, atom types, densities and box-z scale factor for Ewald nwall = 0 wall-type = 9-3 wall-r-linpot = -1 wall-atomtype = wall-density = wall-ewald-zfac = 3 ; COM PULLING ; Pull type: no, umbrella, constraint or constant-force pull = no ; ENFORCED ROTATION ; Enforced rotation: No or Yes rotation = no ; Group to display and/or manipulate in interactive MD session IMD-group = ; NMR refinement stuff ; Distance restraints type: No, Simple or Ensemble disre = No ; Force weighting of pairs in one distance restraint: Conservative or Equal disre-weighting = Equal ; Use sqrt of the time averaged times the instantaneous violation disre-mixed = no disre-fc = 1000 disre-tau = 0 ; Output frequency for pair distances to energy file nstdisreout = 100 ; Orientation restraints: No or Yes orire = no ; Orientation restraints force constant and tau for time averaging orire-fc = 0 orire-tau = 0 orire-fitgrp = ; Output frequency for trace(SD) and S to energy file nstorireout = 100 ; Free energy variables free-energy = no couple-moltype = couple-lambda0 = vdw-q couple-lambda1 = vdw-q couple-intramol = no init-lambda = 0 init-lambda-state = -1 delta-lambda = 0 nstdhdl = 50 fep-lambdas = mass-lambdas = coul-lambdas = vdw-lambdas = bonded-lambdas = restraint-lambdas = temperature-lambdas = calc-lambda-neighbors = 1 init-lambda-weights = dhdl-print-energy = no sc-alpha = 0 sc-power = 1 sc-r-power = 6 sc-sigma = 0.3 sc-coul = no separate-dhdl-file = yes dhdl-derivatives = yes dh_hist_size = 0 dh_hist_spacing = 0.1 ; Non-equilibrium MD stuff acc-grps = accelerate = freezegrps = freezedim = cos-acceleration = 0 deform = ; simulated tempering variables simulated-tempering = no simulated-tempering-scaling = geometric sim-temp-low = 300 sim-temp-high = 300 ; Electric fields ; Format is number of terms (int) and for all terms an amplitude (real) ; and a phase angle (real) E-x = E-xt = E-y = E-yt = E-z = E-zt = ; Ion/water position swapping for computational electrophysiology setups ; Swap positions along direction: no, X, Y, Z swapcoords = no ; AdResS parameters adress = no ; User defined thingies user1-grps = user2-grps = userint1 = 0 userint2 = 0 userint3 = 0 userint4 = 0 userreal1 = 0 userreal2 = 0 userreal3 = 0 userreal4 = 0","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[]},{"title":"VMD安装教程","slug":"vmd安装教程","date":"2015-12-31T05:17:54.000Z","updated":"2017-10-28T03:29:16.960Z","comments":true,"path":"113.html","link":"","permalink":"http://kangsgo.com/113.html","excerpt":"","text":"网上VMD安装教程很多，也非常简单，在这里我只是为了给自己做一下笔记记录一下。 软件下载地址：点我下载 我选择的版本为：LINUX_64 OpenGL, CUDA, TachyonL-OptiX 下载后我放在了1/home/kangsgo/mdinstall/plot/ 文件夹下 解压文件12tar -xvf vmd-1.9.2.bin.LINUXAMD64-RHEL5.opengl.tar.gzcd vmd-1.9.2 修改编译脚本： 1gedit configure 修改两行变为：12# Directory where VMD startup script is installed, should be in users’ paths.$install_bin_dir=”/home/kangsgo/mdinstall/plot/vmd-1.9.2/bin”; →修改成刚刚解压的文件夹中bin的目录； 12# Directory where VMD files and executables are installed$install_library_dir=”/home/kangsgo/mdinstall/plot/vmd-1.9.2/lib/$install_name”; →修改成刚刚解压的文件夹中lib的目录；编译设置： 1./configure LINUXAMD64 尾缀意义不详 123cd srcmake install 在zshrc中添加一行（具体添加方法查看以前文章）12# vmdexport PATH=”$PATH:/home/kangsgo/mdinstall/plot/vmd-1.9.2/bin/:.” 参考文献：VMD-LINUX64安装教程","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"安装","slug":"安装","permalink":"http://kangsgo.com/tags/安装/"}]},{"title":"Gromacs共轭梯度法mdp设置","slug":"Gromacs共轭梯度法mdp设置","date":"2015-12-15T15:44:55.000Z","updated":"2017-10-28T14:16:08.098Z","comments":true,"path":"106.html","link":"","permalink":"http://kangsgo.com/106.html","excerpt":"","text":"来源：嘉晔@武汉","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"gromacs下蛋白-配体复合物模拟[GAFF]","slug":"gromacs下蛋白-配体复合物模拟[GAFF]","date":"2015-12-05T08:10:06.000Z","updated":"2018-01-19T14:20:19.609Z","comments":true,"path":"94.html","link":"","permalink":"http://kangsgo.com/94.html","excerpt":"","text":"gromacs小分子的配体的电荷问题一直时gromacs模拟蛋白-配体复合物中的难点与重点～网上有许多相关方面的教程，但是都没有成为系统，应李继存老师之邀，把最近摸索的方法过程总结出来，分享给大家～感谢网络上的朋友对我的帮助～ 我们以我现在在做的蛋白配体复合物进行模拟，蛋白质为AhR的PAS-B结构域，其是AhR转录因子的配体结合区～TCDD复合物是AhR的经典激动剂。 由于AhR晶体结构并未解析，建模的方法我在这里不累述 你可以在这里下载初始文件:tcddPhe289Ala.tar mdp文件建议从压缩包中的进行修改，以免直接复制导致换行问题。 1.高斯输入文件建立 1antechamber -i tcdd-h.mol2 -fi mol2 -o tcdd.gjf -fo gcrt -pf y -gm \"%mem=1024MB\" -gn \"%nproc=2\" -nc 0 -gk \"#HF/6-31G*SCF=tight Test Pop=MK iop(6/33=2) iop(6/42=6) iop(6/50=1) opt nosymm\" -ge tcdd_resp.gesp -gv 1 其中nosymm是是否保留坐标，可以不加。高斯windows版本内存最多使用1G 2.运行高斯 1g09 tcdd.gjf 3.拟合成resp文件 1antechamber -i tcdd_resp.gesp -fi gesp -o tcdd.mol2 -fo mol2 -pf y -c resp -rn TCD 4.生成缺失参数文件 1parmchk2 -i tcdd.mol2 -f mol2 -o tcdd.frcmod 5.生成AMBER参数文件及坐标文件 1234567source leaprc.ff99SB source leaprc.gaff loadamberparams tcdd.frcmod lig=loadmol2 tcdd.mol2 check lig saveamberparm lig tcdd.prmtop tcdd.inpcrd quit 命名为leap.in 1tleap -f leap.in 6.将AMBER文件转换为GROMACS文件 这里有两种办法amb2gmx.pl和acpype.py，一般使用后者 命令如下： 1python2.7 acpype -p tcdd.prmtop -x tcdd.inpcrd -d 将会得到MOL_GMX.gro和MOL_GMX.top两个文件为下面做准备 7.准备蛋白质的拓扑 1gmx pdb2gmx -f mAhR.pdb -o mAhR_processed.gro -water tip3p 注：群里说tip3p准确度比spec高 力场选择amber99SB 5 8.准备小分子拓扑结构 将得到的TCD_GMX.top中顶部的[defaults]，[ atomtypes ]，底部的[ system ]，[ molecules ]删除，改名为TCD.itp。记得[ moleculetype ]需要被保留!! 复制mAhR_processed.gro，重命名为complex.gro 将TCD_GMX.gro中内容： 123456789101112131415161718192021221 TCD CL1 1 1.163 -4.344 0.9121 TCD CL2 2 1.223 -4.088 0.7261 TCD CL3 3 2.103 -4.309 1.2631 TCD CL4 4 2.164 -4.054 1.0771 TCD O1 5 1.637 -4.310 1.0761 TCD O2 6 1.690 -4.088 0.9131 TCD C1 7 1.542 -4.258 0.9941 TCD C2 8 1.568 -4.148 0.9141 TCD C3 9 1.759 -4.250 1.0751 TCD C4 10 1.785 -4.140 0.9951 TCD C5 11 1.417 -4.317 0.9921 TCD C6 12 1.469 -4.098 0.8321 TCD C7 13 1.857 -4.300 1.1571 TCD C8 14 1.909 -4.081 0.9971 TCD C9 15 1.318 -4.266 0.9111 TCD C10 16 1.344 -4.156 0.8301 TCD C11 17 1.983 -4.242 1.1591 TCD C12 18 2.009 -4.132 1.0791 TCD H1 19 1.399 -4.402 1.0551 TCD H2 20 1.490 -4.013 0.7711 TCD H3 21 1.836 -4.385 1.2181 TCD H4 22 1.928 -3.996 0.934 添加到complex.gro底部数字行上面将顶部1741加22个原子改为1763，保存。 在topol文件中添加小分子的位置限制： 123456789101112131415; Include Position restraint file#ifdef POSRES#include &quot;posre.itp&quot;#endif; Include ligand topology #include &quot;TCD.itp&quot; ; Include water topology#include &quot;amber99sb.ff/tip3p.itp&quot;[ molecules ]; Compound #molsProtein 1TCD 1 [注：增加了itp文件，以及molecules增加了小分子，即：] 12; Include ligand topology #include &quot;TCD.itp&quot; 1TCD 1 9.定义单元盒子 1gmx editconf -f complex.gro -o newbox.gro -bt cubic -d 1.2 1gmx solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro 用vmd观察蛋白体系是否在盒子内部 个人感觉盒子可以调小一些～ 10.添加离子 教程使用了能量最小化的文件，我这里稍微改了一下 1234567891011121314151617181920212223; LINES STARTING WITH &apos;;&apos; ARE COMMENTStitle = Minimization ; 标题define = -DFLEXIBLE ;使用柔性水模型而非刚性模型, 这样最陡下降法可进一步最小化能量; Parameters describing what to do, when to stop and what to save; 参数描述如何做，当模拟结束后如何保存integrator = steep ; Algorithm (steep = steepest descent minimization) 最陡梯度法emtol = 1000.0 ; Stop minimization when the maximum force &lt; 10.0 kJ/mol 当小于多少能量以后停止最小化emstep = 0.01 ; Energy step size 能量步大小nsteps = 50000 ; Maximum number of (minimization) steps to perform 最大最小化步骤energygrps = system ; Which energy group(s) to write to disk 哪个组进行能量最小化; Parameters describing how to find the neighbors of each atom and how to calculate the interactions; 参数描述怎样寻找邻近的原子，怎么样计算相互联系nstlist = 1 ; Frequency to update the neighbor list and long range forces 更新近邻列表的频率. 1表示每步都更新cutoff-scheme = Verlet ; With cutoff-scheme=Verlet and verlet-buffer-tolerance set, nstlist is actually a minimum value and mdrun might increase it, unless it is set to 1 这样设置更加精确（看英文貌似是的）ns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces) 短程力近邻列表的截断值coulombtype = PME ; Treatment of long range electrostatic interactions 计算长程静电的方法. PME为粒子网格Ewald方法, 还可以使用cut-offrcoulomb = 1.0 ; long range electrostatic cut-off 长程库仑力截断值rvdw = 1.0 ; long range Van der Waals cut-off 范德华距离截断值constraints = none ;无位置限制pbc = xyz ; Periodic Boundary Conditions 周期性 我们这里还需要查看topol文件，看一下我们的体系电荷多少，需要补足电荷，可以看出我们需要补4个CL离子 topol 1gmx grompp -f em.mdp -c solv.gro -p topol.top -o ions.tpr 做到这里会报错，我找了很久原因，后来查看amber力场文件，发现是大小写不同导致的我们来看一下我们的TCD.itp文件 12345678910111213141516171819202122 1 Cl 1 TCD CL1 1 -0.072622 35.45000 ; qtot -0.073 2 Cl 1 TCD CL2 2 -0.072622 35.45000 ; qtot -0.145 3 Cl 1 TCD CL3 3 -0.072622 35.45000 ; qtot -0.218 4 Cl 1 TCD CL4 4 -0.072622 35.45000 ; qtot -0.290 5 OS 1 TCD O1 5 -0.320484 16.00000 ; qtot -0.611 6 OS 1 TCD O2 6 -0.320484 16.00000 ; qtot -0.931 7 CA 1 TCD C1 7 0.247670 12.01000 ; qtot -0.684 8 CA 1 TCD C2 8 0.247670 12.01000 ; qtot -0.436 9 CA 1 TCD C3 9 0.247670 12.01000 ; qtot -0.18810 CA 1 TCD C4 10 0.247670 12.01000 ; qtot 0.05911 CA 1 TCD C5 11 -0.253268 12.01000 ; qtot -0.19412 CA 1 TCD C6 12 -0.253268 12.01000 ; qtot -0.44713 CA 1 TCD C7 13 -0.253268 12.01000 ; qtot -0.70114 CA 1 TCD C8 14 -0.253268 12.01000 ; qtot -0.95415 CA 1 TCD C9 15 0.041544 12.01000 ; qtot -0.91216 CA 1 TCD C10 16 0.041544 12.01000 ; qtot -0.87117 CA 1 TCD C11 17 0.041544 12.01000 ; qtot -0.82918 CA 1 TCD C12 18 0.041544 12.01000 ; qtot -0.78819 HA 1 TCD H1 19 0.196918 1.00800 ; qtot -0.59120 HA 1 TCD H2 20 0.196918 1.00800 ; qtot -0.39421 HA 1 TCD H3 21 0.196918 1.00800 ; qtot -0.19722 HA 1 TCD H4 22 0.196918 1.00800 ; qtot -0.000 然而amber99SB力场下如是写的： 1Cl 17 35.45 0.0000 A 4.40104e-01 4.18400e-01 以下有两种方法解决:方法一: 我们需要将top文件的[ atomtypes ]可以写入相应力场的ffnonbonded.itp中，这个方法更加的实用。此方法不建议再使用 个人认为比较稳妥且不会污染力场的方法为将力场文件复制出来，然后在当前目录中进行修改，如果采用apt-get安装，可以在usr/share/gromacs/top下查找对应力场文件,例如拷贝amber99sb-ildn-ligand.ff力场文件，重命名为amber99sb-ildn-ligand.ff，将; Include forcefield parameters下面一行修改为： 1#include &quot;amber99sb-ildn-ligand.ff/forcefield.itp&quot; topol文件其它引用力场的位置可修改可不修改，个人觉得最好修改 方法二:(建议使用该方法) 将[ atomtypes ]写入拓扑中，位于12; Include forcefield parameters#include &quot;amber99sb-ildn.ff/forcefield.itp&quot; 和123[ moleculetype ]; Name nrexclProtein 3 之间，例如下:1234567891011121314151617181920; Include forcefield parameters#include &quot;amber99sb-ildn.ff/forcefield.itp&quot;[ atomtypes ];name bond_type mass charge ptype sigma epsilon Amb c3 c3 0.00000 0.00000 A 3.39967e-01 4.57730e-01 ; 1.91 0.1094 nh nh 0.00000 0.00000 A 3.25000e-01 7.11280e-01 ; 1.82 0.1700 hn hn 0.00000 0.00000 A 1.06908e-01 6.56888e-02 ; 0.60 0.0157 cc cc 0.00000 0.00000 A 3.39967e-01 3.59824e-01 ; 1.91 0.0860 ca ca 0.00000 0.00000 A 3.39967e-01 3.59824e-01 ; 1.91 0.0860 na na 0.00000 0.00000 A 3.25000e-01 7.11280e-01 ; 1.82 0.1700 cd cd 0.00000 0.00000 A 3.39967e-01 3.59824e-01 ; 1.91 0.0860 hc hc 0.00000 0.00000 A 2.64953e-01 6.56888e-02 ; 1.49 0.0157 h1 h1 0.00000 0.00000 A 2.47135e-01 6.56888e-02 ; 1.39 0.0157 ha ha 0.00000 0.00000 A 2.59964e-01 6.27600e-02 ; 1.46 0.0150 h4 h4 0.00000 0.00000 A 2.51055e-01 6.27600e-02 ; 1.41 0.0150[ moleculetype ]; Name nrexclProtein 3 2 然后就是添加离子了现在有一种快速添加的方法，即平衡为中性，如下:1gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -neutral 当然还有手动平衡的方法如下: 1gmx genion -s ions.tpr -o solv_ions.gro -p topol.top -pname NA -nname CL -nn 4 -nn 表示的添加阴离子数目 选择15，添加在水溶剂里面 会有如下话： 12345Back Off! I just backed up topol.top to ./#topol.top.2#Replacing solvent molecule 1173 (atom 5282) with CLReplacing solvent molecule 3252 (atom 11519) with CLReplacing solvent molecule 2563 (atom 9452) with CLReplacing solvent molecule 10648 (atom 33707) with CL 表示插入进去了 11.能量最小化 参数文件如下： 123456789101112131415161718192021; LINES STARTING WITH &apos;;&apos; ARE COMMENTStitle = Minimization ; Title of rundefine = -DFLEXIBLE; Parameters describing what to do, when to stop and what to saveintegrator = steep ; Algorithm (steep = steepest descent minimization)emtol = 500.0 ; Stop minimization when the maximum force &lt; 5.0 kJ/molemstep = 0.01 ; Energy step sizensteps = 50000 ; Maximum number of (minimization) steps to performenergygrps = Protein TCD ; Which energy group(s) to write to disk; Parameters describing how to find the neighbors of each atom and how to calculate the interactionsnstlist = 1 ; Frequency to update the neighbor list and long range forcescutoff-scheme = Verletns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces)coulombtype = PME ; Treatment of long range electrostatic interactionsrcoulomb = 1.0 ; long range electrostatic cut-offrvdw = 1.0 ; long range Van der Waals cut-offconstraints = nonepbc = xyz ; Periodic Boundary Conditions 能量组为energygrps = Protein TCD，这里TCD需要根据自己的体系进行修改，下同 1energygrps = Protein TCD 1gmx grompp -f em_real.mdp -c solv_ions.gro -p topol.top -o em.tpr 运行模拟 1gmx mdrun -v -deffnm em 个人认为在运行模拟之前要搞懂参数的意义，所幸这里有中文参考教程，因为要去吃饭了～这里就使用默认的先 我们发现700步就收敛了，所以我决定改成emtol= 1000修改成500再跑1234567891888步收敛了～所以我尝试删掉emtol= 1000但是通过前面的教程，其也是500来步就已经收敛了～结果如图PS：作图方法如下：```bashgmx energy -f em.edr -o potential.xvg 选择 10 0 potential 再用共轭梯度法，mdp文件参数如下： 12345678910111213141516171819202122; LINES STARTING WITH &apos;;&apos; ARE COMMENTStitle = Minimization ; Title of rundefine = -DFLEXIBLE; Parameters describing what to do, when to stop and what to saveintegrator = cg ; Algorithm (steep = steepest descent minimization)emtol = 100.0 ; Stop minimization when the maximum force &lt; 10.0 kJ/molemstep = 0.01 ; Energy step sizensteps = 50000 ; Maximum number of (minimization) steps to performnstcgsteep = 1000energygrps = Protein TCD ; Which energy group(s) to write to disk; Parameters describing how to find the neighbors of each atom and how to calculate the interactionsnstlist = 1 ; Frequency to update the neighbor list and long range forcescutoff-scheme = Verletns_type = grid ; Method to determine neighbor list (simple, grid)rlist = 1.0 ; Cut-off for making neighbor list (short range forces)coulombtype = PME ; Treatment of long range electrostatic interactionsrcoulomb = 1.0 ; long range electrostatic cut-offrvdw = 1.0 ; long range Van der Waals cut-offconstraints = nonepbc = xyz ; Periodic Boundary Conditions &nbsp; 1gmx grompp -f em2.mdp -c em.gro -p topol.top -o em2.tpr 运行模拟 1gmx mdrun -v -deffnm em2 做出来如这个图，图是否正确待考 potential2 &nbsp; 12.NVT平衡（温度平衡） 限制配体： 1gmx genrestr -f TCD.gro -o posre_TCD.itp -fc 1000 1000 1000 在选择组过程中个人觉得选择system或者TCD均可 3 增加配体限制： 1234567891011; Include ligand topology#include \"TCD.itp\"; Ligand position restraints #ifdef POSRES #include \"posre_TCD.itp\" #endif; Include water topology#include \"amber99sb.ff/tip3p.itp\" [注：插入的为] 1234; Ligand position restraints #ifdef POSRES #include &quot;posre_TCD.itp&quot; #endif 其实这里还可以分开限制（具体这里还是没有特别理解～待我看一下参考资料） 热浴 –温度耦合需要蛋白质和配体在一起？ 1gmx make_ndx -f em2.gro -o index.ndx 选择蛋白和配体分为一组 4 然后就可以热浴了～热浴的mdp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243title = Protein-ligand complex NVT equilibration define = -DPOSRES ; position restrain the protein and ligand; Run parametersintegrator = md ; leap-frog integratornsteps = 50000 ; 2 * 50000 = 100 psdt = 0.002 ; 2 fs; Output controlnstxout = 200 ; save coordinates every 1.0 psnstvout = 200 ; save velocities every 1.0 psnstenergy = 200 ; save energies every 1.0 psnstlog = 200 ; update log file every 1.0 psenergygrps = Protein TCD; Bond parameterscontinuation = no ; first dynamics runconstraint_algorithm = lincs ; holonomic constraints constraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verletrcoulomb = 1.4 ; short-range electrostatic cutoff (in nm)rvdw = 1.4 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature couplingtcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein_TCD Water_and_ions ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure couplingpcoupl = no ; no pressure coupling in NVT; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = yes ; assign velocities from Maxwell distributiongen_temp = 300 ; temperature for Maxwell distributiongen_seed = -1 ; generate a random seed &nbsp; 12gmx grompp -f nvt.mdp -c em2.gro -p topol.top -n index.ndx -o nvt.tprgmx mdrun -deffnm nvt 完成后我的析出如图： 1234567NOTE: The GPU has &gt;20% more load than the CPU. This imbalance causes performance loss, consider using a shorter cut-off and a finer PME grid. Core t (s) Wall t (s) (%) Time: 3799.500 518.255 733.1 (ns/day) (hour/ns)Performance: 16.672 1.440 可以看出我的GPU太渣，暂时没有想到解决办法 我们来看一下NVT耦合的怎么样 1gmx energy -f nvt.edr -o template.xvg 选择15 0 template 13.NPT平衡mdp文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546title = Protein-ligand complex NPT equilibration define = -DPOSRES ; position restrain the protein and ligand; Run parametersintegrator = md ; leap-frog integratornsteps = 50000 ; 2 * 50000 = 100 psdt = 0.002 ; 2 fs; Output controlnstxout = 200 ; save coordinates every 1.0 psnstvout = 200 ; save velocities every 1.0 psnstenergy = 200 ; save energies every 1.0 psnstlog = 200 ; update log file every 1.0 psenergygrps = Protein TCD; Bond parameterscontinuation = yes ; first dynamics runconstraint_algorithm = lincs ; holonomic constraints constraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verletrcoulomb = 1.4 ; short-range electrostatic cutoff (in nm)rvdw = 1.4 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature couplingtcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein_TCD Water_and_ions ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure couplingpcoupl = Parrinello-Rahman ; pressure coupling is on for NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1refcoord_scaling = com; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; velocity generation off after NVT 注意，耦合组为Protein_TCD，自己的体系需要修改成自己的，下同 123gmx grompp -f npt.mdp -c nvt.gro -t nvt.cpt -p topol.top -n index.ndx -o npt.tprgmx mdrun -deffnm npt 先看一下压力 1gmx energy -f npt.edr -o pressure.xvg 选择 16 0 pressure 再来看一下密度 1gmx energy -f npt.edr -o density.xvg 选择 22 0 density 可以看出在1000左右，符合水的密度，个人觉得tip3p效果比spec水模型效果好 14.成品MD 一般MD需要100ns以上，但是我的电脑我怕受不了，就先50ns吧～大约需要3天-4天左右 12345678910111213141516171819202122232425262728293031323334353637383940414243444546title = Protein-ligand complex MD simulation ; Run parametersintegrator = md ; leap-frog integratornsteps = 25000000 ; 2 * 25000000 = 50000 ps (50 ns)dt = 0.002 ; 2 fs; Output controlnstxout = 0 ; suppress .trr output nstvout = 0 ; suppress .trr outputnstenergy = 5000 ; save energies every 10.0 psnstlog = 5000 ; update log file every 10.0 psnstxout-compressed = 5000 ; write .xtc trajectory every 10.0 pscompressed-x-grps = Systemenergygrps = Protein TCD; Bond parameterscontinuation = yes ; first dynamics runconstraint_algorithm = lincs ; holonomic constraints constraints = all-bonds ; all bonds (even heavy atom-H bonds) constrainedlincs_iter = 1 ; accuracy of LINCSlincs_order = 4 ; also related to accuracy; Neighborsearchingcutoff-scheme = Verletns_type = grid ; search neighboring grid cellsnstlist = 10 ; 20 fs, largely irrelevant with Verletrcoulomb = 1.4 ; short-range electrostatic cutoff (in nm)rvdw = 1.4 ; short-range van der Waals cutoff (in nm); Electrostaticscoulombtype = PME ; Particle Mesh Ewald for long-range electrostaticspme_order = 4 ; cubic interpolationfourierspacing = 0.16 ; grid spacing for FFT; Temperature couplingtcoupl = V-rescale ; modified Berendsen thermostattc-grps = Protein_TCD Water_and_ions ; two coupling groups - more accuratetau_t = 0.1 0.1 ; time constant, in psref_t = 300 300 ; reference temperature, one for each group, in K; Pressure coupling pcoupl = Parrinello-Rahman ; pressure coupling is on for NPTpcoupltype = isotropic ; uniform scaling of box vectorstau_p = 2.0 ; time constant, in psref_p = 1.0 ; reference pressure, in barcompressibility = 4.5e-5 ; isothermal compressibility of water, bar^-1; Periodic boundary conditionspbc = xyz ; 3-D PBC; Dispersion correctionDispCorr = EnerPres ; account for cut-off vdW scheme; Velocity generationgen_vel = no ; assign velocities from Maxwell distribution 注意：nsteps = 25000000 ; 2 * 25000000 = 50000 ps (50 ns) 这里修改时长，同时注意修改耦合组成为自己的 12gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -n index.ndx -o md_0_1.tprgmx mdrun -deffnm md_0_1 经过2d12h的计算，终于完成了，即高兴又紧张。 5 由于这个贴实在太长，另外开一贴 参考文献：自动计算ESP和RESP电荷(AMBER and G09) 参考文献：小分子在GAFF立场GROMCA中的操作 参考文献：使用AmberTools+ACPYPE+Gaussian创建小分子GAFF力场的拓扑文件 参考文献：蛋白质配体复合物","categories":[{"name":"分子模拟","slug":"分子模拟","permalink":"http://kangsgo.com/categories/分子模拟/"}],"tags":[{"name":"Gromacs","slug":"Gromacs","permalink":"http://kangsgo.com/tags/Gromacs/"}]},{"title":"Autodock与AutoDock vina利用pymol插件使用教程","slug":"Autodock与AutoDock vina利用pymol插件使用教程","date":"2015-12-04T13:12:53.000Z","updated":"2017-10-29T03:01:37.385Z","comments":true,"path":"89.html","link":"","permalink":"http://kangsgo.com/89.html","excerpt":"","text":"英文版教程：点我查看 中文版教程：严重的然后口头禅····· 你可能需要用到的： 1.ADT和Autodock/vina的安装 2.Pymol安装与问题解决 3.Pymol插件：Autodock/Vina","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Autodock","slug":"Autodock","permalink":"http://kangsgo.com/tags/Autodock/"}]},{"title":"Pymol插件：Autodock/Vina","slug":"Pymol插件AutodockVina","date":"2015-12-03T15:08:41.000Z","updated":"2017-11-12T07:38:54.916Z","comments":true,"path":"68.html","link":"","permalink":"http://kangsgo.com/68.html","excerpt":"","text":"大家知道在AutoDockTools中使用AutoDock Vina特别的复杂，但是Pymol这个插件非常的好用，可以代替AutoDockTools的使用，但是需要注意以下几点： 1. 该插件能正常使用的前提是：已经正常安装ADT/AutoDockTools；已经下载并安装AutoDock 和/或 AutoDock Vina。 2. 该插件的功能只是为AutoDock及AutoDock的运行提供一个图形用户界面（GUI），本身并无对接功能。 3. 在大多数情况下，你可能在安装autodock.py并重启后，并未在插件中见到Autodock/Vina这一栏，却在PyMOL的命令行窗口见到错误信息，显示“no NumPy module”之类的字眼。这说明在你的计算机中还未安装Numpy模块，只需再去下载安装该模块即可。下载的地址为http://sourceforge.net/projects/numpy/files/NumPy/，但是这里还需要说明的一点是，因为NumPy模块是和Python的版本挂钩的，所以最好下载和你使用的PyMOL配套的那个Python版本的NumPy，安装时选择该Python的安装路径（一般默认即可）。 4. 如果你已经正常的完成了上面的步骤，那么现在就可以开始在PyMOL中使用AutoDock和AutoDock Vina了：打开PyMol，在菜单栏选择Plugin &gt; Autodock/Vina但是我推荐使用集成了LeDock插件的AutoDock修饰插件，这样在使用LeDock时就不需要额外再装了。我这里下载了分享给大家 ad_plug_start 原版插件：点我下载 集成了LeDock盒子分析：点我下载 参考文章：pyMOL插件6-Autodock plugin","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Dock","slug":"Dock","permalink":"http://kangsgo.com/tags/Dock/"},{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"ADT和Autodock/vina的安装","slug":"ADT和Autodockvina的安装","date":"2015-12-03T14:54:46.000Z","updated":"2017-10-29T03:02:10.578Z","comments":true,"path":"64.html","link":"","permalink":"http://kangsgo.com/64.html","excerpt":"","text":"文章经：天理-小新发表的修改而成 大家对于audodock及autodocktools的安装问题及运行错误问题，就发到本帖子中，以方便大家以后参阅，谢谢%￥在此建议大家使用linux系统安装运行autodock和ADT因为: 1、win下的运行速度比linux下的运行速度慢 2、win下运行容易出错，第一次可能在win下运行成功，第二次可能生存的dlg文件很大，win下的autodock 不停的运行下去。对于linux系统的AutoDock/Vina和ADT的安装如下（有关win下安装的我就不写了，我不推荐）： 一.AutoDock Vina的安装1.进入目录本人默认安装在（kangsgo的主目录的mdinstall/dock文件夹下） 1cd /home/kangsgo/mdinstall/dock/ 2.解压1tar xvzf autodock_vina_1_1_2_linux_x86.tgz 3.进入目录1cd autodock_vina_1_1_2_linux_x86/bin 4.移动123sudo mv vina /usr/local/bin sudo mv vina_split /usr/local/bin 二.AutoDock安装一模一样，这里就不再啰嗦解压缩的命令应该是这样的： 1tar -xvf autodocksuite-4.2.6-x86_64Linux2.tar 三. AutoDockTools安装1.增加权限：1chmod +x MGLTools-1.5.4-Linux-x86-Install 2.安装 双击 MGLTools-1.5.4-Linux-x86-Install 图标，一直默认点击下去就可成功安装 深度截图20151203225152 安装完后既可以直接打开，若需要在终端中可以使用可以设置环境变量具体可以查看gromacs的安装教程，这里就不再累述。 &nbsp; 深度截图20151203225234","categories":[{"name":"分子对接","slug":"分子对接","permalink":"http://kangsgo.com/categories/分子对接/"}],"tags":[{"name":"Autodock","slug":"Autodock","permalink":"http://kangsgo.com/tags/Autodock/"},{"name":"Dock","slug":"Dock","permalink":"http://kangsgo.com/tags/Dock/"},{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"}]},{"title":"Ctrl+Alt+F1黑屏解决办法","slug":"Ctrl+Alt+F1黑屏解决办法","date":"2015-12-02T20:26:42.000Z","updated":"2017-10-29T03:03:13.290Z","comments":true,"path":"55.html","link":"","permalink":"http://kangsgo.com/55.html","excerpt":"","text":"今天晚上为了安装CUDA弄了半天，一切都是为了省那么1G的流量，哎，学校按照流量收费真的花不起啊～ 由于CUDA需要进入tty来解决，但是我电脑打开偏偏又黑屏，找到好久才找到一个解决办法： 编辑/etc/default/grub 修改GRUB_CMDLINE_LINUX_DEFAULT的值为nomodeset 更新grub：sudo update-grub 重启 参考文章：安装NVidia显卡驱动不能进","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"Pymol安装与问题解决","slug":"Pymol安装与问题解决","date":"2015-12-02T16:58:30.000Z","updated":"2017-10-28T03:52:49.681Z","comments":true,"path":"47.html","link":"","permalink":"http://kangsgo.com/47.html","excerpt":"","text":"Pymol是一个开放源码，由使用者赞助的分子三维结构显示软件，由Warren Lyford DeLano编写，并且由DeLano Scientific LLC负责商业发行。 Pymol被用来创作高品质的分子（特别是生物大分子如蛋白质）三维结构。据软件作者宣称，在所有正式发表的科学论文中的蛋白质结构图像中，有四分之一是使用Pymol来制作的。 Pymol名字的来源：“Py”表示该软件基于python这个计算机语言，“Mol”则是英文分子（molucule）的缩写，表示该软件用来显示分子结构。 安装方法：1sudo apt-get install pymol 我们通过pymol命令运行，看似安装成功，但是我们打开时会终端出现： Segmentation fault 深度截图20151203010035 出现这个问题主要是栈溢出造成的，因为默认ubuntu只有8MB，所以我们需要增加栈桥大小 百度上给予了这些方法： 在/etc/profile 的最后面添加ulimit -s unlimited 保存，source /etc/profile使修改文件生效 linux查看修改线程默认栈空间大小 ：ulimit -s 1、通过命令 ulimit -s 查看linux的默认栈空间大小，默认情况下 为10240 即10M 2、通过命令 ulimit -s 设置大小值 临时改变栈空间大小：ulimit -s 102400， 即修改为100M 3、可以在/etc/rc.local 内 加入 ulimit -s 102400 则可以开机就设置栈空间大小 4、在/etc/security/limits.conf 中也可以改变栈空间大小： #&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; soft stack 102400 重新登录，执行ulimit -s 即可看到改为102400 即100M 深度截图20151203010949 最好我的方法是:1sudo gedit /etc/profile 在最后一行增加：1234# add ulimitulimit -s 102400 重启，再ulimit -s 发现变为1102400 完美解决！ 1.如果自行安装最新的编译包，只需（倘若安装在我的kangsgo主目录的mdinstall/plot/py目录下）： python setup.py build install –home=/home/kangsgo/mdinstall/plot/py 2.设置环境变量：1234567~/.zshrc# pymolexport PATH=”$PATH:/home/kangsgo/mdinstall/plot/py/bin/:.”source ~/.zshrc 倘若还不行请安装openGL环境或者直接上CUDA 深度截图20151203051619","categories":[{"name":"绘图与可视化","slug":"绘图与可视化","permalink":"http://kangsgo.com/categories/绘图与可视化/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://kangsgo.com/tags/软件安装/"},{"name":"Pymol","slug":"Pymol","permalink":"http://kangsgo.com/tags/Pymol/"}]},{"title":"CUDA驱动安装","slug":"CUDA驱动安装","date":"2015-12-02T16:29:01.000Z","updated":"2017-10-29T03:08:24.471Z","comments":true,"path":"40.html","link":"","permalink":"http://kangsgo.com/40.html","excerpt":"","text":"由于gromacs，amber等都需要CUDA的安装，所以我们将其额外的提出来讲解其安装 点击下载：CUDA驱动 我的选择如下： 第一个和第二个为本地安装，第三个为在线安装 深度截图20151203002727 之后按照如下提示即可： 1.进入下载的目录，本人的为（/home/kangsgo/mdinstall/）1cd /home/kangsgo/mdinstall 2.直接按照底部说的安装123sudo dpkg -i cuda-repo-ubuntu1404_7.5-18_amd64.debsudo apt-get updatesudo apt-get install cuda 3.设置环境变量123456789gedit(或者vi进入文本编辑模式) ~/.zshrc (ubuntu客户端为bashrc，后面都需要修改，下同)# CUDAexport PATH=”$PATH:/usr/local/cuda-7.5/bin”export LD_LIBRARY_PATH=”$LD_LIBRARY_PATH:/usr/local/cuda-7.5/lib64“具体目录需要自己进入usr/local/ 查看source ~/.zshrc 到此结束 倘若你下载的为run编译包，我试了，但是有一点问题，建议在线安装Run编译包安装如下： 1.建立连接（个人测试这个并没有用）：1sudo ln -s /usr/lib/x86_64-linux-gnu/libGLU.so.1.3.1 /usr/lib/libGLU.so 2.切换至tty1Ctrl+Alt+F1 倘若出现黑屏按照此文进行修改：点击进入 3.关闭X-windows1sudo service lightdm stop 4.赋权：1sudo sh cuda-7.5.18-linux.run 5.安装一路accept-yes-yes-default等待默认即可 6.重新启动X-Window：1sudo service lightdm start 7.环境变量设置1234567~/.zshrcexport PATH=/usr/local/cuda-7.5/bin:$PATH’export LD_LIBRARY_PATH=/usr/local/cuda-7.5/lib64:$LD_LIBRARY_PATHsource ~/.zshrc 本人完成后sample会有报错，暂未发现影响和解决办法 参考文章：Caffe + Ubuntu 14.04 64bit + CUDA 6.5 配置说明","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kangsgo.com/categories/Linux/"}],"tags":[]},{"title":"Sci-hub下载文献方法","slug":"Sci-hub下载文献方法","date":"2015-11-28T18:55:47.000Z","updated":"2017-10-28T03:37:39.918Z","comments":true,"path":"10.html","link":"","permalink":"http://kangsgo.com/10.html","excerpt":"","text":"Sci-hub是一个非常好用的下载文献的在线网站，只需要输入DOI号或者连接，就会析出想要的文章 （不是全部）。方法也很简单： SCI-HUB地址：sci-hub.io 首先搜索到你需要的论文DOI号： 图片1 找到文章的DOI号，或者杂志的连接，输入网址：http://sci-hub.io 图片2 输入你找到的doi号或者连接 图片3 可以下载啦~ 图片1","categories":[{"name":"杂项","slug":"杂项","permalink":"http://kangsgo.com/categories/杂项/"}],"tags":[{"name":"文献下载","slug":"文献下载","permalink":"http://kangsgo.com/tags/文献下载/"}]}]}